  }));

export const createError = (
  status: number,
  code: string,
  message: string,
  fields?: FieldError[],
): AppError => new AppError(status, code, message, fields);

export const badRequest = (code: string, message: string, fields?: FieldError[]): AppError =>
  createError(400, code, message, fields);

export const unauthorized = (code: string, message: string): AppError =>
  createError(401, code, message);

export const forbidden = (code: string, message: string): AppError =>
  createError(403, code, message);

export const notFound = (code: string, message: string): AppError =>
  createError(404, code, message);

export const conflict = (code: string, message: string): AppError =>
  createError(409, code, message);

export const validationError = (error: ZodError | FieldError[]): AppError => {
  if (Array.isArray(error)) {
    return badRequest("invalid_body", "Validation failed", error);
  }
  return badRequest("invalid_body", "Validation failed", toFieldErrors(error.issues));
};



============================================================
FILE: C:\src\apgms-final\shared\src\idempotency.js
============================================================
import { badRequest, conflict } from "./errors.js";
import { createHash } from "node:crypto";
export async function withIdempotency(request, _reply, ctx, handler) {
    const rawKey = request?.headers?.["idempotency-key"] ??
        request?.headers?.["Idempotency-Key"] ??
        request?.headers?.["IDEMPOTENCY-KEY"];
    const key = normalizeKey(rawKey, ctx);
    const existing = await ctx.prisma.idempotencyKey.findUnique({
        where: { orgId_key: { orgId: ctx.orgId, key } },
        select: { id: true, key: true, orgId: true, firstSeenAt: true },
    });
    if (existing)
        throw conflict("idempotent_replay", "Request already processed");
    await ctx.prisma.idempotencyKey.create({
        data: {
            key,
            orgId: ctx.orgId,
            resource: ctx.resource ?? null,
            resourceId: null,
        },
    });
    const result = await handler({ idempotencyKey: key });
    try {
        await ctx.prisma.idempotencyKey.update({
            where: { orgId_key: { orgId: ctx.orgId, key } },
            data: {
                resource: result.resource ?? ctx.resource ?? null,
                resourceId: result.resourceId ?? null,
            },
        });
    }
    catch {
        // ignore
    }
    return result;
}
function normalizeKey(rawKey, ctx) {
    const headerKey = typeof rawKey === "string" ? rawKey.trim() : "";
    if (headerKey.length > 0) {
        return headerKey;
    }
    if (ctx.requestPayload !== undefined) {
        return `payload:${derivePayloadDigest(ctx)}`;
    }
    throw badRequest("missing_idempotency_key", "Idempotency-Key header or request payload is required");
}
function derivePayloadDigest(ctx) {
    const resource = ctx.resource ?? "";
    const payloadString = safeStringify(ctx.requestPayload);
    const digestInput = `${ctx.orgId ?? ""}:${resource}:${payloadString}`;
    return createHash("sha256").update(digestInput).digest("hex");
}
function safeStringify(value) {
    if (typeof value === "string") {
        return value;
    }
    if (value === undefined) {
        return "";
    }
    try {
        return JSON.stringify(value);
    }
    catch {
        return String(value);
    }
}



============================================================
FILE: C:\src\apgms-final\shared\src\idempotency.ts
============================================================
// shared/src/idempotency.ts
import type { PrismaClient } from "@prisma/client";
import { badRequest, conflict } from "./errors.js";
import { createHash } from "node:crypto";

type Ctx = {
  prisma: PrismaClient;
  orgId: string;
  actorId?: string;        // not persisted
  requestPayload?: unknown;
  resource?: string | null;
};

type HandlerResult = {
  statusCode: number;
  resource?: string | null;
  resourceId?: string | null;
  body?: unknown;
};

export async function withIdempotency<T extends HandlerResult>(
  request: { headers?: Record<string, unknown> },
  _reply: unknown,
  ctx: Ctx,
  handler: (args: { idempotencyKey: string }) => Promise<T>
): Promise<T> {
  const rawKey =
    request?.headers?.["idempotency-key"] ??
    request?.headers?.["Idempotency-Key"] ??
    request?.headers?.["IDEMPOTENCY-KEY"];

  const key = normalizeKey(rawKey, ctx);

  const existing = await ctx.prisma.idempotencyKey.findUnique({
    where: { orgId_key: { orgId: ctx.orgId, key } },
    select: { id: true, key: true, orgId: true, firstSeenAt: true },
  });
  if (existing) throw conflict("idempotent_replay", "Request already processed");

  await ctx.prisma.idempotencyKey.create({
    data: {
      key,
      orgId: ctx.orgId,
      resource: ctx.resource ?? null,
      resourceId: null,
    },
  });

  const result = await handler({ idempotencyKey: key });

  try {
    await ctx.prisma.idempotencyKey.update({
      where: { orgId_key: { orgId: ctx.orgId, key } },
      data: {
        resource: result.resource ?? ctx.resource ?? null,
        resourceId: result.resourceId ?? null,
      },
    });
  } catch {
    // ignore
  }

  return result;
}

function normalizeKey(rawKey: unknown, ctx: Ctx): string {
  const headerKey = typeof rawKey === "string" ? rawKey.trim() : "";
  if (headerKey.length > 0) {
    return headerKey;
  }

  if (ctx.requestPayload !== undefined) {
    return `payload:${derivePayloadDigest(ctx)}`;
  }

  throw badRequest("missing_idempotency_key", "Idempotency-Key header or request payload is required");
}

function derivePayloadDigest(ctx: Ctx): string {
  const resource = ctx.resource ?? "";
  const payloadString = safeStringify(ctx.requestPayload);
  const digestInput = `${ctx.orgId ?? ""}:${resource}:${payloadString}`;
  return createHash("sha256").update(digestInput).digest("hex");
}

function safeStringify(value: unknown): string {
  if (typeof value === "string") {
    return value;
  }
  if (value === undefined) {
    return "";
  }
  try {
    return JSON.stringify(value);
  } catch {
    return String(value);
  }
}



============================================================
FILE: C:\src\apgms-final\shared\src\index.js
============================================================
// shared/src/index.ts
export * from "./masking.js";
export * from "./security/password.js";
export * from "./redaction.js";
export * from "./logging.js";
export * from "./security-log.js";
export * from "./errors.js";
export * from "./crypto/envelope.js";
export * from "./security/totp.js";
export * from "./validation/index.js";
export * from "./idempotency.js";
export * from "./ledger/index.js";
// If ./tax is a directory with index.ts, NodeNext wants the explicit /index.js.
// If instead you actually have tax.ts (not a folder), then change this line to:
// export * from "./tax.js";
export * from "./tax/index.js";
export * from "./tax/tables.js";
export * from "./security/secret-manager.js";
export * from "./messaging/event-bus.js";
export * from "./messaging/in-memory-bus.js";
export * from "./messaging/nats-bus.js";
export * from "./ledger/one-way-account.js";
export * from "./ledger/integration-events.js";
export * from "./ledger/discrepancies.js";
export * from "./ledger/obligations.js";
export * from "./ledger/predictive.js";
export * from "./analytics/anomaly.js";
export * from "./ledger/bas.js";
export * from "./ledger/transfers.js";
export * from "./ledger/payment-plan.js";
export * from "./analytics/payment-plan-summary.js";
export * from "./observability/compliance-health.js";
export * from "./operations/government.js";
export * from "./operations/risk.js";



============================================================
FILE: C:\src\apgms-final\shared\src\index.ts
============================================================
// shared/src/index.ts

export * from "./masking.js";
export * from "./security/password.js";
export * from "./redaction.js";
export * from "./logging.js";
export * from "./security-log.js";
export * from "./errors.js";
export * from "./crypto/envelope.js";
export * from "./security/totp.js";
export * from "./validation/index.js";
export * from "./idempotency.js";
export * from "./ledger/index.js";

// If ./tax is a directory with index.ts, NodeNext wants the explicit /index.js.
// If instead you actually have tax.ts (not a folder), then change this line to:
// export * from "./tax.js";
export * from "./tax/index.js";

export * from "./tax/tables.js";
export * from "./security/secret-manager.js";
export * from "./messaging/event-bus.js";
export * from "./messaging/in-memory-bus.js";
export * from "./messaging/nats-bus.js";

export * from "./ledger/one-way-account.js";
export * from "./ledger/integration-events.js";
export * from "./ledger/discrepancies.js";
export * from "./ledger/obligations.js";
export * from "./ledger/predictive.js";
export * from "./analytics/anomaly.js";
export * from "./ledger/bas.js";
export * from "./ledger/transfers.js";
export * from "./ledger/payment-plan.js";
export * from "./analytics/payment-plan-summary.js";
export * from "./observability/compliance-health.js";
export * from "./operations/government.js";
export * from "./operations/risk.js";



============================================================
FILE: C:\src\apgms-final\shared\src\ledger\bas.js
============================================================
import { prisma } from "../db.js";
export async function recordBasLodgment(params) {
    return prisma.basLodgment.create({
        data: {
            orgId: params.orgId,
            initiatedBy: params.initiatedBy,
            taxTypes: params.taxTypes,
            status: params.status ?? "queued",
            result: params.result ? params.result : null,
        },
    });
}
export async function finalizeBasLodgment(id, result, status) {
    return prisma.basLodgment.update({
        where: { id },
        data: {
            result: result,
            status,
            processedAt: new Date(),
        },
    });
}



============================================================
FILE: C:\src\apgms-final\shared\src\ledger\bas.ts
============================================================
import { InputJsonValue } from "@prisma/client/runtime/library";

import { prisma } from "../db.js";

export type BasLodgmentStatus = "queued" | "in_progress" | "success" | "failed";

export async function recordBasLodgment(params: {
  orgId: string;
  initiatedBy?: string;
  taxTypes: string[];
  status?: BasLodgmentStatus;
  result?: Record<string, unknown>;
}) {
  return prisma.basLodgment.create({
    data: {
      orgId: params.orgId,
      initiatedBy: params.initiatedBy,
      taxTypes: params.taxTypes,
      status: params.status ?? "queued",
      result: params.result ? (params.result as InputJsonValue) : null,
    },
  });
}

export async function finalizeBasLodgment(id: string, result: Record<string, unknown>, status: BasLodgmentStatus) {
  return prisma.basLodgment.update({
    where: { id },
    data: {
      result: result as InputJsonValue,
      status,
      processedAt: new Date(),
    },
  });
}



============================================================
FILE: C:\src\apgms-final\shared\src\ledger\designated-account.js
============================================================
import { conflict } from "../errors.js";
// Use a const tuple so TS doesnâ€™t complain about assignability.
const ALLOWED_TYPES = ["PAYGW_BUFFER", "GST_BUFFER"];
function assertTaxType(type) {
    if (!ALLOWED_TYPES.includes(type)) {
        throw new Error(`Unsupported designated account type: ${type}`);
    }
}
class PrismaBankingAdapter {
    async getBalance(account) {
        return Number(account.balance);
    }
    async blockTransfer(_account, _shortfall) {
        // no-op for now; placeholder for future alerts/sandbox plan
    }
}
class PartnerBankingAdapter {
    constructor(url, token) {
        this.url = url;
        this.token = token;
    }
    headers() {
        const headers = {
            "Content-Type": "application/json",
        };
        if (this.token) {
            headers.Authorization = `Bearer ${this.token}`;
        }
        return headers;
    }
    accountEndpoint(account) {
        return `${this.url.replace(/\/$/, "")}/accounts/${account.id}`;
    }
    async getBalance(account) {
        const res = await fetch(`${this.accountEndpoint(account)}/balance`, {
            headers: this.headers(),
        });
        if (!res.ok) {
            throw new Error(`Partner adapter balance fetch failed: ${res.status}`);
        }
        const payload = await res.json();
        return Number(payload.balance ?? 0);
    }
    async blockTransfer(account, shortfall) {
        await fetch(`${this.accountEndpoint(account)}/lock`, {
            method: "POST",
            headers: this.headers(),
            body: JSON.stringify({ shortfall }),
        });
    }
}
let currentAdapter;
const partnerUrl = process.env.DESIGNATED_BANKING_URL?.trim();
const partnerToken = process.env.DESIGNATED_BANKING_TOKEN?.trim();
if (partnerUrl && partnerUrl.length > 0) {
    currentAdapter = new PartnerBankingAdapter(partnerUrl, partnerToken);
}
else {
    currentAdapter = new PrismaBankingAdapter();
}
/** Configure the adapter that simulates the banking partner. Swap this for a sandbox/ADI connector later. */
export function configureBankingAdapter(adapter) {
    currentAdapter = adapter;
}
export async function getDesignatedAccountByType(prisma, orgId, type) {
    assertTaxType(type);
    const account = (await prisma.designatedAccount.findFirst({
        where: { orgId, type },
    }));
    if (!account) {
        throw conflict("designated_account_not_found", `Designated account for ${type} is not configured for org ${orgId}`);
    }
    return account;
}
export async function ensureDesignatedAccountCoverage(prisma, orgId, type, requiredAmount, context) {
    const account = await getDesignatedAccountByType(prisma, orgId, type);
    const balance = await currentAdapter.getBalance(account);
    const shortfall = requiredAmount - balance;
    if (shortfall > 0) {
        await prisma.alert.create({
            data: {
                orgId,
                type: "DESIGNATED_FUNDS_SHORTFALL",
                severity: "HIGH",
                message: `Designated ${type} account is short by ${shortfall.toFixed(2)}`,
                metadata: {
                    requiredAmount,
                    balance,
                    cycleId: context?.cycleId ?? null,
                    description: context?.description ?? null,
                },
            },
        });
        await currentAdapter.blockTransfer?.(account, shortfall);
        await markAccountLocked(prisma, account.id);
        throw conflict("designated_insufficient_funds", `Designated ${type} account balance ${balance.toFixed(2)} does not cover requirement ${requiredAmount.toFixed(2)}`);
    }
    return account;
}
export async function releaseAccountLock(prisma, accountId) {
    await prisma.designatedAccount.update({
        where: { id: accountId },
        data: {
            locked: false,
            lockedAt: null,
        },
    });
}
export async function markAccountLocked(prisma, accountId) {
    await prisma.designatedAccount.update({
        where: { id: accountId },
        data: {
            locked: true,
            lockedAt: new Date(),
        },
    });
}
export async function reconcileAccountSnapshot(prisma, orgId, type) {
    const account = await getDesignatedAccountByType(prisma, orgId, type);
    return {
        account,
        balance: await currentAdapter.getBalance(account),
        updatedAt: account.updatedAt,
        locked: account.locked,
    };
}



============================================================
FILE: C:\src\apgms-final\shared\src\ledger\designated-account.ts
============================================================
import type { PrismaClient } from "@prisma/client";
import type { DesignatedAccountType } from "./types.js";
import { conflict } from "../errors.js";

// Minimal shape we actually need from the Prisma model.
// This avoids having to import `Prisma` and fights with its types.
export interface DesignatedAccount {
  id: string;
  orgId: string;
  type: string;
  balance: unknown; // Prisma Decimal or number
  updatedAt: Date;
  locked: boolean;
}

// Use a const tuple so TS doesnâ€™t complain about assignability.
const ALLOWED_TYPES = ["PAYGW_BUFFER", "GST_BUFFER"] as const;

function assertTaxType(type: string): asserts type is DesignatedAccountType {
  if (!(ALLOWED_TYPES as readonly string[]).includes(type)) {
    throw new Error(`Unsupported designated account type: ${type}`);
  }
}

export interface BankingAdapter {
  getBalance(account: DesignatedAccount): Promise<number>;
  blockTransfer?(account: DesignatedAccount, shortfall: number): Promise<void>;
}

class PrismaBankingAdapter implements BankingAdapter {
  async getBalance(account: DesignatedAccount): Promise<number> {
    return Number((account as any).balance);
  }

  async blockTransfer(
    _account: DesignatedAccount,
    _shortfall: number,
  ): Promise<void> {
    // no-op for now; placeholder for future alerts/sandbox plan
  }
}

class PartnerBankingAdapter implements BankingAdapter {
  constructor(private url: string, private token?: string) {}

  private headers(): Record<string, string> {
    const headers: Record<string, string> = {
      "Content-Type": "application/json",
    };

    if (this.token) {
      headers.Authorization = `Bearer ${this.token}`;
    }

    return headers;
  }

  private accountEndpoint(account: DesignatedAccount): string {
    return `${this.url.replace(/\/$/, "")}/accounts/${account.id}`;
  }

  async getBalance(account: DesignatedAccount): Promise<number> {
    const res = await fetch(`${this.accountEndpoint(account)}/balance`, {
      headers: this.headers(),
    });

    if (!res.ok) {
      throw new Error(`Partner adapter balance fetch failed: ${res.status}`);
    }

    const payload = await res.json();
    return Number((payload as any).balance ?? 0);
  }

  async blockTransfer(account: DesignatedAccount, shortfall: number): Promise<void> {
    await fetch(`${this.accountEndpoint(account)}/lock`, {
      method: "POST",
      headers: this.headers(),
      body: JSON.stringify({ shortfall }),
    });
  }
}

let currentAdapter: BankingAdapter;

const partnerUrl = process.env.DESIGNATED_BANKING_URL?.trim();
const partnerToken = process.env.DESIGNATED_BANKING_TOKEN?.trim();

if (partnerUrl && partnerUrl.length > 0) {
  currentAdapter = new PartnerBankingAdapter(partnerUrl, partnerToken);
} else {
  currentAdapter = new PrismaBankingAdapter();
}

/** Configure the adapter that simulates the banking partner. Swap this for a sandbox/ADI connector later. */
export function configureBankingAdapter(adapter: BankingAdapter): void {
  currentAdapter = adapter;
}

export async function getDesignatedAccountByType(
  prisma: PrismaClient,
  orgId: string,
  type: string,
): Promise<DesignatedAccount> {
  assertTaxType(type);

  const account = (await prisma.designatedAccount.findFirst({
    where: { orgId, type },
  })) as unknown as DesignatedAccount | null;

  if (!account) {
    throw conflict(
      "designated_account_not_found",
      `Designated account for ${type} is not configured for org ${orgId}`,
    );
  }

  return account;
}

export interface CoverageContext {
  cycleId?: string;
  description?: string;
}

export async function ensureDesignatedAccountCoverage(
  prisma: PrismaClient,
  orgId: string,
  type: DesignatedAccountType,
  requiredAmount: number,
  context?: CoverageContext,
): Promise<DesignatedAccount> {
  const account = await getDesignatedAccountByType(prisma, orgId, type);
  const balance = await currentAdapter.getBalance(account);
  const shortfall = requiredAmount - balance;

  if (shortfall > 0) {
    await prisma.alert.create({
      data: {
        orgId,
        type: "DESIGNATED_FUNDS_SHORTFALL",
        severity: "HIGH",
        message: `Designated ${type} account is short by ${shortfall.toFixed(2)}`,
        metadata: {
          requiredAmount,
          balance,
          cycleId: context?.cycleId ?? null,
          description: context?.description ?? null,
        },
      },
    });

    await currentAdapter.blockTransfer?.(account, shortfall);
    await markAccountLocked(prisma, account.id);

    throw conflict(
      "designated_insufficient_funds",
      `Designated ${type} account balance ${balance.toFixed(
        2,
      )} does not cover requirement ${requiredAmount.toFixed(2)}`,
    );
  }

  return account;
}

export async function releaseAccountLock(
  prisma: PrismaClient,
  accountId: string,
): Promise<void> {
  await prisma.designatedAccount.update({
    where: { id: accountId },
    data: {
      locked: false,
      lockedAt: null,
    },
  });
}

export async function markAccountLocked(
  prisma: PrismaClient,
  accountId: string,
): Promise<void> {
  await prisma.designatedAccount.update({
    where: { id: accountId },
    data: {
      locked: true,
      lockedAt: new Date(),
    },
  });
}

export async function reconcileAccountSnapshot(
  prisma: PrismaClient,
  orgId: string,
  type: DesignatedAccountType,
): Promise<{
  account: DesignatedAccount;
  balance: number;
  updatedAt: Date;
  locked: boolean;
}> {
  const account = await getDesignatedAccountByType(prisma, orgId, type);

  return {
    account,
    balance: await currentAdapter.getBalance(account),
    updatedAt: account.updatedAt,
    locked: account.locked,
  };
}



============================================================
FILE: C:\src\apgms-final\shared\src\ledger\discrepancies.js
============================================================
import { Decimal } from "@prisma/client/runtime/library";
import { prisma } from "../db.js";
export async function recordDiscrepancy(params) {
    const expected = new Decimal(params.expectedAmount);
    const actual = new Decimal(params.actualAmount);
    return prisma.discrepancyAlert.create({
        data: {
            orgId: params.orgId,
            taxType: params.taxType,
            eventId: params.eventId,
            expectedAmount: expected,
            actualAmount: actual,
            reason: params.reason,
        },
    });
}
export async function fetchRecentDiscrepancies(orgId) {
    return prisma.discrepancyAlert.findMany({
        where: { orgId },
        orderBy: { createdAt: "desc" },
        take: 20,
    });
}



============================================================
FILE: C:\src\apgms-final\shared\src\ledger\discrepancies.ts
============================================================
import { Decimal } from "@prisma/client/runtime/library";

import { prisma } from "../db.js";

export async function recordDiscrepancy(params: {
  orgId: string;
  taxType: string;
  eventId: string;
  expectedAmount: number | string | Decimal;
  actualAmount: number | string | Decimal;
  reason: string;
}) {
  const expected = new Decimal(params.expectedAmount);
  const actual = new Decimal(params.actualAmount);
  return prisma.discrepancyAlert.create({
    data: {
      orgId: params.orgId,
      taxType: params.taxType,
      eventId: params.eventId,
      expectedAmount: expected,
      actualAmount: actual,
      reason: params.reason,
    },
  });
}

export async function fetchRecentDiscrepancies(orgId: string) {
  return prisma.discrepancyAlert.findMany({
    where: { orgId },
    orderBy: { createdAt: "desc" },
    take: 20,
  });
}



============================================================
FILE: C:\src\apgms-final\shared\src\ledger\index.js
============================================================
// shared/src/ledger/index.ts
// Re-export the public ledger surface for other packages
export * from "./types.js";
export * as DesignatedAccountModule from "./designated-account.js";
export * from "./ingest.js";
export * from "./predictive.js";
/**
 * ---------------------------------------------------------------------------
 * Backwards-compatibility shims
 *
 * Older code (including @apgms/domain-policy) still imports
 * `evaluateDesignatedAccountPolicy` and `normalizeTransferSource` from
 * `@apgms/shared/ledger`. Those symbols used to live here but the design
 * moved on.
 *
 * To avoid breaking those imports while we refactor, we provide very
 * permissive "shim" exports:
 *  - `normalizeTransferSource` â€“ identity function
 *  - `evaluateDesignatedAccountPolicy` â€“ async stub that throws if called
 *
 * TypeScript is happy because the symbols exist and accept any parameters;
 * at runtime you should *not* be calling these â€“ domain policy should own
 * the real implementations.
 * ---------------------------------------------------------------------------
 */
/**
 * Normalises a transfer source string.
 *
 * Shim implementation: currently a no-op identity function so existing code
 * that still calls it will continue to behave as before, just without extra
 * normalisation.
 */
export function normalizeTransferSource(source) {
    return source;
}
/**
 * Evaluates a designated account policy.
 *
 * Shim implementation: this should never be hit in production. If it is,
 * it will throw loudly so we find and fix the remaining legacy call sites.
 */
export async function evaluateDesignatedAccountPolicy(..._args) {
    throw new Error("evaluateDesignatedAccountPolicy shim in @apgms/shared/ledger was called. " +
        "This logic has moved; imports should be updated to use @apgms/domain-policy directly.");
}



============================================================
FILE: C:\src\apgms-final\shared\src\ledger\index.ts
============================================================
// shared/src/ledger/index.ts

// Re-export the public ledger surface for other packages
export * from "./types.js";
export * as DesignatedAccountModule from "./designated-account.js";
export * from "./ingest.js";
export * from "./predictive.js";

/**
 * ---------------------------------------------------------------------------
 * Backwards-compatibility shims
 *
 * Older code (including @apgms/domain-policy) still imports
 * `evaluateDesignatedAccountPolicy` and `normalizeTransferSource` from
 * `@apgms/shared/ledger`. Those symbols used to live here but the design
 * moved on.
 *
 * To avoid breaking those imports while we refactor, we provide very
 * permissive "shim" exports:
 *  - `normalizeTransferSource` â€“ identity function
 *  - `evaluateDesignatedAccountPolicy` â€“ async stub that throws if called
 *
 * TypeScript is happy because the symbols exist and accept any parameters;
 * at runtime you should *not* be calling these â€“ domain policy should own
 * the real implementations.
 * ---------------------------------------------------------------------------
 */

/**
 * Normalises a transfer source string.
 *
 * Shim implementation: currently a no-op identity function so existing code
 * that still calls it will continue to behave as before, just without extra
 * normalisation.
 */
export function normalizeTransferSource(source: string): string {
  return source;
}

/**
 * Evaluates a designated account policy.
 *
 * Shim implementation: this should never be hit in production. If it is,
 * it will throw loudly so we find and fix the remaining legacy call sites.
 */
export async function evaluateDesignatedAccountPolicy(
  ..._args: any[]
): Promise<any> {
  throw new Error(
    "evaluateDesignatedAccountPolicy shim in @apgms/shared/ledger was called. " +
      "This logic has moved; imports should be updated to use @apgms/domain-policy directly.",
  );
}



============================================================
FILE: C:\src\apgms-final\shared\src\ledger\ingest.js
============================================================
import { Decimal } from "@prisma/client/runtime/library";
import { withIdempotency } from "../idempotency.js";
import { getDesignatedAccountByType } from "./designated-account.js";
import { applyDesignatedAccountTransfer } from "@apgms/domain-policy";
const PAYROLL_SOURCE = "payroll_system";
const POS_SOURCE = "pos_system";
export async function recordPayrollContribution(params) {
    await withIdempotency({
        headers: params.idempotencyKey
            ? { "Idempotency-Key": params.idempotencyKey }
            : undefined,
    }, null, {
        prisma: params.prisma,
        orgId: params.orgId,
        requestPayload: {
            amount: params.amount,
            type: PAYROLL_SOURCE,
            payload: params.payload,
        },
        resource: "payrollContribution",
    }, 
    // Donâ€™t import HandlerResult â€“ just return a generic â€œokâ€ object.
    async ({ idempotencyKey }) => {
        await params.prisma.payrollContribution.create({
            data: {
                orgId: params.orgId,
                amount: new Decimal(params.amount),
                source: PAYROLL_SOURCE,
                payload: params.payload ?? null,
                actorId: params.actorId,
                idempotencyKey,
            },
        });
        return { ok: true };
    });
}
export async function recordPosTransaction(params) {
    await withIdempotency({
        headers: params.idempotencyKey
            ? { "Idempotency-Key": params.idempotencyKey }
            : undefined,
    }, null, {
        prisma: params.prisma,
        orgId: params.orgId,
        requestPayload: {
            amount: params.amount,
            type: POS_SOURCE,
            payload: params.payload,
        },
        resource: "posTransaction",
    }, async ({ idempotencyKey }) => {
        await params.prisma.posTransaction.create({
            data: {
                orgId: params.orgId,
                amount: new Decimal(params.amount),
                source: POS_SOURCE,
                payload: params.payload ?? null,
                actorId: params.actorId,
                idempotencyKey,
            },
        });
        return { ok: true };
    });
}
export async function applyPendingContributions(params) {
    const pendingPayroll = await params.prisma.payrollContribution.findMany({
        where: { orgId: params.orgId, appliedAt: null },
        orderBy: { createdAt: "asc" },
    });
    const pendingPos = await params.prisma.posTransaction.findMany({
        where: { orgId: params.orgId, appliedAt: null },
        orderBy: { createdAt: "asc" },
    });
    const context = { prisma: params.prisma, auditLogger: params.auditLogger };
    for (const contribution of pendingPayroll) {
        await applyContribution(contribution, {
            orgId: params.orgId,
            accountType: "PAYGW_BUFFER",
            actorId: params.actorId ?? contribution.actorId ?? "system",
            context,
            table: "payroll",
        });
    }
    for (const contribution of pendingPos) {
        await applyContribution(contribution, {
            orgId: params.orgId,
            accountType: "GST_BUFFER",
            actorId: params.actorId ?? contribution.actorId ?? "system",
            context,
            table: "pos",
        });
    }
    return {
        payrollApplied: pendingPayroll.length,
        posApplied: pendingPos.length,
    };
}
async function applyContribution(contribution, params) {
    const account = await getDesignatedAccountByType(params.context.prisma, params.orgId, params.accountType);
    const transfer = await applyDesignatedAccountTransfer({
        prisma: params.context.prisma,
        auditLogger: params.context.auditLogger,
    }, {
        orgId: params.orgId,
        accountId: account.id,
        amount: Number(contribution.amount),
        source: contribution.source,
        actorId: params.actorId,
    });
    const update = params.table === "payroll"
        ? params.context.prisma.payrollContribution.update({
            where: { id: contribution.id },
            data: {
                appliedAt: new Date(),
                transferId: transfer.transferId,
            },
        })
        : params.context.prisma.posTransaction.update({
            where: { id: contribution.id },
            data: {
                appliedAt: new Date(),
                transferId: transfer.transferId,
            },
        });
    await update;
}
export async function summarizeContributions(prisma, orgId) {
    const payrollSummary = await prisma.payrollContribution.aggregate({
        _sum: { amount: true },
        where: { orgId, appliedAt: { not: null } },
    });
    const posSummary = await prisma.posTransaction.aggregate({
        _sum: { amount: true },
        where: { orgId, appliedAt: { not: null } },
    });
    return {
        paygwSecured: Number(payrollSummary._sum.amount ?? 0),
        gstSecured: Number(posSummary._sum.amount ?? 0),
    };
}



============================================================
FILE: C:\src\apgms-final\shared\src\ledger\ingest.ts
============================================================
import { Decimal } from "@prisma/client/runtime/library";
import type { PrismaClient } from "@prisma/client";
import { withIdempotency } from "../idempotency.js";
import { getDesignatedAccountByType } from "./designated-account.js";
import { applyDesignatedAccountTransfer, type AuditLogger } from "@apgms/domain-policy";

export type ContributionSource = "payroll_system" | "pos_system";

const PAYROLL_SOURCE: ContributionSource = "payroll_system";
const POS_SOURCE: ContributionSource = "pos_system";

export type ContributionResult = {
  payrollApplied: number;
  posApplied: number;
};

export async function recordPayrollContribution(params: {
  prisma: PrismaClient;
  orgId: string;
  amount: number;
  actorId?: string;
  payload?: unknown;
  idempotencyKey?: string;
}): Promise<void> {
  await withIdempotency(
    {
      headers: params.idempotencyKey
        ? { "Idempotency-Key": params.idempotencyKey }
        : undefined,
    },
    null,
    {
      prisma: params.prisma,
      orgId: params.orgId,
      requestPayload: {
        amount: params.amount,
        type: PAYROLL_SOURCE,
        payload: params.payload,
      },
      resource: "payrollContribution",
    },
    // Donâ€™t import HandlerResult â€“ just return a generic â€œokâ€ object.
    async ({ idempotencyKey }) => {
      await params.prisma.payrollContribution.create({
        data: {
          orgId: params.orgId,
          amount: new Decimal(params.amount),
          source: PAYROLL_SOURCE,
          payload: params.payload ?? null,
          actorId: params.actorId,
          idempotencyKey,
        },
      });

      return { ok: true } as any;
    },
  );
}

export async function recordPosTransaction(params: {
  prisma: PrismaClient;
  orgId: string;
  amount: number;
  actorId?: string;
  payload?: unknown;
  idempotencyKey?: string;
}): Promise<void> {
  await withIdempotency(
    {
      headers: params.idempotencyKey
        ? { "Idempotency-Key": params.idempotencyKey }
        : undefined,
    },
    null,
    {
      prisma: params.prisma,
      orgId: params.orgId,
      requestPayload: {
        amount: params.amount,
        type: POS_SOURCE,
        payload: params.payload,
      },
      resource: "posTransaction",
    },
    async ({ idempotencyKey }) => {
      await params.prisma.posTransaction.create({
        data: {
          orgId: params.orgId,
          amount: new Decimal(params.amount),
          source: POS_SOURCE,
          payload: params.payload ?? null,
          actorId: params.actorId,
          idempotencyKey,
        },
      });

      return { ok: true } as any;
    },
  );
}

export async function applyPendingContributions(params: {
  prisma: PrismaClient;
  orgId: string;
  actorId?: string;
  auditLogger?: AuditLogger;
}): Promise<ContributionResult> {
  const pendingPayroll = await params.prisma.payrollContribution.findMany({
    where: { orgId: params.orgId, appliedAt: null },
    orderBy: { createdAt: "asc" },
  });

  const pendingPos = await params.prisma.posTransaction.findMany({
    where: { orgId: params.orgId, appliedAt: null },
    orderBy: { createdAt: "asc" },
  });

  const context = { prisma: params.prisma, auditLogger: params.auditLogger };

  for (const contribution of pendingPayroll) {
    await applyContribution(contribution, {
      orgId: params.orgId,
      accountType: "PAYGW_BUFFER",
      actorId: params.actorId ?? contribution.actorId ?? "system",
      context,
      table: "payroll",
    });
  }

  for (const contribution of pendingPos) {
    await applyContribution(contribution, {
      orgId: params.orgId,
      accountType: "GST_BUFFER",
      actorId: params.actorId ?? contribution.actorId ?? "system",
      context,
      table: "pos",
    });
  }

  return {
    payrollApplied: pendingPayroll.length,
    posApplied: pendingPos.length,
  };
}

type ApplyContributionContext = {
  orgId: string;
  accountType: "PAYGW_BUFFER" | "GST_BUFFER";
  actorId: string;
  context: {
    prisma: PrismaClient;
    auditLogger?: AuditLogger;
  };
  table: "payroll" | "pos";
};

async function applyContribution(
  contribution: {
    id: string;
    amount: Decimal;
    source: string;
    idempotencyKey?: string | null;
  },
  params: ApplyContributionContext,
): Promise<void> {
  const account = await getDesignatedAccountByType(
    params.context.prisma,
    params.orgId,
    params.accountType,
  );

  const transfer = await applyDesignatedAccountTransfer(
    {
      prisma: params.context.prisma,
      auditLogger: params.context.auditLogger,
    },
    {
      orgId: params.orgId,
      accountId: account.id,
      amount: Number(contribution.amount),
      source: contribution.source,
      actorId: params.actorId,
    },
  );

  const update =
    params.table === "payroll"
      ? params.context.prisma.payrollContribution.update({
          where: { id: contribution.id },
          data: {
            appliedAt: new Date(),
            transferId: transfer.transferId,
          },
        })
      : params.context.prisma.posTransaction.update({
          where: { id: contribution.id },
          data: {
            appliedAt: new Date(),
            transferId: transfer.transferId,
          },
        });

  await update;
}

export async function summarizeContributions(
  prisma: PrismaClient,
  orgId: string,
): Promise<{
  paygwSecured: number;
  gstSecured: number;
}> {
  const payrollSummary = await prisma.payrollContribution.aggregate({
    _sum: { amount: true },
    where: { orgId, appliedAt: { not: null } },
  });

  const posSummary = await prisma.posTransaction.aggregate({
    _sum: { amount: true },
    where: { orgId, appliedAt: { not: null } },
  });

  return {
    paygwSecured: Number(payrollSummary._sum.amount ?? 0),
    gstSecured: Number(posSummary._sum.amount ?? 0),
  };
}



============================================================
FILE: C:\src\apgms-final\shared\src\ledger\integration-events.js
============================================================
import { Decimal } from "@prisma/client/runtime/library";
import { prisma } from "../db.js";
export async function recordIntegrationEvent(params) {
    const amountDecimal = new Decimal(params.amount);
    const metadata = params.metadata ? params.metadata : null;
    const event = await prisma.integrationEvent.create({
        data: {
            orgId: params.orgId,
            taxType: params.taxType,
            source: params.source,
            amount: amountDecimal,
            metadata,
            status: params.status ?? "pending",
        },
    });
    return event;
}
export async function markIntegrationEventProcessed(eventId) {
    return prisma.integrationEvent.update({
        where: { id: eventId },
        data: { status: "processed" },
    });
}



============================================================
FILE: C:\src\apgms-final\shared\src\ledger\integration-events.ts
============================================================
import { Decimal, InputJsonValue } from "@prisma/client/runtime/library";

import { prisma } from "../db.js";
import { TaxObligation } from "./one-way-account.js";

export type IntegrationEventStatus = "pending" | "processed" | "failed";

export async function recordIntegrationEvent(params: {
  orgId: string;
  taxType: TaxObligation;
  source: string;
  amount: number | string | Decimal;
  metadata?: Record<string, unknown>;
  status?: IntegrationEventStatus;
}) {
  const amountDecimal = new Decimal(params.amount);
  const metadata = params.metadata ? (params.metadata as InputJsonValue) : null;

  const event = await prisma.integrationEvent.create({
    data: {
      orgId: params.orgId,
      taxType: params.taxType,
      source: params.source,
      amount: amountDecimal,
      metadata,
      status: params.status ?? "pending",
    },
  });
  return event;
}

export async function markIntegrationEventProcessed(eventId: string) {
  return prisma.integrationEvent.update({
    where: { id: eventId },
    data: { status: "processed" },
  });
}



============================================================
FILE: C:\src\apgms-final\shared\src\ledger\obligations.js
============================================================
import { Decimal } from "@prisma/client/runtime/library";
import { prisma } from "../db.js";
import { fetchOneWayAccount } from "./one-way-account.js";
export async function recordObligation(params) {
    const amountDecimal = new Decimal(params.amount);
    return prisma.integrationObligation.create({
        data: {
            orgId: params.orgId,
            taxType: params.taxType,
            eventId: params.eventId,
            amount: amountDecimal,
            status: params.status ?? "pending",
        },
    });
}
export async function aggregateObligations(orgId, taxType) {
    const [result] = await prisma.$queryRaw `
    SELECT SUM("amount") as total
    FROM "IntegrationObligation"
    WHERE "orgId" = ${orgId} AND "taxType" = ${taxType} AND "status" = 'pending'
  `;
    return result?.total ?? new Decimal(0);
}
export async function markObligationsStatus(orgId, taxType, status) {
    return prisma.integrationObligation.updateMany({
        where: { orgId, taxType, status: "pending" },
        data: { status },
    });
}
export async function verifyObligations(orgId, taxType) {
    const pending = await aggregateObligations(orgId, taxType);
    const account = await fetchOneWayAccount({ orgId, taxType });
    const balance = account?.balance ?? new Decimal(0);
    let shortfall = null;
    if (balance.greaterThanOrEqualTo(pending)) {
        await markObligationsStatus(orgId, taxType, "verified");
    }
    else {
        shortfall = pending.minus(balance);
    }
    return { pending, balance, shortfall };
}



============================================================
FILE: C:\src\apgms-final\shared\src\ledger\obligations.ts
============================================================
import { Decimal } from "@prisma/client/runtime/library";

import { prisma } from "../db.js";
import { fetchOneWayAccount } from "./one-way-account.js";

export type ObligationStatus = "pending" | "verified" | "settled";

export async function recordObligation(params: {
  orgId: string;
  taxType: string;
  eventId: string;
  amount: number | string | Decimal;
  status?: ObligationStatus;
}) {
  const amountDecimal = new Decimal(params.amount);
  return prisma.integrationObligation.create({
    data: {
      orgId: params.orgId,
      taxType: params.taxType,
      eventId: params.eventId,
      amount: amountDecimal,
      status: params.status ?? "pending",
    },
  });
}

export async function aggregateObligations(orgId: string, taxType: string) {
  const [result] = await prisma.$queryRaw<
    { total: Decimal | null }[]
  >`
    SELECT SUM("amount") as total
    FROM "IntegrationObligation"
    WHERE "orgId" = ${orgId} AND "taxType" = ${taxType} AND "status" = 'pending'
  `;
  return result?.total ?? new Decimal(0);
}

export async function markObligationsStatus(orgId: string, taxType: string, status: ObligationStatus) {
  return prisma.integrationObligation.updateMany({
    where: { orgId, taxType, status: "pending" },
    data: { status },
  });
}

export async function verifyObligations(orgId: string, taxType: string) {
  const pending = await aggregateObligations(orgId, taxType);
  const account = await fetchOneWayAccount({ orgId, taxType });
  const balance = account?.balance ?? new Decimal(0);
  let shortfall: Decimal | null = null;
  if (balance.greaterThanOrEqualTo(pending)) {
    await markObligationsStatus(orgId, taxType, "verified");
  } else {
    shortfall = pending.minus(balance);
  }
  return { pending, balance, shortfall };
}



============================================================
FILE: C:\src\apgms-final\shared\src\ledger\one-way-account.js
============================================================
import { Decimal } from "@prisma/client/runtime/library";
import { prisma } from "../db.js";
const ALLOWED_TAX_TYPES = ["PAYGW", "GST"];
function ensureTaxType(value) {
    if (!ALLOWED_TAX_TYPES.includes(value)) {
        throw new Error(`Unsupported tax type: ${value}`);
    }
}
export async function getOrCreateOneWayAccount(params) {
    ensureTaxType(params.taxType);
    const account = await prisma.oneWayAccount.upsert({
        where: {
            orgId_taxType: {
                orgId: params.orgId,
                taxType: params.taxType,
            },
        },
        create: {
            orgId: params.orgId,
            taxType: params.taxType,
        },
        update: {},
    });
    return account;
}
export async function depositToOneWayAccount(params) {
    ensureTaxType(params.taxType);
    const amountDecimal = new Decimal(params.amount);
    const account = await getOrCreateOneWayAccount(params);
    const updated = await prisma.oneWayAccount.update({
        where: { id: account.id },
        data: {
            balance: {
                increment: amountDecimal,
            },
            lastDepositAt: new Date(),
        },
    });
    return updated;
}
export async function fetchOneWayAccount(params) {
    ensureTaxType(params.taxType);
    return prisma.oneWayAccount.findUnique({
        where: {
            orgId_taxType: {
                orgId: params.orgId,
                taxType: params.taxType,
            },
        },
    });
}



============================================================
FILE: C:\src\apgms-final\shared\src\ledger\one-way-account.ts
============================================================
import { Decimal } from "@prisma/client/runtime/library";

import { prisma } from "../db.js";

export type TaxObligation = "PAYGW" | "GST";

const ALLOWED_TAX_TYPES: TaxObligation[] = ["PAYGW", "GST"];

function ensureTaxType(value: string): asserts value is TaxObligation {
  if (!ALLOWED_TAX_TYPES.includes(value as TaxObligation)) {
    throw new Error(`Unsupported tax type: ${value}`);
  }
}

export async function getOrCreateOneWayAccount(params: {
  orgId: string;
  taxType: string;
}) {
  ensureTaxType(params.taxType);
  const account = await prisma.oneWayAccount.upsert({
    where: {
      orgId_taxType: {
        orgId: params.orgId,
        taxType: params.taxType,
      },
    },
    create: {
      orgId: params.orgId,
      taxType: params.taxType,
    },
    update: {},
  });
  return account;
}

export async function depositToOneWayAccount(params: {
  orgId: string;
  taxType: string;
  amount: number | string | Decimal;
}) {
  ensureTaxType(params.taxType);
  const amountDecimal = new Decimal(params.amount);
  const account = await getOrCreateOneWayAccount(params);
  const updated = await prisma.oneWayAccount.update({
    where: { id: account.id },
    data: {
      balance: {
        increment: amountDecimal,
      },
      lastDepositAt: new Date(),
    },
  });
  return updated;
}

export async function fetchOneWayAccount(params: {
  orgId: string;
  taxType: string;
}) {
  ensureTaxType(params.taxType);
  return prisma.oneWayAccount.findUnique({
    where: {
      orgId_taxType: {
        orgId: params.orgId,
        taxType: params.taxType,
      },
    },
  });
}



============================================================
FILE: C:\src\apgms-final\shared\src\ledger\payment-plan.js
============================================================
import { prisma } from "../db.js";
export async function createPaymentPlanRequest(params) {
    const payload = params.details ? params.details : null;
    return prisma.paymentPlanRequest.create({
        data: {
            orgId: params.orgId,
            basCycleId: params.basCycleId,
            reason: params.reason,
            detailsJson: payload,
            status: "SUBMITTED",
        },
    });
}
export async function listPaymentPlans(orgId) {
    return prisma.paymentPlanRequest.findMany({
        where: { orgId },
        orderBy: { requestedAt: "desc" },
        take: 50,
    });
}
export async function updatePaymentPlanStatus(id, status, metadata) {
    return prisma.paymentPlanRequest.update({
        where: { id },
        data: {
            status,
            detailsJson: metadata ? metadata : undefined,
        },
    });
}



============================================================
FILE: C:\src\apgms-final\shared\src\ledger\payment-plan.ts
============================================================
import { Decimal, InputJsonValue } from "@prisma/client/runtime/library";

import { prisma } from "../db.js";

export type PaymentPlanStatus = "SUBMITTED" | "APPROVED" | "REJECTED" | "CANCELLED";

export async function createPaymentPlanRequest(params: {
  orgId: string;
  basCycleId: string;
  reason: string;
  details?: Record<string, unknown>;
}) {
  const payload = params.details ? (params.details as InputJsonValue) : null;
  return prisma.paymentPlanRequest.create({
    data: {
      orgId: params.orgId,
      basCycleId: params.basCycleId,
      reason: params.reason,
      detailsJson: payload,
      status: "SUBMITTED",
    },
  });
}

export async function listPaymentPlans(orgId: string) {
  return prisma.paymentPlanRequest.findMany({
    where: { orgId },
    orderBy: { requestedAt: "desc" },
    take: 50,
  });
}

export async function updatePaymentPlanStatus(
  id: string,
  status: PaymentPlanStatus,
  metadata?: Record<string, unknown>,
) {
  return prisma.paymentPlanRequest.update({
    where: { id },
    data: {
      status,
      detailsJson: metadata ? (metadata as InputJsonValue) : undefined,
    },
  });
}



============================================================
FILE: C:\src\apgms-final\shared\src\ledger\policy.ts
============================================================
import {
  DESIGNATED_TRANSFER_SOURCES,
  type DesignatedAccountPolicyInput,
  type DesignatedAccountPolicyResult,
  type DesignatedTransferSource,
} from "./types.js";

const allowedSources = new Set<string>(DESIGNATED_TRANSFER_SOURCES);

export function normalizeTransferSource(
  source: string,
): DesignatedTransferSource | null {
  const upper = source.toUpperCase();
  return allowedSources.has(upper) ? (upper as DesignatedTransferSource) : null;
}

export function evaluateDesignatedAccountPolicy(
  input: DesignatedAccountPolicyInput,
): DesignatedAccountPolicyResult {
  if (!Number.isFinite(input.amount)) {
    return {
      allowed: false,
      violation: {
        code: "designated_invalid_amount",
        message: "Transfer amount must be a finite number",
        severity: "MEDIUM",
      },
    };
  }

  if (input.amount <= 0) {
    return {
      allowed: false,
      violation: {
        code: "designated_withdrawal_attempt",
        message: "Designated accounts are deposit-only; debits are prohibited",
        severity: "HIGH",
      },
    };
  }

  const normalized = normalizeTransferSource(input.source);
  if (!normalized) {
    return {
      allowed: false,
      violation: {
        code: "designated_untrusted_source",
        message: `Designated account funding source '${input.source}' is not whitelisted`,
        severity: "HIGH",
      },
    };
  }

  return { allowed: true };
}




============================================================
FILE: C:\src\apgms-final\shared\src\ledger\predictive.js
============================================================
const DEFAULT_ALPHA = 0.6;
export async function forecastObligations(prisma, orgId, lookback = 6, alpha = DEFAULT_ALPHA) {
    const cycles = await prisma.basCycle.findMany({
        where: { orgId },
        orderBy: { periodEnd: "desc" },
        take: lookback,
    });
    const count = cycles.length;
    if (count === 0) {
        return { paygwForecast: 0, gstForecast: 0, baselineCycles: 0, trend: { paygwDelta: 0, gstDelta: 0 } };
    }
    let weightedPaygw = 0;
    let weightedGst = 0;
    let weightSum = 0;
    for (let i = 0; i < count; i += 1) {
        const weight = Math.pow(alpha, count - i - 1);
        weightedPaygw += Number(cycles[i].paygwRequired) * weight;
        weightedGst += Number(cycles[i].gstRequired) * weight;
        weightSum += weight;
    }
    const paygwForecast = weightSum ? weightedPaygw / weightSum : 0;
    const gstForecast = weightSum ? weightedGst / weightSum : 0;
    const xMean = (1 + count) / 2;
    const yPaygwMean = cycles.reduce((sum, cycle) => sum + Number(cycle.paygwRequired), 0) / count;
    const yGstMean = cycles.reduce((sum, cycle) => sum + Number(cycle.gstRequired), 0) / count;
    let numeratorPaygw = 0;
    let numeratorGst = 0;
    let denominator = 0;
    for (let i = 0; i < count; i += 1) {
        const x = i + 1;
        denominator += (x - xMean) ** 2;
        numeratorPaygw += (x - xMean) * (Number(cycles[i].paygwRequired) - yPaygwMean);
        numeratorGst += (x - xMean) * (Number(cycles[i].gstRequired) - yGstMean);
    }
    const deltaPaygw = denominator > 0 ? numeratorPaygw / denominator : 0;
    const deltaGst = denominator > 0 ? numeratorGst / denominator : 0;
    return {
        paygwForecast,
        gstForecast,
        baselineCycles: count,
        trend: {
            paygwDelta: deltaPaygw,
            gstDelta: deltaGst,
        },
    };
}
export function computeTierStatus(balance, forecast, margin = 0) {
    if (balance >= forecast + margin) {
        return "reserve";
    }
    if (balance >= forecast) {
        return "automate";
    }
    return "escalate";
}



============================================================
FILE: C:\src\apgms-final\shared\src\ledger\predictive.ts
============================================================
import type { PrismaClient } from "@prisma/client";

export type ForecastResult = {
  paygwForecast: number;
  gstForecast: number;
  baselineCycles: number;
  trend: {
    paygwDelta: number;
    gstDelta: number;
  };
};

const DEFAULT_ALPHA = 0.6;

export async function forecastObligations(
  prisma: PrismaClient,
  orgId: string,
  lookback = 6,
  alpha = DEFAULT_ALPHA,
): Promise<ForecastResult> {
  const cycles = await prisma.basCycle.findMany({
    where: { orgId },
    orderBy: { periodEnd: "desc" },
    take: lookback,
  });
  const count = cycles.length;
  if (count === 0) {
    return { paygwForecast: 0, gstForecast: 0, baselineCycles: 0, trend: { paygwDelta: 0, gstDelta: 0 } };
  }

  let weightedPaygw = 0;
  let weightedGst = 0;
  let weightSum = 0;

  for (let i = 0; i < count; i += 1) {
    const weight = Math.pow(alpha, count - i - 1);
    weightedPaygw += Number(cycles[i].paygwRequired) * weight;
    weightedGst += Number(cycles[i].gstRequired) * weight;
    weightSum += weight;
  }

  const paygwForecast = weightSum ? weightedPaygw / weightSum : 0;
  const gstForecast = weightSum ? weightedGst / weightSum : 0;

  const xMean = (1 + count) / 2;
  const yPaygwMean =
  cycles.reduce((sum: number, cycle: any) => sum + Number(cycle.paygwRequired), 0) / count;

const yGstMean =
  cycles.reduce((sum: number, cycle: any) => sum + Number(cycle.gstRequired), 0) / count;


  let numeratorPaygw = 0;
  let numeratorGst = 0;
  let denominator = 0;
  for (let i = 0; i < count; i += 1) {
    const x = i + 1;
    denominator += (x - xMean) ** 2;
    numeratorPaygw += (x - xMean) * (Number(cycles[i].paygwRequired) - yPaygwMean);
    numeratorGst += (x - xMean) * (Number(cycles[i].gstRequired) - yGstMean);
  }

  const deltaPaygw = denominator > 0 ? numeratorPaygw / denominator : 0;
  const deltaGst = denominator > 0 ? numeratorGst / denominator : 0;

  return {
    paygwForecast,
    gstForecast,
    baselineCycles: count,
    trend: {
      paygwDelta: deltaPaygw,
      gstDelta: deltaGst,
    },
  };
}

export type TierStatus = "reserve" | "automate" | "escalate";

export function computeTierStatus(balance: number, forecast: number, margin = 0): TierStatus {
  if (balance >= forecast + margin) {
    return "reserve";
  }
  if (balance >= forecast) {
    return "automate";
  }
  return "escalate";
}



============================================================
FILE: C:\src\apgms-final\shared\src\ledger\transfers.js
============================================================
import { Decimal } from "@prisma/client/runtime/library";
import { prisma } from "../db.js";
export async function createTransferInstruction(params) {
    const amountDecimal = new Decimal(params.amount);
    return prisma.transferInstruction.create({
        data: {
            orgId: params.orgId,
            taxType: params.taxType,
            basId: params.basId,
            amount: amountDecimal,
            destination: params.destination,
        },
    });
}
export async function markTransferStatus(id, status) {
    return prisma.transferInstruction.update({
        where: { id },
        data: {
            status,
        },
    });
}



============================================================
FILE: C:\src\apgms-final\shared\src\ledger\transfers.ts
============================================================
import { Decimal } from "@prisma/client/runtime/library";

import { prisma } from "../db.js";

export type TransferStatus = "queued" | "sent" | "failed";

export async function createTransferInstruction(params: {
  orgId: string;
  taxType: string;
  basId: string;
  amount: number | string | Decimal;
  destination: string;
}) {
  const amountDecimal = new Decimal(params.amount);
  return prisma.transferInstruction.create({
    data: {
      orgId: params.orgId,
      taxType: params.taxType,
      basId: params.basId,
      amount: amountDecimal,
      destination: params.destination,
    },
  });
}

export async function markTransferStatus(id: string, status: TransferStatus) {
  return prisma.transferInstruction.update({
    where: { id },
    data: {
      status,
    },
  });
}



============================================================
FILE: C:\src\apgms-final\shared\src\ledger\types.js
============================================================
export const DESIGNATED_ACCOUNT_TYPES = ["PAYGW", "GST"];
export const DESIGNATED_TRANSFER_SOURCES = [
    "PAYROLL_CAPTURE",
    "GST_CAPTURE",
    "BAS_ESCROW",
];



============================================================
FILE: C:\src\apgms-final\shared\src\ledger\types.ts
============================================================
export const DESIGNATED_ACCOUNT_TYPES = ["PAYGW", "GST"] as const;

export type DesignatedAccountType = (typeof DESIGNATED_ACCOUNT_TYPES)[number];

export const DESIGNATED_TRANSFER_SOURCES = [
  "PAYROLL_CAPTURE",
  "GST_CAPTURE",
  "BAS_ESCROW",
] as const;

export type DesignatedTransferSource =
  (typeof DESIGNATED_TRANSFER_SOURCES)[number];

export type DesignatedAccountPolicyInput = {
  amount: number;
  source: string;
};

export type DesignatedAccountPolicyViolation = {
  code:
    | "designated_withdrawal_attempt"
    | "designated_invalid_amount"
    | "designated_untrusted_source";
  message: string;
  severity: "HIGH" | "MEDIUM";
};

export type DesignatedAccountPolicyResult =
  | { allowed: true }
  | { allowed: false; violation: DesignatedAccountPolicyViolation };




============================================================
FILE: C:\src\apgms-final\shared\src\logging.js
============================================================
import { redactLogPayload, redactError } from "./redaction.js";
export function safeLogAttributes(payload) {
    return redactLogPayload(payload);
}
export function safeLogError(err) {
    return redactError(err);
}



============================================================
FILE: C:\src\apgms-final\shared\src\logging.ts
============================================================
import { redactLogPayload, redactError } from "./redaction.js";

export function safeLogAttributes<T>(payload: T): T {
  return redactLogPayload(payload) as T;
}

export function safeLogError(err: unknown): Record<string, unknown> {
  return redactError(err);
}



============================================================
FILE: C:\src\apgms-final\shared\src\masking.js
============================================================
// services/api-gateway/src/lib/masking.ts
const SENSITIVE_KEY_PATTERNS = [
    "password",
    "token",
    "secret",
    "key",
    "authorization",
    "cookie",
    "session",
    "database_url",
    "databaseurl",
    "dsn",
];
const MASK = "***redacted***";
function shouldMaskKey(key) {
    if (!key)
        return false;
    const normalised = key.toLowerCase();
    return SENSITIVE_KEY_PATTERNS.some((pattern) => normalised.includes(pattern));
}
function maskString(value) {
    if (!value) {
        return MASK;
    }
    if (value.length <= 8) {
        return MASK;
    }
    const start = value.slice(0, 4);
    const end = value.slice(-2);
    return `${start}${"*".repeat(Math.max(3, value.length - 6))}${end}`;
}
function maskPotentialSecret(value, key) {
    if (shouldMaskKey(key)) {
        return MASK;
    }
    if (/password|secret|token|key/i.test(value)) {
        return MASK;
    }
    if (/^postgres(?:ql)?:\/\//i.test(value) ||
        /^mongodb:\/\//i.test(value)) {
        return maskString(value);
    }
    if (value.length > 32) {
        return maskString(value);
    }
    return value;
}
export function maskValue(value, key) {
    if (value == null)
        return value;
    if (typeof value === "string") {
        return shouldMaskKey(key) ? MASK : maskPotentialSecret(value, key);
    }
    if (typeof value === "number" || typeof value === "boolean") {
        return value;
    }
    if (value instanceof Date) {
        return value;
    }
    if (Array.isArray(value)) {
        return value.map((item) => maskValue(item, key));
    }
    if (typeof value === "object") {
        return maskObject(value);
    }
    return value;
}
export function maskObject(input) {
    if (input == null) {
        return input;
    }
    if (Array.isArray(input)) {
        return input.map((value) => maskValue(value));
    }
    if (typeof input !== "object") {
        return maskValue(input);
    }
    const entries = Object.entries(input).map(([key, value]) => [key, maskValue(value, key)]);
    return Object.fromEntries(entries);
}
export function maskError(err) {
    if (err instanceof Error) {
        const serialised = {
            name: err.name,
            message: err.message,
        };
        if (err.stack) {
            serialised.stack = err.stack.split("\n").slice(0, 5).join("\n");
        }
        if (err.cause) {
            serialised.cause = maskValue(err.cause);
        }
        return maskObject(serialised);
    }
    if (typeof err === "object" && err !== null) {
        return maskObject(err);
    }
    return { error: maskValue(err) };
}



============================================================
FILE: C:\src\apgms-final\shared\src\masking.ts
============================================================
// services/api-gateway/src/lib/masking.ts

const SENSITIVE_KEY_PATTERNS = [
  "password",
  "token",
  "secret",
  "key",
  "authorization",
  "cookie",
  "session",
  "database_url",
  "databaseurl",
  "dsn",
];

const MASK = "***redacted***";

function shouldMaskKey(key: string | undefined): boolean {
  if (!key) return false;
  const normalised = key.toLowerCase();
  return SENSITIVE_KEY_PATTERNS.some((pattern) =>
    normalised.includes(pattern)
  );
}

function maskString(value: string): string {
  if (!value) {
    return MASK;
  }
  if (value.length <= 8) {
    return MASK;
  }
  const start = value.slice(0, 4);
  const end = value.slice(-2);
  return `${start}${"*".repeat(Math.max(3, value.length - 6))}${end}`;
}

function maskPotentialSecret(value: string, key?: string): string {
  if (shouldMaskKey(key)) {
    return MASK;
  }
  if (/password|secret|token|key/i.test(value)) {
    return MASK;
  }
  if (
    /^postgres(?:ql)?:\/\//i.test(value) ||
    /^mongodb:\/\//i.test(value)
  ) {
    return maskString(value);
  }
  if (value.length > 32) {
    return maskString(value);
  }
  return value;
}

export function maskValue(value: unknown, key?: string): unknown {
  if (value == null) return value;

  if (typeof value === "string") {
    return shouldMaskKey(key) ? MASK : maskPotentialSecret(value, key);
  }

  if (typeof value === "number" || typeof value === "boolean") {
    return value;
  }

  if (value instanceof Date) {
    return value;
  }

  if (Array.isArray(value)) {
    return value.map((item) => maskValue(item, key));
  }

  if (typeof value === "object") {
    return maskObject(value as Record<string, unknown>);
  }

  return value;
}

export function maskObject<T>(input: T): T {
  if (input == null) {
    return input;
  }

  if (Array.isArray(input)) {
    return input.map((value) => maskValue(value)) as unknown as T;
  }

  if (typeof input !== "object") {
    return maskValue(input) as T;
  }

  const entries = Object.entries(
    input as Record<string, unknown>
  ).map(([key, value]) => [key, maskValue(value, key)]);

  return Object.fromEntries(entries) as T;
}

export function maskError(err: unknown): Record<string, unknown> {
  if (err instanceof Error) {
    const serialised: Record<string, unknown> = {
      name: err.name,
      message: err.message,
    };

    if (err.stack) {
      serialised.stack = err.stack.split("\n").slice(0, 5).join("\n");
    }

    if ((err as any).cause) {
      serialised.cause = maskValue((err as any).cause);
    }

    return maskObject(serialised);
  }

  if (typeof err === "object" && err !== null) {
    return maskObject(err as Record<string, unknown>);
  }

  return { error: maskValue(err) };
}



============================================================
FILE: C:\src\apgms-final\shared\src\messaging\event-bus.js
============================================================
export {};



============================================================
FILE: C:\src\apgms-final\shared\src\messaging\event-bus.ts
============================================================
export type BusEnvelope<T = unknown> = {
  id: string;
  orgId: string;
  eventType: string;
  key: string;
  ts: string;
  schemaVersion: string;
  source: string;
  dedupeId: string;
  traceId?: string;
  payload: T;
};

export interface EventBus {
  publish<T>(subject: string, msg: BusEnvelope<T>): Promise<void>;
  subscribe(
    subject: string,
    durable: string,
    onMsg: (message: BusEnvelope) => Promise<void>,
  ): Promise<() => Promise<void>>;
}




============================================================
FILE: C:\src\apgms-final\shared\src\messaging\in-memory-bus.js
============================================================
import { EventEmitter } from "node:events";
export class InMemoryEventBus {
    constructor() {
        this.emitter = new EventEmitter({ captureRejections: true });
    }
    async publish(subject, msg) {
        this.emitter.emit(subject, msg);
    }
    async subscribe(subject, durable, onMsg) {
        void durable; // durable names not needed for in-memory bus
        const handler = async (msg) => {
            await onMsg(msg);
        };
        this.emitter.on(subject, handler);
        return async () => {
            this.emitter.off(subject, handler);
        };
    }
}



============================================================
FILE: C:\src\apgms-final\shared\src\messaging\in-memory-bus.ts
============================================================
import { EventEmitter } from "node:events";

import type { BusEnvelope, EventBus } from "./event-bus.js";

export class InMemoryEventBus implements EventBus {
  private readonly emitter = new EventEmitter({ captureRejections: true });

  async publish<T>(subject: string, msg: BusEnvelope<T>): Promise<void> {
    this.emitter.emit(subject, msg);
  }

  async subscribe(
    subject: string,
    durable: string,
    onMsg: (message: BusEnvelope) => Promise<void>,
  ): Promise<() => Promise<void>> {
    void durable; // durable names not needed for in-memory bus

    const handler = async (msg: BusEnvelope) => {
      await onMsg(msg);
    };

    this.emitter.on(subject, handler);

    return async () => {
      this.emitter.off(subject, handler);
    };
  }
}




============================================================
FILE: C:\src\apgms-final\shared\src\messaging\nats-bus.js
============================================================
import { createHash } from "node:crypto";
import { DiscardPolicy, RetentionPolicy, StorageType, StringCodec, connect, consumerOpts, headers, } from "nats";
const codec = StringCodec();
export class NatsBus {
    constructor(connection, jetStream, jetStreamManager, stream, prefix) {
        this.connection = connection;
        this.jetStream = jetStream;
        this.jetStreamManager = jetStreamManager;
        this.stream = stream;
        this.prefix = prefix;
    }
    static async connect(options) {
        const connection = await connect({
            servers: options.url,
            name: options.connectionName ?? "apgms-nats-bus",
        });
        const jetStream = connection.jetstream();
        const jetStreamManager = await connection.jetstreamManager();
        await ensureStream(jetStreamManager, options.stream, options.subjectPrefix);
        return new NatsBus(connection, jetStream, jetStreamManager, options.stream, options.subjectPrefix);
    }
    async publish(subject, msg) {
        const payload = codec.encode(JSON.stringify(msg));
        const hdrs = buildHeaders(msg);
        await this.jetStream.publish(subject, payload, { headers: hdrs });
    }
    async subscribe(subject, durable, onMsg) {
        const opts = consumerOpts();
        opts.ackExplicit();
        opts.durable(durable);
        opts.manualAck();
        opts.deliverGroup(durable);
        opts.queue(durable);
        opts.deliverTo(`apgms-consumer-${hashSubject(subject)}-${durable}`);
        const subscription = await this.jetStream.subscribe(subject, opts);
        (async () => {
            for await (const message of subscription) {
                try {
                    const envelope = decodeEnvelope(message.data);
                    await onMsg(envelope);
                    message.ack();
                }
                catch (error) {
                    message.nak();
                    // eslint-disable-next-line no-console
                    console.error("Failed to process NATS message", { subject, durable, error });
                }
            }
        })().catch((error) => {
            // eslint-disable-next-line no-console
            console.error("NATS subscription closed with error", { subject, durable, error });
        });
        return async () => {
            subscription.unsubscribe();
        };
    }
    async ping() {
        await this.connection.flush();
    }
    async close() {
        await this.connection.drain();
    }
}
function decodeEnvelope(data) {
    const raw = codec.decode(data);
    return JSON.parse(raw);
}
function ensureHeaderString(value) {
    return value === undefined ? undefined : value;
}
function buildHeaders(msg) {
    const hdrs = headers();
    hdrs.set("apgms-eventType", msg.eventType);
    hdrs.set("apgms-schema", msg.schemaVersion);
    hdrs.set("apgms-source", msg.source);
    if (msg.traceId) {
        hdrs.set("traceparent", msg.traceId);
    }
    return hdrs;
}
async function ensureStream(jetStreamManager, stream, prefix) {
    try {
        await jetStreamManager.streams.info(stream);
        return;
    }
    catch {
        // stream missing; fall through to create
    }
    await jetStreamManager.streams.add({
        name: stream,
        subjects: [`${prefix}.>`],
        retention: RetentionPolicy.Limits,
        discard: DiscardPolicy.Old,
        storage: StorageType.File,
        num_replicas: 1,
    });
}
function hashSubject(subject) {
    return createHash("sha1").update(subject).digest("hex").slice(0, 8);
}



============================================================
FILE: C:\src\apgms-final\shared\src\messaging\nats-bus.ts
============================================================
import { createHash } from "node:crypto";

import {
  DiscardPolicy,
  JetStreamClient,
  JetStreamManager,
  NatsConnection,
  RetentionPolicy,
  StorageType,
  StringCodec,
  connect,
  consumerOpts,
  headers,
} from "nats";

import type { BusEnvelope, EventBus } from "./event-bus.js";

export interface NatsBusOptions {
  url: string;
  stream: string;
  subjectPrefix: string;
  connectionName?: string;
}

const codec = StringCodec();

export class NatsBus implements EventBus {
  private constructor(
    private readonly connection: NatsConnection,
    private readonly jetStream: JetStreamClient,
    private readonly jetStreamManager: JetStreamManager,
    private readonly stream: string,
    private readonly prefix: string,
  ) {}

  public static async connect(options: NatsBusOptions): Promise<NatsBus> {
    const connection = await connect({
      servers: options.url,
      name: options.connectionName ?? "apgms-nats-bus",
    });

    const jetStream = connection.jetstream();
    const jetStreamManager = await connection.jetstreamManager();
    await ensureStream(jetStreamManager, options.stream, options.subjectPrefix);

    return new NatsBus(connection, jetStream, jetStreamManager, options.stream, options.subjectPrefix);
  }

  public async publish<T>(subject: string, msg: BusEnvelope<T>): Promise<void> {
    const payload = codec.encode(JSON.stringify(msg));
    const hdrs = buildHeaders(msg);

    await this.jetStream.publish(subject, payload, { headers: hdrs });
  }

  public async subscribe(
    subject: string,
    durable: string,
    onMsg: (message: BusEnvelope) => Promise<void>,
  ): Promise<() => Promise<void>> {
    const opts = consumerOpts();
    opts.ackExplicit();
    opts.durable(durable);
    opts.manualAck();
    opts.deliverGroup(durable);
    opts.queue(durable);
    opts.deliverTo(`apgms-consumer-${hashSubject(subject)}-${durable}`);

    const subscription = await this.jetStream.subscribe(subject, opts);

    (async () => {
      for await (const message of subscription) {
        try {
          const envelope = decodeEnvelope(message.data);
          await onMsg(envelope);
          message.ack();
        } catch (error) {
          message.nak();
          // eslint-disable-next-line no-console
          console.error("Failed to process NATS message", { subject, durable, error });
        }
      }
    })().catch((error) => {
      // eslint-disable-next-line no-console
      console.error("NATS subscription closed with error", { subject, durable, error });
    });

    return async () => {
      subscription.unsubscribe();
    };
  }

  public async ping(): Promise<void> {
    await this.connection.flush();
  }

  public async close(): Promise<void> {
    await this.connection.drain();
  }
}

function decodeEnvelope(data: Uint8Array): BusEnvelope {
  const raw = codec.decode(data);
  return JSON.parse(raw) as BusEnvelope;
}

function ensureHeaderString(value: string | undefined): string | undefined {
  return value === undefined ? undefined : value;
}

function buildHeaders<T>(msg: BusEnvelope<T>) {
  const hdrs = headers();
  hdrs.set("apgms-eventType", msg.eventType);
  hdrs.set("apgms-schema", msg.schemaVersion);
  hdrs.set("apgms-source", msg.source);
  if (msg.traceId) {
    hdrs.set("traceparent", msg.traceId);
  }
  return hdrs;
}

async function ensureStream(
  jetStreamManager: JetStreamManager,
  stream: string,
  prefix: string,
): Promise<void> {
  try {
    await jetStreamManager.streams.info(stream);
    return;
  } catch {
    // stream missing; fall through to create
  }

  await jetStreamManager.streams.add({
    name: stream,
    subjects: [`${prefix}.>`],
    retention: RetentionPolicy.Limits,
    discard: DiscardPolicy.Old,
    storage: StorageType.File,
    num_replicas: 1,
  });
}

function hashSubject(subject: string): string {
  return createHash("sha1").update(subject).digest("hex").slice(0, 8);
}




============================================================
FILE: C:\src\apgms-final\shared\src\observability\compliance-health.js
============================================================
import { prisma } from "../db.js";
import { analyzeIntegrationAnomaly } from "../analytics/anomaly.js";
import { aggregateObligations } from "../ledger/obligations.js";
export async function complianceSnapshot(orgId, taxType = "PAYGW") {
    const [openDiscrepancies, pendingPlans, obligations, anomaly] = await Promise.all([
        prisma.discrepancyAlert.count({
            where: { orgId, resolved: false, taxType },
        }),
        prisma.paymentPlanRequest.count({
            where: { orgId, status: { in: ["SUBMITTED", "APPROVED"] } },
        }),
        aggregateObligations(orgId, taxType),
        analyzeIntegrationAnomaly(orgId, taxType),
    ]);
    return {
        taxType,
        pendingObligations: obligations.toString(),
        unresolvedDiscrepancies: openDiscrepancies,
        activePaymentPlans: pendingPlans,
        anomaly,
    };
}



============================================================
FILE: C:\src\apgms-final\shared\src\observability\compliance-health.ts
============================================================
import { prisma } from "../db.js";
