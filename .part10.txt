    cpu: [loong64]
    os: [linux]

  '@esbuild/linux-mips64el@0.25.10':
    resolution: {integrity: sha512-ab6eiuCwoMmYDyTnyptoKkVS3k8fy/1Uvq7Dj5czXI6DF2GqD2ToInBI0SHOp5/X1BdZ26RKc5+qjQNGRBelRA==}
    engines: {node: '>=18'}
    cpu: [mips64el]
    os: [linux]

  '@esbuild/linux-ppc64@0.25.10':
    resolution: {integrity: sha512-NLinzzOgZQsGpsTkEbdJTCanwA5/wozN9dSgEl12haXJBzMTpssebuXR42bthOF3z7zXFWH1AmvWunUCkBE4EA==}
    engines: {node: '>=18'}
    cpu: [ppc64]
    os: [linux]

  '@esbuild/linux-riscv64@0.25.10':
    resolution: {integrity: sha512-FE557XdZDrtX8NMIeA8LBJX3dC2M8VGXwfrQWU7LB5SLOajfJIxmSdyL/gU1m64Zs9CBKvm4UAuBp5aJ8OgnrA==}
    engines: {node: '>=18'}
    cpu: [riscv64]
    os: [linux]

  '@esbuild/linux-s390x@0.25.10':
    resolution: {integrity: sha512-3BBSbgzuB9ajLoVZk0mGu+EHlBwkusRmeNYdqmznmMc9zGASFjSsxgkNsqmXugpPk00gJ0JNKh/97nxmjctdew==}
    engines: {node: '>=18'}
    cpu: [s390x]
    os: [linux]

  '@esbuild/linux-x64@0.25.10':
    resolution: {integrity: sha512-QSX81KhFoZGwenVyPoberggdW1nrQZSvfVDAIUXr3WqLRZGZqWk/P4T8p2SP+de2Sr5HPcvjhcJzEiulKgnxtA==}
    engines: {node: '>=18'}
    cpu: [x64]
    os: [linux]

  '@esbuild/netbsd-arm64@0.25.10':
    resolution: {integrity: sha512-AKQM3gfYfSW8XRk8DdMCzaLUFB15dTrZfnX8WXQoOUpUBQ+NaAFCP1kPS/ykbbGYz7rxn0WS48/81l9hFl3u4A==}
    engines: {node: '>=18'}
    cpu: [arm64]
    os: [netbsd]

  '@esbuild/netbsd-x64@0.25.10':
    resolution: {integrity: sha512-7RTytDPGU6fek/hWuN9qQpeGPBZFfB4zZgcz2VK2Z5VpdUxEI8JKYsg3JfO0n/Z1E/6l05n0unDCNc4HnhQGig==}
    engines: {node: '>=18'}
    cpu: [x64]
    os: [netbsd]

  '@esbuild/openbsd-arm64@0.25.10':
    resolution: {integrity: sha512-5Se0VM9Wtq797YFn+dLimf2Zx6McttsH2olUBsDml+lm0GOCRVebRWUvDtkY4BWYv/3NgzS8b/UM3jQNh5hYyw==}
    engines: {node: '>=18'}
    cpu: [arm64]
    os: [openbsd]

  '@esbuild/openbsd-x64@0.25.10':
    resolution: {integrity: sha512-XkA4frq1TLj4bEMB+2HnI0+4RnjbuGZfet2gs/LNs5Hc7D89ZQBHQ0gL2ND6Lzu1+QVkjp3x1gIcPKzRNP8bXw==}
    engines: {node: '>=18'}
    cpu: [x64]
    os: [openbsd]

  '@esbuild/openharmony-arm64@0.25.10':
    resolution: {integrity: sha512-AVTSBhTX8Y/Fz6OmIVBip9tJzZEUcY8WLh7I59+upa5/GPhh2/aM6bvOMQySspnCCHvFi79kMtdJS1w0DXAeag==}
    engines: {node: '>=18'}
    cpu: [arm64]
    os: [openharmony]

  '@esbuild/sunos-x64@0.25.10':
    resolution: {integrity: sha512-fswk3XT0Uf2pGJmOpDB7yknqhVkJQkAQOcW/ccVOtfx05LkbWOaRAtn5SaqXypeKQra1QaEa841PgrSL9ubSPQ==}
    engines: {node: '>=18'}
    cpu: [x64]
    os: [sunos]

  '@esbuild/win32-arm64@0.25.10':
    resolution: {integrity: sha512-ah+9b59KDTSfpaCg6VdJoOQvKjI33nTaQr4UluQwW7aEwZQsbMCfTmfEO4VyewOxx4RaDT/xCy9ra2GPWmO7Kw==}
    engines: {node: '>=18'}
    cpu: [arm64]
    os: [win32]

  '@esbuild/win32-ia32@0.25.10':
    resolution: {integrity: sha512-QHPDbKkrGO8/cz9LKVnJU22HOi4pxZnZhhA2HYHez5Pz4JeffhDjf85E57Oyco163GnzNCVkZK0b/n4Y0UHcSw==}
    engines: {node: '>=18'}
    cpu: [ia32]
    os: [win32]

  '@esbuild/win32-x64@0.25.10':
    resolution: {integrity: sha512-9KpxSVFCu0iK1owoez6aC/s/EdUQLDN3adTxGCqxMVhrPDj6bt5dbrHDXUuq+Bs2vATFBBrQS5vdQ/Ed2P+nbw==}
    engines: {node: '>=18'}
    cpu: [x64]
    os: [win32]

  '@fastify/ajv-compiler@4.0.2':
    resolution: {integrity: sha512-Rkiu/8wIjpsf46Rr+Fitd3HRP+VsxUFDDeag0hs9L0ksfnwx2g7SPQQTFL0E8Qv+rfXzQOxBJnjUB9ITUDjfWQ==}

  '@fastify/cors@11.1.0':
    resolution: {integrity: sha512-sUw8ed8wP2SouWZTIbA7V2OQtMNpLj2W6qJOYhNdcmINTu6gsxVYXjQiM9mdi8UUDlcoDDJ/W2syPo1WB2QjYA==}

  '@fastify/error@4.2.0':
    resolution: {integrity: sha512-RSo3sVDXfHskiBZKBPRgnQTtIqpi/7zhJOEmAxCiBcM7d0uwdGdxLlsCaLzGs8v8NnxIRlfG0N51p5yFaOentQ==}

  '@fastify/fast-json-stringify-compiler@5.0.3':
    resolution: {integrity: sha512-uik7yYHkLr6fxd8hJSZ8c+xF4WafPK+XzneQDPU+D10r5X19GW8lJcom2YijX2+qtFF1ENJlHXKFM9ouXNJYgQ==}

  '@fastify/forwarded@3.0.1':
    resolution: {integrity: sha512-JqDochHFqXs3C3Ml3gOY58zM7OqO9ENqPo0UqAjAjH8L01fRZqwX9iLeX34//kiJubF7r2ZQHtBRU36vONbLlw==}

  '@fastify/merge-json-schemas@0.2.1':
    resolution: {integrity: sha512-OA3KGBCy6KtIvLf8DINC5880o5iBlDX4SxzLQS8HorJAbqluzLRn80UXU0bxZn7UOFhFgpRJDasfwn9nG4FG4A==}

  '@fastify/proxy-addr@5.1.0':
    resolution: {integrity: sha512-INS+6gh91cLUjB+PVHfu1UqcB76Sqtpyp7bnL+FYojhjygvOPA9ctiD/JDKsyD9Xgu4hUhCSJBPig/w7duNajw==}

  '@types/node@24.7.1':
    resolution: {integrity: sha512-CmyhGZanP88uuC5GpWU9q+fI61j2SkhO3UGMUdfYRE6Bcy0ccyzn1Rqj9YAB/ZY4kOXmNf0ocah5GtphmLMP6Q==}

  abstract-logging@2.0.1:
    resolution: {integrity: sha512-2BjRTZxTPvheOvGbBslFSYOUkr+SjPtOnrLP33f+VIWLzezQpZcqVg7ja3L4dBXmzzgwT+a029jRx5PCi3JuiA==}

  ajv-formats@3.0.1:
    resolution: {integrity: sha512-8iUql50EUR+uUcdRQ3HDqa6EVyo3docL8g5WJ3FNcWmu62IbkGUue/pEyLBW8VGKKucTPgqeks4fIU1DA4yowQ==}
    peerDependencies:
      ajv: ^8.0.0
    peerDependenciesMeta:
      ajv:
        optional: true

  ajv@8.17.1:
    resolution: {integrity: sha512-B/gBuNg5SiMTrPkC+A2+cW0RszwxYmn6VYxB/inlBStS5nx6xHIt/ehKRhIMhqusl7a8LjQoZnjCs5vhwxOQ1g==}

  atomic-sleep@1.0.0:
    resolution: {integrity: sha512-kNOjDqAh7px0XWNI+4QbzoiR/nTkHAWNud2uvnJquD1/x5a7EQZMJT0AczqK0Qn67oY/TTQ1LbUKajZpp3I9tQ==}
    engines: {node: '>=8.0.0'}

  avvio@9.1.0:
    resolution: {integrity: sha512-fYASnYi600CsH/j9EQov7lECAniYiBFiiAtBNuZYLA2leLe9qOvZzqYHFjtIj6gD2VMoMLP14834LFWvr4IfDw==}

  cookie@1.0.2:
    resolution: {integrity: sha512-9Kr/j4O16ISv8zBBhJoi4bXOYNTkFLOqSL3UDB0njXxCXNezjeyVrJyGOWtgfs/q2km1gwBcfH8q1yEGoMYunA==}
    engines: {node: '>=18'}

  dequal@2.0.3:
    resolution: {integrity: sha512-0je+qPKHEMohvfRTCEo3CrPG6cAzAYgmzKyxRiYSSDkS6eGJdyVJm7WaYA5ECaAD9wLB2T4EEeymA5aFVcYXCA==}
    engines: {node: '>=6'}

  dotenv@16.6.1:
    resolution: {integrity: sha512-uBq4egWHTcTt33a72vpSG0z3HnPuIl6NqYcTrKEg2azoEyl2hpW0zqlxysq2pK9HlDIHyHyakeYaYnSAwd8bow==}
    engines: {node: '>=12'}

  esbuild@0.25.10:
    resolution: {integrity: sha512-9RiGKvCwaqxO2owP61uQ4BgNborAQskMR6QusfWzQqv7AZOg5oGehdY2pRJMTKuwxd1IDBP4rSbI5lHzU7SMsQ==}
    engines: {node: '>=18'}
    hasBin: true

  fast-decode-uri-component@1.0.1:
    resolution: {integrity: sha512-WKgKWg5eUxvRZGwW8FvfbaH7AXSh2cL+3j5fMGzUMCxWBJ3dV3a7Wz8y2f/uQ0e3B6WmodD3oS54jTQ9HVTIIg==}

  fast-deep-equal@3.1.3:
    resolution: {integrity: sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==}

  fast-json-stringify@6.1.1:
    resolution: {integrity: sha512-DbgptncYEXZqDUOEl4krff4mUiVrTZZVI7BBrQR/T3BqMj/eM1flTC1Uk2uUoLcWCxjT95xKulV/Lc6hhOZsBQ==}

  fast-querystring@1.1.2:
    resolution: {integrity: sha512-g6KuKWmFXc0fID8WWH0jit4g0AGBoJhCkJMb1RmbsSEUNvQ+ZC8D6CUZ+GtF8nMzSPXnhiePyyqqipzNNEnHjg==}

  fast-uri@3.1.0:
    resolution: {integrity: sha512-iPeeDKJSWf4IEOasVVrknXpaBV0IApz/gp7S2bb7Z4Lljbl2MGJRqInZiUrQwV16cpzw/D3S5j5Julj/gT52AA==}

  fastify-plugin@5.1.0:
    resolution: {integrity: sha512-FAIDA8eovSt5qcDgcBvDuX/v0Cjz0ohGhENZ/wpc3y+oZCY2afZ9Baqql3g/lC+OHRnciQol4ww7tuthOb9idw==}

  fastify@5.6.1:
    resolution: {integrity: sha512-WjjlOciBF0K8pDUPZoGPhqhKrQJ02I8DKaDIfO51EL0kbSMwQFl85cRwhOvmSDWoukNOdTo27gLN549pLCcH7Q==}

  fastq@1.19.1:
    resolution: {integrity: sha512-GwLTyxkCXjXbxqIhTsMI2Nui8huMPtnxg7krajPJAjnEG/iiOS7i+zCtWGZR9G0NBKbXKh6X9m9UIsYX/N6vvQ==}

  find-my-way@9.3.0:
    resolution: {integrity: sha512-eRoFWQw+Yv2tuYlK2pjFS2jGXSxSppAs3hSQjfxVKxM5amECzIgYYc1FEI8ZmhSh/Ig+FrKEz43NLRKJjYCZVg==}
    engines: {node: '>=20'}

  fsevents@2.3.3:
    resolution: {integrity: sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==}
    engines: {node: ^8.16.0 || ^10.6.0 || >=11.0.0}
    os: [darwin]

  get-tsconfig@4.12.0:
    resolution: {integrity: sha512-LScr2aNr2FbjAjZh2C6X6BxRx1/x+aTDExct/xyq2XKbYOiG5c0aK7pMsSuyc0brz3ibr/lbQiHD9jzt4lccJw==}

  ipaddr.js@2.2.0:
    resolution: {integrity: sha512-Ag3wB2o37wslZS19hZqorUnrnzSkpOVy+IiiDEiTqNubEYpYuHWIf6K4psgN2ZWKExS4xhVCrRVfb/wfW8fWJA==}
    engines: {node: '>= 10'}

  json-schema-ref-resolver@3.0.0:
    resolution: {integrity: sha512-hOrZIVL5jyYFjzk7+y7n5JDzGlU8rfWDuYyHwGa2WA8/pcmMHezp2xsVwxrebD/Q9t8Nc5DboieySDpCp4WG4A==}

  json-schema-traverse@1.0.0:
    resolution: {integrity: sha512-NM8/P9n3XjXhIZn1lLhkFaACTOURQXjWhV4BA/RnOv8xvgqtqpAX9IO4mRQxSx1Rlo4tqzeqb0sOlruaOy3dug==}

  light-my-request@6.6.0:
    resolution: {integrity: sha512-CHYbu8RtboSIoVsHZ6Ye4cj4Aw/yg2oAFimlF7mNvfDV192LR7nDiKtSIfCuLT7KokPSTn/9kfVLm5OGN0A28A==}

  on-exit-leak-free@2.1.2:
    resolution: {integrity: sha512-0eJJY6hXLGf1udHwfNftBqH+g73EU4B504nZeKpz1sYRKafAghwxEJunB2O7rDZkL4PGfsMVnTXZ2EjibbqcsA==}
    engines: {node: '>=14.0.0'}

  pino-abstract-transport@2.0.0:
    resolution: {integrity: sha512-F63x5tizV6WCh4R6RHyi2Ml+M70DNRXt/+HANowMflpgGFMAym/VKm6G7ZOQRjqN7XbGxK1Lg9t6ZrtzOaivMw==}

  pino-std-serializers@7.0.0:
    resolution: {integrity: sha512-e906FRY0+tV27iq4juKzSYPbUj2do2X2JX4EzSca1631EB2QJQUqGbDuERal7LCtOpxl6x3+nvo9NPZcmjkiFA==}

  pino@9.13.1:
    resolution: {integrity: sha512-Szuj+ViDTjKPQYiKumGmEn3frdl+ZPSdosHyt9SnUevFosOkMY2b7ipxlEctNKPmMD/VibeBI+ZcZCJK+4DPuw==}
    hasBin: true

  process-warning@4.0.1:
    resolution: {integrity: sha512-3c2LzQ3rY9d0hc1emcsHhfT9Jwz0cChib/QN89oME2R451w5fy3f0afAhERFZAwrbDU43wk12d0ORBpDVME50Q==}

  process-warning@5.0.0:
    resolution: {integrity: sha512-a39t9ApHNx2L4+HBnQKqxxHNs1r7KF+Intd8Q/g1bUh6q0WIp9voPXJ/x0j+ZL45KF1pJd9+q2jLIRMfvEshkA==}

  quick-format-unescaped@4.0.4:
    resolution: {integrity: sha512-tYC1Q1hgyRuHgloV/YXs2w15unPVh8qfu/qCTfhTYamaw7fyhumKa2yGpdSo87vY32rIclj+4fWYQXUMs9EHvg==}

  real-require@0.2.0:
    resolution: {integrity: sha512-57frrGM/OCTLqLOAh0mhVA9VBMHd+9U7Zb2THMGdBUoZVOtGbJzjxsYGDJ3A9AYYCP4hn6y1TVbaOfzWtm5GFg==}
    engines: {node: '>= 12.13.0'}

  require-from-string@2.0.2:
    resolution: {integrity: sha512-Xf0nWe6RseziFMu+Ap9biiUbmplq6S9/p+7w7YXP/JBHhrUDDUhwa+vANyubuqfZWTveU//DYVGsDG7RKL/vEw==}
    engines: {node: '>=0.10.0'}

  resolve-pkg-maps@1.0.0:
    resolution: {integrity: sha512-seS2Tj26TBVOC2NIc2rOe2y2ZO7efxITtLZcGSOnHHNOQ7CkiUBfw0Iw2ck6xkIhPwLhKNLS8BO+hEpngQlqzw==}

  ret@0.5.0:
    resolution: {integrity: sha512-I1XxrZSQ+oErkRR4jYbAyEEu2I0avBvvMM5JN+6EBprOGRCs63ENqZ3vjavq8fBw2+62G5LF5XelKwuJpcvcxw==}
    engines: {node: '>=10'}

  reusify@1.1.0:
    resolution: {integrity: sha512-g6QUff04oZpHs0eG5p83rFLhHeV00ug/Yf9nZM6fLeUrPguBTkTQOdpAWWspMh55TZfVQDPaN3NQJfbVRAxdIw==}
    engines: {iojs: '>=1.0.0', node: '>=0.10.0'}

  rfdc@1.4.1:
    resolution: {integrity: sha512-q1b3N5QkRUWUl7iyylaaj3kOpIT0N2i9MqIEQXP73GVsN9cw3fdx8X63cEmWhJGi2PPCF23Ijp7ktmd39rawIA==}

  safe-regex2@5.0.0:
    resolution: {integrity: sha512-YwJwe5a51WlK7KbOJREPdjNrpViQBI3p4T50lfwPuDhZnE3XGVTlGvi+aolc5+RvxDD6bnUmjVsU9n1eboLUYw==}

  safe-stable-stringify@2.5.0:
    resolution: {integrity: sha512-b3rppTKm9T+PsVCBEOUR46GWI7fdOs00VKZ1+9c1EWDaDMvjQc6tUwuFyIprgGgTcWoVHSKrU8H31ZHA2e0RHA==}
    engines: {node: '>=10'}

  secure-json-parse@4.1.0:
    resolution: {integrity: sha512-l4KnYfEyqYJxDwlNVyRfO2E4NTHfMKAWdUuA8J0yve2Dz/E/PdBepY03RvyJpssIpRFwJoCD55wA+mEDs6ByWA==}

  semver@7.7.3:
    resolution: {integrity: sha512-SdsKMrI9TdgjdweUSR9MweHA4EJ8YxHn8DFaDisvhVlUOe4BF1tLD7GAj0lIqWVl+dPb/rExr0Btby5loQm20Q==}
    engines: {node: '>=10'}
    hasBin: true

  set-cookie-parser@2.7.1:
    resolution: {integrity: sha512-IOc8uWeOZgnb3ptbCURJWNjWUPcO3ZnTTdzsurqERrP6nPyv+paC55vJM0LpOlT2ne+Ix+9+CRG1MNLlyZ4GjQ==}

  slow-redact@0.3.1:
    resolution: {integrity: sha512-NvFvl1GuLZNW4U046Tfi8b26zXo8aBzgCAS2f7yVJR/fArN93mOqSA99cB9uITm92ajSz01bsu1K7SCVVjIMpQ==}

  sonic-boom@4.2.0:
    resolution: {integrity: sha512-INb7TM37/mAcsGmc9hyyI6+QR3rR1zVRu36B0NeGXKnOOLiZOfER5SA+N7X7k3yUYRzLWafduTDvJAfDswwEww==}

  split2@4.2.0:
    resolution: {integrity: sha512-UcjcJOWknrNkF6PLX83qcHM6KHgVKNkV62Y8a5uYDVv9ydGQVwAHMKqHdJje1VTWpljG0WYpCDhrCdAOYH4TWg==}
    engines: {node: '>= 10.x'}

  thread-stream@3.1.0:
    resolution: {integrity: sha512-OqyPZ9u96VohAyMfJykzmivOrY2wfMSf3C5TtFJVgN+Hm6aj+voFhlK+kZEIv2FBh1X6Xp3DlnCOfEQ3B2J86A==}

  toad-cache@3.7.0:
    resolution: {integrity: sha512-/m8M+2BJUpoJdgAHoG+baCwBT+tf2VraSfkBgl0Y00qIWt41DJ8R5B8nsEw0I58YwF5IZH6z24/2TobDKnqSWw==}
    engines: {node: '>=12'}

  tsx@4.20.6:
    resolution: {integrity: sha512-ytQKuwgmrrkDTFP4LjR0ToE2nqgy886GpvRSpU0JAnrdBYppuY5rLkRUYPU1yCryb24SsKBTL/hlDQAEFVwtZg==}
    engines: {node: '>=18.0.0'}
    hasBin: true

  typescript@5.9.3:
    resolution: {integrity: sha512-jl1vZzPDinLr9eUt3J/t7V6FgNEw9QjvBPdysz9KfQDD41fQrC2Y4vKQdiaUpFT4bXlb1RHhLpp8wtm6M5TgSw==}
    engines: {node: '>=14.17'}
    hasBin: true

  undici-types@7.14.0:
    resolution: {integrity: sha512-QQiYxHuyZ9gQUIrmPo3IA+hUl4KYk8uSA7cHrcKd/l3p1OTpZcM0Tbp9x7FAtXdAYhlasd60ncPpgu6ihG6TOA==}

snapshots:

  '@esbuild/aix-ppc64@0.25.10':
    optional: true

  '@esbuild/android-arm64@0.25.10':
    optional: true

  '@esbuild/android-arm@0.25.10':
    optional: true

  '@esbuild/android-x64@0.25.10':
    optional: true

  '@esbuild/darwin-arm64@0.25.10':
    optional: true

  '@esbuild/darwin-x64@0.25.10':
    optional: true

  '@esbuild/freebsd-arm64@0.25.10':
    optional: true

  '@esbuild/freebsd-x64@0.25.10':
    optional: true

  '@esbuild/linux-arm64@0.25.10':
    optional: true

  '@esbuild/linux-arm@0.25.10':
    optional: true

  '@esbuild/linux-ia32@0.25.10':
    optional: true

  '@esbuild/linux-loong64@0.25.10':
    optional: true

  '@esbuild/linux-mips64el@0.25.10':
    optional: true

  '@esbuild/linux-ppc64@0.25.10':
    optional: true

  '@esbuild/linux-riscv64@0.25.10':
    optional: true

  '@esbuild/linux-s390x@0.25.10':
    optional: true

  '@esbuild/linux-x64@0.25.10':
    optional: true

  '@esbuild/netbsd-arm64@0.25.10':
    optional: true

  '@esbuild/netbsd-x64@0.25.10':
    optional: true

  '@esbuild/openbsd-arm64@0.25.10':
    optional: true

  '@esbuild/openbsd-x64@0.25.10':
    optional: true

  '@esbuild/openharmony-arm64@0.25.10':
    optional: true

  '@esbuild/sunos-x64@0.25.10':
    optional: true

  '@esbuild/win32-arm64@0.25.10':
    optional: true

  '@esbuild/win32-ia32@0.25.10':
    optional: true

  '@esbuild/win32-x64@0.25.10':
    optional: true

  '@fastify/ajv-compiler@4.0.2':
    dependencies:
      ajv: 8.17.1
      ajv-formats: 3.0.1(ajv@8.17.1)
      fast-uri: 3.1.0

  '@fastify/cors@11.1.0':
    dependencies:
      fastify-plugin: 5.1.0
      toad-cache: 3.7.0

  '@fastify/error@4.2.0': {}

  '@fastify/fast-json-stringify-compiler@5.0.3':
    dependencies:
      fast-json-stringify: 6.1.1

  '@fastify/forwarded@3.0.1': {}

  '@fastify/merge-json-schemas@0.2.1':
    dependencies:
      dequal: 2.0.3

  '@fastify/proxy-addr@5.1.0':
    dependencies:
      '@fastify/forwarded': 3.0.1
      ipaddr.js: 2.2.0

  '@types/node@24.7.1':
    dependencies:
      undici-types: 7.14.0

  abstract-logging@2.0.1: {}

  ajv-formats@3.0.1(ajv@8.17.1):
    optionalDependencies:
      ajv: 8.17.1

  ajv@8.17.1:
    dependencies:
      fast-deep-equal: 3.1.3
      fast-uri: 3.1.0
      json-schema-traverse: 1.0.0
      require-from-string: 2.0.2

  atomic-sleep@1.0.0: {}

  avvio@9.1.0:
    dependencies:
      '@fastify/error': 4.2.0
      fastq: 1.19.1

  cookie@1.0.2: {}

  dequal@2.0.3: {}

  dotenv@16.6.1: {}

  esbuild@0.25.10:
    optionalDependencies:
      '@esbuild/aix-ppc64': 0.25.10
      '@esbuild/android-arm': 0.25.10
      '@esbuild/android-arm64': 0.25.10
      '@esbuild/android-x64': 0.25.10
      '@esbuild/darwin-arm64': 0.25.10
      '@esbuild/darwin-x64': 0.25.10
      '@esbuild/freebsd-arm64': 0.25.10
      '@esbuild/freebsd-x64': 0.25.10
      '@esbuild/linux-arm': 0.25.10
      '@esbuild/linux-arm64': 0.25.10
      '@esbuild/linux-ia32': 0.25.10
      '@esbuild/linux-loong64': 0.25.10
      '@esbuild/linux-mips64el': 0.25.10
      '@esbuild/linux-ppc64': 0.25.10
      '@esbuild/linux-riscv64': 0.25.10
      '@esbuild/linux-s390x': 0.25.10
      '@esbuild/linux-x64': 0.25.10
      '@esbuild/netbsd-arm64': 0.25.10
      '@esbuild/netbsd-x64': 0.25.10
      '@esbuild/openbsd-arm64': 0.25.10
      '@esbuild/openbsd-x64': 0.25.10
      '@esbuild/openharmony-arm64': 0.25.10
      '@esbuild/sunos-x64': 0.25.10
      '@esbuild/win32-arm64': 0.25.10
      '@esbuild/win32-ia32': 0.25.10
      '@esbuild/win32-x64': 0.25.10

  fast-decode-uri-component@1.0.1: {}

  fast-deep-equal@3.1.3: {}

  fast-json-stringify@6.1.1:
    dependencies:
      '@fastify/merge-json-schemas': 0.2.1
      ajv: 8.17.1
      ajv-formats: 3.0.1(ajv@8.17.1)
      fast-uri: 3.1.0
      json-schema-ref-resolver: 3.0.0
      rfdc: 1.4.1

  fast-querystring@1.1.2:
    dependencies:
      fast-decode-uri-component: 1.0.1

  fast-uri@3.1.0: {}

  fastify-plugin@5.1.0: {}

  fastify@5.6.1:
    dependencies:
      '@fastify/ajv-compiler': 4.0.2
      '@fastify/error': 4.2.0
      '@fastify/fast-json-stringify-compiler': 5.0.3
      '@fastify/proxy-addr': 5.1.0
      abstract-logging: 2.0.1
      avvio: 9.1.0
      fast-json-stringify: 6.1.1
      find-my-way: 9.3.0
      light-my-request: 6.6.0
      pino: 9.13.1
      process-warning: 5.0.0
      rfdc: 1.4.1
      secure-json-parse: 4.1.0
      semver: 7.7.3
      toad-cache: 3.7.0

  fastq@1.19.1:
    dependencies:
      reusify: 1.1.0

  find-my-way@9.3.0:
    dependencies:
      fast-deep-equal: 3.1.3
      fast-querystring: 1.1.2
      safe-regex2: 5.0.0

  fsevents@2.3.3:
    optional: true

  get-tsconfig@4.12.0:
    dependencies:
      resolve-pkg-maps: 1.0.0

  ipaddr.js@2.2.0: {}

  json-schema-ref-resolver@3.0.0:
    dependencies:
      dequal: 2.0.3

  json-schema-traverse@1.0.0: {}

  light-my-request@6.6.0:
    dependencies:
      cookie: 1.0.2
      process-warning: 4.0.1
      set-cookie-parser: 2.7.1

  on-exit-leak-free@2.1.2: {}

  pino-abstract-transport@2.0.0:
    dependencies:
      split2: 4.2.0

  pino-std-serializers@7.0.0: {}

  pino@9.13.1:
    dependencies:
      atomic-sleep: 1.0.0
      on-exit-leak-free: 2.1.2
      pino-abstract-transport: 2.0.0
      pino-std-serializers: 7.0.0
      process-warning: 5.0.0
      quick-format-unescaped: 4.0.4
      real-require: 0.2.0
      safe-stable-stringify: 2.5.0
      slow-redact: 0.3.1
      sonic-boom: 4.2.0
      thread-stream: 3.1.0

  process-warning@4.0.1: {}

  process-warning@5.0.0: {}

  quick-format-unescaped@4.0.4: {}

  real-require@0.2.0: {}

  require-from-string@2.0.2: {}

  resolve-pkg-maps@1.0.0: {}

  ret@0.5.0: {}

  reusify@1.1.0: {}

  rfdc@1.4.1: {}

  safe-regex2@5.0.0:
    dependencies:
      ret: 0.5.0

  safe-stable-stringify@2.5.0: {}

  secure-json-parse@4.1.0: {}

  semver@7.7.3: {}

  set-cookie-parser@2.7.1: {}

  slow-redact@0.3.1: {}

  sonic-boom@4.2.0:
    dependencies:
      atomic-sleep: 1.0.0

  split2@4.2.0: {}

  thread-stream@3.1.0:
    dependencies:
      real-require: 0.2.0

  toad-cache@3.7.0: {}

  tsx@4.20.6:
    dependencies:
      esbuild: 0.25.10
      get-tsconfig: 4.12.0
    optionalDependencies:
      fsevents: 2.3.3

  typescript@5.9.3: {}

  undici-types@7.14.0: {}



============================================================
FILE: C:\src\apgms-final\services\api-gateway\seed_data.sql
============================================================


============================================================
FILE: C:\src\apgms-final\services\api-gateway\src\app.ts
============================================================
import Fastify, {
  type FastifyInstance,
  type FastifyPluginAsync,
} from "fastify";
import cors from "@fastify/cors";
import helmet from "@fastify/helmet";
import { context, trace } from "@opentelemetry/api";
import "dotenv/config.js";

import {
  AppError,
  badRequest,
  conflict,
  forbidden,
  notFound,
  unauthorized,
} from "@apgms/shared";
import { config } from "./config.js";

import rateLimit from "./plugins/rate-limit.js";
import { authGuard, createAuthGuard, REGULATOR_AUDIENCE } from "./auth.js";
import { registerAuthRoutes } from "./routes/auth.js";
import { helmetConfigFor } from "./security-headers";
import { registerRegulatorAuthRoutes } from "./routes/regulator-auth.js";
import { registerRegulatorRoutes } from "./routes/regulator.js";
import { registerAdminDataRoutes } from "./routes/admin.data.js";
import { registerBankLinesRoutes } from "./routes/bank-lines.js";
import { registerTaxRoutes } from "./routes/tax.js";

import registerConnectorRoutes from "./routes/connectors.js";
import { prisma } from "./db.js";
import { parseWithSchema } from "./lib/validation.js";
import { registerBasRoutes } from "./routes/bas.js";
import { registerTransferRoutes } from "./routes/transfers.js";
import { registerIntegrationEventRoutes } from "./routes/integration-events.js";
import {
  verifyChallenge,
  requireRecentVerification,
  type VerifyChallengeResult,
} from "./security/mfa.js";
import { recordAuditLog } from "./lib/audit.js";
import { ensureRegulatorSessionActive } from "./lib/regulator-session.js";
import {
  metrics,
  installHttpMetrics,
  registerMetricsRoute,
} from "./observability/metrics.js";
import { closeProviders, initProviders } from "./providers.js";
import { registerPaymentPlanRoutes } from "./routes/payment-plans.js";
import { registerAtoRoutes } from "./routes/ato.js";
import { registerMonitoringRoutes } from "./routes/monitoring.js";
import { registerRiskRoutes } from "./routes/risk.js";
import { registerDemoRoutes } from "./routes/demo.js";
import { registerComplianceProxy } from "./routes/compliance-proxy.js";
import { registerComplianceMonitorRoutes } from "./routes/compliance-monitor.js";
import { registerOnboardingRoutes } from "./routes/onboarding.js";
import { registerForecastRoutes } from "./routes/forecast.js";
import { ERROR_MESSAGES } from "./lib/errors.js";
export * from "./designated-accounts/mappings";

type BuildServerOptions = {
  bankLinesPlugin?: FastifyPluginAsync;
};

export async function buildServer(
  options: BuildServerOptions = {},
): Promise<FastifyInstance> {
  const app = Fastify({ logger: true });

  installHttpMetrics(app);

  const allowedOrigins = new Set(config.cors.allowedOrigins);

  const providers = await initProviders(app.log);
  (app as any).providers = providers;
  app.addHook("onClose", async () => {
    await closeProviders(providers, app.log);
  });

  const drainingState = { value: false };
  (app as any).isDraining = () => drainingState.value;
  (app as any).setDraining = (v: boolean) => {
    drainingState.value = v;
  };

  app.addHook("onRequest", (request, reply, done) => {
    const span = trace.getSpan(context.active());
    if (span) {
      const traceId = span.spanContext().traceId;
      if (traceId) {
        request.log = request.log.child({ traceId });
        reply.log = reply.log.child({ traceId });
      }
    }

    const route = request.routeOptions?.url ?? request.raw.url ?? "unknown";
    const timer = metrics.httpRequestDuration.startTimer({
      method: request.method,
      route,
    });
    (reply as any).__metrics = { timer, method: request.method, route };
    done();
  });

  app.addHook("onResponse", (request, reply, done) => {
    const metricState = (reply as any).__metrics ?? {};
    const route =
      metricState.route ??
      request.routeOptions?.url ??
      request.raw.url ??
      "unknown";
    const method = metricState.method ?? request.method;
    const status = String(reply.statusCode);

    try {
      metrics.httpRequestTotal.labels(method, route, status).inc();
      if (typeof metricState.timer === "function") {
        metricState.timer({ status });
      } else {
        const end = metrics.httpRequestDuration.startTimer({ method, route });
        end({ status });
      }
    } catch (error) {
      request.log.warn({ err: error }, "failed_to_record_http_metrics");
    } finally {
      (reply as any).__metrics = undefined;
    }
    done();
  });

  app.setErrorHandler((error, request, reply) => {
    if (error instanceof AppError) {
      const appError = error as AppError;
      reply.status(appError.status).send({
        error: {
          code: appError.code,
          message: appError.message,
          fields: appError.fields,
        },
      });
      return;
    }
    if ((error as any)?.validation) {
      reply.status(400).send({
        error: { code: "invalid_body", message: "Validation failed" },
      });
      return;
    }
    if ((error as any)?.code === "FST_CORS_FORBIDDEN_ORIGIN") {
      reply.status(403).send({
        error: {
          code: "cors_forbidden",
          message: ERROR_MESSAGES.cors_forbidden,
        },
      });
      return;
    }
    request.log.error({ err: error }, "Unhandled error");
    reply.status(500).send({
      error: {
        code: "internal_error",
        message: ERROR_MESSAGES.internal_error,
      },
    });
  });

  await app.register(rateLimit);

  // Use extracted, testable helmet configuration
  await app.register(helmet, helmetConfigFor(config));

  await app.register(cors, {
    origin: (origin, cb) => {
      if (!origin) return cb(null, false);
      if (allowedOrigins.has(origin)) return cb(null, true);
      const error = new Error(`Origin ${origin} is not allowed`);
      cb(
        Object.assign(error, {
          code: "FST_CORS_FORBIDDEN_ORIGIN",
          statusCode: 403,
        }),
        false,
      );
    },
    methods: ["GET", "POST", "OPTIONS"],
    allowedHeaders: ["Content-Type", "Authorization", "Idempotency-Key"],
    exposedHeaders: ["Idempotent-Replay"],
  });

  app.get("/health", async () => ({ ok: true, service: "api-gateway" }));

  app.get("/ready", async (_request, reply) => {
    if ((app as any).isDraining?.() === true) {
      reply.code(503).send({ ok: false, draining: true });
      return;
    }

    const providerState = (app as any).providers ?? {};
    const results: {
      db: boolean;
      redis: boolean | null;
      nats: boolean | null;
    } = {
      db: false,
      redis: providerState.redis ? false : null,
      nats: providerState.nats ? false : null,
    };

    try {
      await prisma.$queryRaw`SELECT 1`;
      results.db = true;
    } catch (error) {
      app.log.error({ err: error }, "readiness_db_check_failed");
      results.db = false;
    }

    if (providerState.redis) {
      try {
        await providerState.redis.ping();
        results.redis = true;
      } catch (error) {
        results.redis = false;
        app.log.error({ err: error }, "readiness_redis_ping_failed");
      }
    }

    if (providerState.nats) {
      try {
        await providerState.nats.flush();
        results.nats = true;
      } catch (error) {
        results.nats = false;
        app.log.error({ err: error }, "readiness_nats_flush_failed");
      }
    }

    const healthy =
      results.db && results.redis !== false && results.nats !== false;
    if (!healthy) {
      reply.code(503).send({ ok: false, components: results });
      return;
    }

    reply.send({ ok: true, components: results });
  });

  registerMetricsRoute(app);

  await registerAuthRoutes(app);
  await registerRegulatorAuthRoutes(app);

  // All customer/admin routes under auth guard
  await app.register(async (secureScope) => {
    secureScope.addHook("onRequest", authGuard);

    const bankLinesPlugin = options.bankLinesPlugin ?? registerBankLinesRoutes;
    await secureScope.register(bankLinesPlugin);
    await secureScope.register(registerAdminDataRoutes);
    await secureScope.register(registerTaxRoutes);
    await secureScope.register(registerIntegrationEventRoutes);
    await secureScope.register(registerBasRoutes);
    await secureScope.register(registerTransferRoutes);
    await secureScope.register(registerPaymentPlanRoutes);
    await secureScope.register(registerAtoRoutes);
    await secureScope.register(registerMonitoringRoutes);
    await secureScope.register(registerRiskRoutes);
    await secureScope.register(registerDemoRoutes);
    await secureScope.register(registerComplianceMonitorRoutes);

    // Onboarding + forecast inside authenticated scope
    await secureScope.register(registerOnboardingRoutes);
    await secureScope.register(registerForecastRoutes);

    // compliance proxy mounts onto root app, not secureScope
    await registerComplianceProxy(app, {} as any);

    // Connector routes as a standard Fastify plugin
    await secureScope.register(registerConnectorRoutes);
  });

  const regulatorAuthGuard = createAuthGuard(REGULATOR_AUDIENCE, {
    validate: async (principal, request) => {
      const sessionId = (principal.sessionId ?? principal.id) as
        | string
        | undefined;
      if (!sessionId) throw new Error("regulator_session_missing");
      const session = await ensureRegulatorSessionActive(sessionId);
      (request as any).regulatorSession = session;
    },
  });

  app.register(
    async (regScope) => {
      regScope.addHook("onRequest", regulatorAuthGuard);
      await registerRegulatorRoutes(regScope);
    },
    { prefix: "/regulator" },
  );

  app.register(registerPayrollRoutes);

  return app;
}



============================================================
FILE: C:\src\apgms-final\services\api-gateway\src\auth.ts
============================================================
// services/api-gateway/src/auth.ts
import { FastifyReply, FastifyRequest } from "fastify";
import jwt, { JwtPayload, type Secret } from "jsonwebtoken";
import { SignJWT, importJWK, type JWK } from "jose";

import { verifyPassword } from "@apgms/shared";
import { verifyRequest, AuthError as JwtAuthError, type Principal } from "./lib/auth.js";

import { prisma } from "./db.js";

function requireEnv(name: string): string {
  const value = process.env[name];
  if (!value) {
    throw new Error(`${name} is required`);
  }
  return value;
}

const AUD = requireEnv("AUTH_AUDIENCE");
const ISS = requireEnv("AUTH_ISSUER");
const SECRET: Secret | undefined = process.env.AUTH_DEV_SECRET;
const regulatorAudience = process.env.REGULATOR_JWT_AUDIENCE?.trim();
const REGULATOR_AUD =
  regulatorAudience && regulatorAudience.length
    ? regulatorAudience
    : "urn:apgms:regulator";

type SigningKey = {
  kid: string;
  key: Parameters<typeof SignJWT.prototype.sign>[0];
  alg: string;
};

let signingKeyCache: SigningKey | null = null;

async function loadSigningKey(): Promise<SigningKey | null> {
  if (signingKeyCache) {
    return signingKeyCache;
  }
  const jwksEnv = process.env.AUTH_JWKS;
  if (!jwksEnv) {
    return null;
  }
  let parsed: { keys?: JWK[] };
  try {
    parsed = JSON.parse(jwksEnv) as { keys?: JWK[] };
  } catch {
    return null;
  }
  const jwk = (parsed.keys ?? []).find(
    (entry) =>
      entry.kid && entry.alg && typeof entry.d === "string" && entry.d.length > 0,
  );
  if (!jwk) {
    return null;
  }
  const key = await importJWK(jwk, jwk.alg);
  const kid = jwk.kid;
  const alg = jwk.alg;
  if (!kid || !alg) {
    throw new Error("JWT header missing kid or alg");
  }
  signingKeyCache = { kid, key, alg };
  return signingKeyCache;
}

export type TokenClaims = JwtPayload & {
  orgId?: string;
  org?: string;
  roles?: string[];
  role?: string;
  regulator?: boolean;
  sessionId?: string;
};

export interface SignTokenOptions {
  audience?: string;
  expiresIn?: string;
  subject?: string;
  extraClaims?: Record<string, unknown>;
}

export interface AuthenticatedUser {
  sub: string;
  orgId: string;
  role: string;
  mfaEnabled: boolean;
  regulator?: boolean;
  sessionId?: string;
}

declare module "fastify" {
  interface FastifyRequest {
    user?: AuthenticatedUser;
  }
}

function toSessionUser(user: {
  id: string;
  orgId: string;
  role?: string | null;
  mfaEnabled?: boolean | null;
}): AuthenticatedUser {
  return {
    sub: user.id,
    orgId: user.orgId,
    role: user.role ?? "admin",
    mfaEnabled: Boolean(user.mfaEnabled),
  };
}

export async function signToken(
  user: {
    id: string;
    orgId: string;
    role?: string;
    mfaEnabled?: boolean;
  },
  options: SignTokenOptions = {},
): Promise<string> {
  const payload: TokenClaims = {
    sub: options.subject ?? user.id,
    orgId: user.orgId,
    role: user.role ?? "admin",
    mfaEnabled: user.mfaEnabled ?? false,
    ...(options.extraClaims ?? {}),
  };

  const audience = options.audience ?? AUD;
  const issuer = ISS;
  const expiresIn = options.expiresIn ?? "1h";

  const signingKey = await loadSigningKey();
  if (signingKey) {
    const token = await new SignJWT(payload)
      .setProtectedHeader({ alg: signingKey.alg, kid: signingKey.kid })
      .setAudience(audience)
      .setIssuer(issuer)
      .setSubject(String(payload.sub))
      .setExpirationTime(expiresIn)
      .setIssuedAt()
      .sign(signingKey.key);
    return token;
  }

  const secret = SECRET;
  if (!secret) {
    throw new Error("AUTH_DEV_SECRET is required when no JWKS signing key is configured");
  }
  const signingSecret: Secret = secret;
  const signOptions: jwt.SignOptions = {
    algorithm: "HS256",
    audience,
    issuer,
    expiresIn: expiresIn as jwt.SignOptions["expiresIn"],
  };

  return jwt.sign(payload, signingSecret, signOptions);
}

type GuardValidateFn = (
  principal: Principal,
  request: FastifyRequest,
) => Promise<void> | void;

interface GuardOptions {
  validate?: GuardValidateFn;
}

export function createAuthGuard(
  expectedAudience: string,
  options: GuardOptions = {},
) {
  return async function authGuardInstance(
    request: FastifyRequest,
    reply: FastifyReply,
  ) {
    try {
      const principal = await verifyRequest(request, reply, {
        audience: expectedAudience,
      });

      if (options.validate) {
        await options.validate(principal, request);
      }

      const context: AuthenticatedUser = {
        sub: principal.id,
        orgId: principal.orgId,
        role: principal.roles[0] ?? "admin",
        mfaEnabled: principal.mfaEnabled,
        regulator: principal.regulator,
        sessionId: principal.sessionId,
      };

      (request as any).user = context;
    } catch (error) {
      if (error instanceof JwtAuthError) {
        reply.code(error.statusCode).send({
          error: { code: error.code ?? "unauthorized", message: error.message },
        });
        return;
      }
      reply.code(401).send({
        error: { code: "unauthorized", message: "Invalid token" },
      });
      return;
    }
  };
}

export const authGuard = createAuthGuard(AUD);
export const REGULATOR_AUDIENCE = REGULATOR_AUD;

export async function verifyCredentials(
  email: string,
  pw: string,
) {
  const user = await prisma.user.findUnique({
    where: { email },
    select: {
      id: true,
      orgId: true,
      role: true,
      mfaEnabled: true,
      password: true,
    },
  });
  if (!user) return null;

  const ok = await verifyPassword(user.password, pw);
  if (!ok) return null;

  return {
    id: user.id,
    orgId: user.orgId,
    role: user.role ?? "admin",
    mfaEnabled: user.mfaEnabled ?? false,
  };
}

export function buildSessionUser(user: {
  id: string;
  orgId: string;
  role?: string | null;
  mfaEnabled?: boolean | null;
}): AuthenticatedUser {
  return toSessionUser(user);
}

export function buildClientUser(user: AuthenticatedUser) {
  return {
    id: user.sub,
    orgId: user.orgId,
    role: user.role,
    mfaEnabled: user.mfaEnabled,
  };
}



============================================================
FILE: C:\src\apgms-final\services\api-gateway\src\config.ts
============================================================
// services/api-gateway/src/config.ts
import { Buffer } from "node:buffer";
import { URL } from "node:url";
import { z } from "zod";

export interface AppConfig {
  readonly env: "local" | "test" | "development" | "staging" | "production";

  readonly databaseUrl: string;
  readonly shadowDatabaseUrl?: string;
  readonly rateLimit: {
    readonly max: number;
    readonly window: string;
  };
  readonly security: {
    readonly authFailureThreshold: number;
    readonly kmsKeysetLoaded?: boolean;
    readonly requireHttps: boolean;
    readonly enableIsolation?: boolean; 
  };
  readonly cors: {
    readonly allowedOrigins: string[];
  };
  readonly taxEngineUrl: string;

  readonly auth: {
    readonly audience: string;
    readonly issuer: string;
    readonly devSecret: string;
  };
  readonly regulator: {
    readonly accessCode: string;
    readonly jwtAudience: string;
    readonly sessionTtlMinutes: number;
  };
  readonly encryption: {
    readonly masterKey: Buffer;
  };
  readonly webauthn: {
    readonly rpId: string;
    readonly rpName: string;
    readonly origin: string;
  };
  readonly banking: {
    readonly providerId: string;
    readonly maxReadTransactions: number;
    readonly maxWriteCents: number;
  };
  readonly redis?: {
    readonly url: string;
  };
  readonly nats?: {
    readonly url: string;
    readonly token?: string;
    readonly username?: string;
    readonly password?: string;
  };
}

const base64Regex = /^[A-Za-z0-9+/=]+$/;

const jwksKeySchema = z.object({
  kid: z.string().min(1),
  alg: z.string().min(1),
});

const envString = (name: string): string => {
  const value = process.env[name];
  if (!value || value.trim().length === 0) {
    throw new Error(`${name} is required`);
  }
  return value.trim();
};

const envDefault = (name: string, fallback: string): string => {
  const value = process.env[name];
  if (!value || value.trim().length === 0) {
    return fallback;
  }
  return value.trim();
};

const parseIntegerEnv = (name: string, fallback: number): number => {
  const raw = process.env[name];
  if (!raw || raw.trim().length === 0) {
    return fallback;
  }
  const parsed = Number.parseInt(raw, 10);
  if (!Number.isFinite(parsed) || parsed <= 0) {
    throw new Error(`${name} must be a positive integer`);
  }
  return parsed;
};

const ensureUrl = (value: string, name: string): string => {
  try {
    // eslint-disable-next-line no-new
    new URL(value);
    return value;
  } catch {
    throw new Error(`${name} must be a valid URL`);
  }
};

const ensureMasterKey = (raw: string): Buffer => {
  if (!base64Regex.test(raw)) {
    throw new Error("ENCRYPTION_MASTER_KEY must be base64 encoded");
  }
  const key = Buffer.from(raw, "base64");
  if (key.length !== 32) {
    throw new Error("ENCRYPTION_MASTER_KEY must decode to 32 bytes");
  }
  return key;
};

const parseJson = <T>(value: string, name: string): T => {
  try {
    return JSON.parse(value) as T;
  } catch {
    throw new Error(`${name} must contain valid JSON`);
  }
};

const ensureJwksConfigured = (raw: string): void => {
  const parsed = parseJson<{ keys?: unknown }>(raw, "AUTH_JWKS");
  const schema = z
    .object({
      keys: z.array(jwksKeySchema).min(1),
    })
    .safeParse(parsed);
  if (!schema.success) {
    throw new Error(
      `AUTH_JWKS must contain at least one key with kid/alg: ${schema.error.message}`,
    );
  }
};

const ensureKeyMaterial = (
  value: string,
  name: string,
): Array<{ kid: string; material: string }> => {
  const parsed = parseJson<Array<{ kid?: unknown; material?: unknown }>>(
    value,
    name,
  );
  const schema = z
    .array(
      z.object({
        kid: z.string().min(1),
        material: z
          .string()
          .regex(base64Regex, "expected base64 material")
          .refine(
            (material) => Buffer.from(material, "base64").length === 32,
            {
              message: "material must decode to 32 bytes",
            },
          ),
      }),
    )
    .min(1);

  const result = schema.safeParse(parsed);
  if (!result.success) {
    throw new Error(`${name} invalid: ${result.error.message}`);
  }
  return result.data;
};

const ensureSaltMaterial = (
  value: string,
  name: string,
): Array<{ sid: string; secret: string }> => {
  const parsed = parseJson<Array<{ sid?: unknown; secret?: unknown }>>(
    value,
    name,
  );
  const schema = z
    .array(
      z.object({
        sid: z.string().min(1),
        secret: z
          .string()
          .regex(base64Regex, "expected base64 secret")
          .refine(
            (secret) => Buffer.from(secret, "base64").length === 32,
            {
              message: "secret must decode to 32 bytes",
            },
          ),
      }),
    )
    .min(1);

  const result = schema.safeParse(parsed);
  if (!result.success) {
    throw new Error(`${name} invalid: ${result.error.message}`);
  }
  return result.data;
};

const splitOrigins = (raw: string | undefined): string[] => {
  if (!raw) {
    return [];
  }
  return raw
    .split(",")
    .map((entry) => entry.trim())
    .filter((entry) => entry.length > 0);
};

// This builds a config object from process.env with validation.
export function loadConfig(): AppConfig {
  const rawEnv = process.env.APP_ENV ?? process.env.NODE_ENV ?? "local";
  const env = (rawEnv && rawEnv.trim().length > 0
    ? rawEnv.trim()
    : "local") as AppConfig["env"];
  // DB URLs
  const databaseUrl = ensureUrl(
    envString("DATABASE_URL"),
    "DATABASE_URL",
  );

  const shadowDatabaseUrlRaw = process.env.SHADOW_DATABASE_URL;
  const shadowDatabaseUrl =
    shadowDatabaseUrlRaw && shadowDatabaseUrlRaw.trim().length > 0
      ? ensureUrl(
          shadowDatabaseUrlRaw.trim(),
          "SHADOW_DATABASE_URL",
        )
      : undefined;

  // auth inputs must exist / be sane
  const audience =
    envDefault("AUTH_AUDIENCE", "http://localhost:3000");
  const issuer = envDefault(
    "AUTH_ISSUER",
    "https://auth.localhost",
  );
  const devSecret = envDefault(
    "AUTH_DEV_SECRET",
    "local-dev-secret",
  );

  const jwksRaw = envDefault(
    "AUTH_JWKS",
    JSON.stringify({ keys: [{ kid: "local-dev", alg: "RS256" }] }),
  );
  ensureJwksConfigured(jwksRaw);

  // encryption/key material must exist / be sane
  const keySet = ensureKeyMaterial(
    envString("PII_KEYS"),
    "PII_KEYS",
  );
  const activeKid = envString("PII_ACTIVE_KEY");
  if (!keySet.some((entry) => entry.kid === activeKid)) {
    throw new Error(
      `PII_ACTIVE_KEY ${activeKid} does not exist in PII_KEYS`,
    );
  }

  const saltSet = ensureSaltMaterial(
    envString("PII_SALTS"),
    "PII_SALTS",
  );
  const activeSid = envString("PII_ACTIVE_SALT");
  if (!saltSet.some((entry) => entry.sid === activeSid)) {
    throw new Error(
      `PII_ACTIVE_SALT ${activeSid} does not exist in PII_SALTS`,
    );
  }

  const masterKey = ensureMasterKey(envString("ENCRYPTION_MASTER_KEY"));

  // if we reached here, PII is valid
  const kmsKeysetLoaded = true;
  const requireHttps = process.env.REQUIRE_TLS === "true";
  const enableIsolation = process.env.SECURITY_ENABLE_ISOLATION === "true";


  // rate limit config
  const rateLimitMax = parseIntegerEnv(
    "API_RATE_LIMIT_MAX",
    60,
  );
  const rateLimitWindow = (
    process.env.API_RATE_LIMIT_WINDOW ?? "1 minute"
  ).trim();
  if (rateLimitWindow.length === 0) {
    throw new Error(
      "API_RATE_LIMIT_WINDOW must not be empty",
    );
  }

  // auth brute force threshold
  const authFailureThreshold = parseIntegerEnv(
    "AUTH_FAILURE_THRESHOLD",
    5,
  );

  // tax-engine URL
  const taxEngineUrl = ensureUrl(
    process.env.TAX_ENGINE_URL?.trim() &&
      process.env.TAX_ENGINE_URL.trim().length > 0
      ? process.env.TAX_ENGINE_URL.trim()
      : "http://tax-engine:8000",
    "TAX_ENGINE_URL",
  );

  const regulatorAccessCode = envString("REGULATOR_ACCESS_CODE");
  const regulatorAudience =
    process.env.REGULATOR_JWT_AUDIENCE &&
    process.env.REGULATOR_JWT_AUDIENCE.trim().length > 0
      ? process.env.REGULATOR_JWT_AUDIENCE.trim()
      : "urn:apgms:regulator";
  const regulatorSessionTtl = parseIntegerEnv(
    "REGULATOR_SESSION_TTL_MINUTES",
    60,
  );

  const webauthnRpId = process.env.WEBAUTHN_RP_ID?.trim() ?? "localhost";
  const webauthnRpName = process.env.WEBAUTHN_RP_NAME?.trim() ?? "APGMS Admin";
  const webauthnOrigin = ensureUrl(
    process.env.WEBAUTHN_ORIGIN?.trim() ?? "http://localhost:5173",
    "WEBAUTHN_ORIGIN",
  );

  const bankingProvider =
    process.env.BANKING_PROVIDER?.trim().toLowerCase() ?? "mock";
  const bankingMaxRead = parseIntegerEnv(
    "BANKING_MAX_READ_TRANSACTIONS",
    1000,
  );
  const bankingMaxWrite = parseIntegerEnv(
    "BANKING_MAX_WRITE_CENTS",
    5_000_000,
  );

  const corsAllowedOrigins = splitOrigins(
    envDefault("CORS_ALLOWED_ORIGINS", "http://localhost:5173"),
  );

  const redisUrlRaw = process.env.REDIS_URL?.trim();
  const redis =
    redisUrlRaw && redisUrlRaw.length > 0
      ? {
          url: ensureUrl(redisUrlRaw, "REDIS_URL"),
        }
      : undefined;

  const natsUrlRaw = process.env.NATS_URL?.trim();
  const nats =
    natsUrlRaw && natsUrlRaw.length > 0
      ? {
          url: ensureUrl(natsUrlRaw, "NATS_URL"),
          token: process.env.NATS_TOKEN?.trim() || undefined,
          username: process.env.NATS_USERNAME?.trim() || undefined,
          password: process.env.NATS_PASSWORD?.trim() || undefined,
        }
      : undefined;

  return {
    env,

    databaseUrl,
    shadowDatabaseUrl,
    rateLimit: {
      max: rateLimitMax,
      window: rateLimitWindow,
    },
    security: {
      authFailureThreshold,
      kmsKeysetLoaded,
      requireHttps,
      enableIsolation,
    },
    cors: {
      allowedOrigins: corsAllowedOrigins,
    },
    taxEngineUrl,
    auth: {
      audience,
      issuer,
      devSecret,
    },
    regulator: {
      accessCode: regulatorAccessCode,
      jwtAudience: regulatorAudience,
      sessionTtlMinutes: regulatorSessionTtl,
    },
    encryption: {
      masterKey,
    },
    webauthn: {
      rpId: webauthnRpId,
      rpName: webauthnRpName,
      origin: webauthnOrigin,
    },
    banking: {
      providerId: bankingProvider.length > 0 ? bankingProvider : "mock",
      maxReadTransactions: bankingMaxRead,
      maxWriteCents: bankingMaxWrite,
    },
    redis,
    nats,
  };
}

// 🔥 THIS is what app.ts imports
export const config: AppConfig = loadConfig();



============================================================
FILE: C:\src\apgms-final\services\api-gateway\src\db.ts
============================================================
// services/api-gateway/src/db.ts
import pkg from "@prisma/client";
import { instrumentPrisma } from "./observability/prisma-metrics.js";

// Prisma v6 ships its client on the default export. TypeScript's view of the
// default export doesn't declare PrismaClient as a value, so we cast.
const { PrismaClient } = pkg as unknown as {
  PrismaClient: new (...args: any[]) => any;
};

const prismaClient = new PrismaClient();

export const prisma = instrumentPrisma(prismaClient);



============================================================
FILE: C:\src\apgms-final\services\api-gateway\src\index.js
============================================================
import process from "node:process";
import path from "node:path";
import { fileURLToPath } from "node:url";
import dotenv from "dotenv";
import { createApp } from "./app";
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
dotenv.config({ path: path.resolve(__dirname, "../../../.env") });
const app = await createApp();
let shuttingDown = false;
const port = Number(process.env.PORT ?? 3000);
const host = "0.0.0.0";
app
    .listen({ port, host })
    .then(() => {
    app.log.info({ port, host }, "api-gateway listening");
})
    .catch((err) => {
    app.log.error({ err }, "failed to start api-gateway");
    process.exit(1);
});
async function shutdown(signal) {
    if (shuttingDown)
        return;
    shuttingDown = true;
    app.log.info({ signal }, "received shutdown signal");
    try {
        await app.close();
        app.log.info("api-gateway shut down cleanly");
        process.exit(0);
    }
    catch (error) {
        app.log.error({ error }, "error during shutdown");
        process.exit(1);
    }
}
const signals = ["SIGINT", "SIGTERM"];
for (const signal of signals) {
    process.on(signal, () => {
        void shutdown(signal);
    });
}
process.on("unhandledRejection", (reason) => {
    app.log.error({ reason }, "unhandled rejection");
});
process.on("uncaughtException", (error) => {
    app.log.error({ error }, "uncaught exception");
    void shutdown("uncaughtException");
});



============================================================
FILE: C:\src\apgms-final\services\api-gateway\src\index.ts
============================================================
import { buildServer } from "./app.js";
import { startTracing, stopTracing } from "./observability/tracing.js";


const port = Number(process.env.PORT ?? 3000);
const host = process.env.HOST ?? "0.0.0.0";

async function main() {
  await startTracing();

  const app = await buildServer();

  const shutdown = async (signal: string) => {
    try {
      app.log.info({ signal }, "shutdown_start");
      try {
        // @ts-ignore custom decorator defined in app.ts
        app.setDraining?.(true);
      } catch {}
      await app.close();
      await stopTracing();
      app.log.info("shutdown_complete");
    } catch (err) {
      app.log.error({ err }, "shutdown_error");
    } finally {
      process.exit(0);
    }
  };

  process.on("SIGINT", () => shutdown("SIGINT"));
  process.on("SIGTERM", () => shutdown("SIGTERM"));

  await app.listen({ port, host });
  app.log.info({ url: `http://${host}:${port}` }, "api-gateway_up");
}

main().catch(async (err) => {
  console.error("fatal_startup_error", err);
  await stopTracing();
  process.exit(1);
});



============================================================
FILE: C:\src\apgms-final\services\api-gateway\src\lib\ato.ts
============================================================
// Thin wrapper so routes can import a stable function name.
// Swap implementation here when you wire up real ABR/ATO integration.

import {
  validateAbnOrTfnStub,
  type AbnTfnLookupResult,
} from "../services/abr-stub.js";

export async function validateAbnTfn(
  abn?: string,
  tfn?: string,
): Promise<AbnTfnLookupResult> {
  return validateAbnOrTfnStub({ abn, tfn });
}

export type { AbnTfnLookupResult };



============================================================
FILE: C:\src\apgms-final\services\api-gateway\src\lib\audit.ts
============================================================
// services/api-gateway/src/lib/audit.ts
import crypto from "node:crypto";
import { prisma } from "../db.js";

type RecordAuditLogParams = {
  orgId: string;
  actorId: string;
  action: string;
  // We only need this to be JSON-serialisable; avoid hard Prisma typing.
  metadata?: unknown | null;
  throwOnError?: boolean;
  timestamp?: Date;
};

export async function recordAuditLog({
  orgId,
  actorId,
  action,
  metadata,
  throwOnError = false,
  timestamp,
}: RecordAuditLogParams): Promise<void> {
  try {
    const previous = await prisma.auditLog.findFirst({
      where: { orgId },
      orderBy: { createdAt: "desc" },
    });

    const createdAt = timestamp ?? new Date();
    const metadataValue = metadata ?? null;
    const prevHash = previous?.hash ?? null;

    const hashPayload = JSON.stringify({
      orgId,
      actorId,
      action,
      metadata: metadataValue,
      createdAt: createdAt.toISOString(),
      prevHash,
    });

    const hash = crypto.createHash("sha256").update(hashPayload).digest("hex");

    await prisma.auditLog.create({
      data: {
        orgId,
        actorId,
        action,
        // Let Prisma coerce this to JSON; avoid JsonNull typings.
        metadata: metadataValue as any,
        createdAt,
        hash,
        prevHash,
      },
    });
  } catch (error) {
    if (throwOnError) {
      throw error;
    }
    // eslint-disable-next-line no-console
    console.warn("audit-log failure", { error, orgId, action });
  }
}

export async function recordCriticalAuditLog(
  params: Omit<RecordAuditLogParams, "throwOnError">
) {
  await recordAuditLog({ ...params, throwOnError: true });
}



============================================================
FILE: C:\src\apgms-final\services\api-gateway\src\lib\auth.js
============================================================
import { Buffer } from "node:buffer";
import { createHash, timingSafeEqual } from "node:crypto";
import { importJWK, jwtVerify, } from "jose";
const clockToleranceSeconds = Number(process.env.AUTH_CLOCK_TOLERANCE_S ?? "5");
const keyCache = new Map();
export class AuthError extends Error {
    statusCode;
    code;
    constructor(message, statusCode = 401, code = "unauthorized") {
        super(message);
        this.statusCode = statusCode;
        this.code = code;
    }
}
async function loadKeys() {
    if (keyCache.size > 0) {
        return;
    }
    const jwksEnv = process.env.AUTH_JWKS;
    if (!jwksEnv) {
        throw new AuthError("JWT configuration missing", 500, "jwt_config_missing");
    }
    let parsed;
    try {
        parsed = JSON.parse(jwksEnv);
    }
    catch (error) {
        throw new AuthError("Invalid JWT key set", 500, "jwt_config_invalid");
    }
    if (!parsed.keys || parsed.keys.length === 0) {
        throw new AuthError("JWT key set is empty", 500, "jwt_config_invalid");
    }
    await Promise.all(parsed.keys.map(async (jwk) => {
        if (!jwk.kid) {
            throw new Error("JWK entries must include a kid");
        }
        if (!jwk.alg) {
            throw new Error(`JWK ${jwk.kid} is missing alg`);
        }
        const key = await importJWK(jwk, jwk.alg);
        keyCache.set(jwk.kid, { kid: jwk.kid, key, alg: jwk.alg });
    }));
}
async function resolveKey(kid) {
    if (!kid) {
        throw new Error("JWT header missing kid");
    }
    const cached = keyCache.get(kid);
    if (!cached) {
        throw new Error(`Unknown kid ${kid}`);
    }
    return cached;
}
function normaliseRoles(raw) {
    if (!Array.isArray(raw)) {
        return [];
    }
    const roles = raw.filter((value) => typeof value === "string");
    return Array.from(new Set(roles));
}
export async function verifyRequest(request, reply) {
    const header = request.headers.authorization ??
        request.headers["Authorization"];
    const audience = process.env.AUTH_AUDIENCE;
    const issuer = process.env.AUTH_ISSUER;
    if (!audience || !issuer) {
        throw new AuthError("JWT configuration missing", 500, "jwt_config_missing");
    }
    await loadKeys();
    const value = Array.isArray(header) ? header?.[0] : header;
    if (!value) {
        throw new AuthError("Authorization header missing");
    }
    const match = /^Bearer\s+(.+)$/i.exec(value.trim());
    if (!match) {
        throw new AuthError("Unsupported authorization scheme");
    }
    const token = match[1];
    let verification;
    try {
        verification = await jwtVerify(token, async (header) => {
            const { kid } = header;
            const key = await resolveKey(kid);
            return key.key;
        }, {
            audience,
            issuer,
            clockTolerance: clockToleranceSeconds,
        });
    }
    catch (error) {
        throw new AuthError("Token verification failed");
    }
    const { payload, protectedHeader } = verification;
    const principal = buildPrincipalFromPayload(payload, protectedHeader.kid, token);
    request.log.debug({
        principal: {
            id: principal.id,
            org: principal.orgId,
            roles: principal.roles,
            kid: protectedHeader.kid,
        },
    }, "verified principal");
    return principal;
}
function buildPrincipalFromPayload(payload, kid, token) {
    const sub = payload.sub;
    const orgId = typeof payload.org === "string" ? payload.org : undefined;
    const roles = normaliseRoles(payload.roles);
    if (!sub || !orgId) {
        throw new AuthError("Token missing required claims");
    }
    if (roles.length === 0) {
        throw new AuthError("Token missing roles claim");
    }
    return {
        id: sub,
        orgId,
        roles,
        token,
    };
}
export function requireRole(principal, allowed) {
    if (allowed.length === 0) {
        return;
    }
    const hasRole = principal.roles.some((role) => allowed.some((allowedRole) => timingSafeEqual(Buffer.from(role), Buffer.from(allowedRole))));
    if (!hasRole) {
        throw new AuthError("Forbidden", 403, "forbidden");
    }
}
export function hashIdentifier(value) {
    return createHash("sha256").update(value).digest("hex").slice(0, 16);
}
export async function authenticateRequest(app, request, reply, roles) {
    const metrics = app.metrics;
    try {
        const principal = await verifyRequest(request, reply);
        requireRole(principal, roles);
        metrics?.recordSecurityEvent("auth.success");
        return principal;
    }
    catch (error) {
        if (error instanceof AuthError) {
            const code = error.statusCode === 403 ? "auth.forbidden" : "auth.unauthorized";
            metrics?.recordSecurityEvent(code);
            void reply.code(error.statusCode).send({ error: error.code ?? "unauthorized" });
            return null;
        }
        throw error;
    }
}



============================================================
FILE: C:\src\apgms-final\services\api-gateway\src\lib\auth.ts
============================================================
import { Buffer } from "node:buffer";
import { createHash, timingSafeEqual } from "node:crypto";
import type { FastifyInstance, FastifyReply, FastifyRequest } from "fastify";
import jwt from "jsonwebtoken";
import {
  importJWK,
  jwtVerify,
  type JWTPayload,
  type JWK,
} from "jose";

const clockToleranceSeconds = Number(process.env.AUTH_CLOCK_TOLERANCE_S ?? "5");

export type Role = "admin" | "analyst" | "finance" | "auditor";

export interface Principal {
  id: string;
  orgId: string;
  roles: Role[];
  token: string;
  mfaEnabled: boolean;
  regulator?: boolean;
  sessionId?: string;
}

interface InternalKey {
  kid: string;
  key: unknown;
  alg: string;
}

const keyCache = new Map<string, InternalKey>();

export class AuthError extends Error {
  public readonly statusCode: number;
  public readonly code: string;

  constructor(message: string, statusCode = 401, code = "unauthorized") {
    super(message);
    this.statusCode = statusCode;
    this.code = code;
  }
}

async function loadKeys(): Promise<void> {
  if (keyCache.size > 0) {
    return;
  }
  const jwksEnv = process.env.AUTH_JWKS;
  if (!jwksEnv || jwksEnv.trim().length === 0) {
    return;
  }
  let parsed: { keys?: JWK[] };
  try {
    parsed = JSON.parse(jwksEnv) as { keys?: JWK[] };
  } catch (error) {
    throw new AuthError("Invalid JWT key set", 500, "jwt_config_invalid");
  }
  if (!parsed.keys || parsed.keys.length === 0) {
    throw new AuthError("JWT key set is empty", 500, "jwt_config_invalid");
  }
  await Promise.all(
    parsed.keys.map(async (jwk) => {
      if (!jwk.kid) {
        throw new Error("JWK entries must include a kid");
      }
      if (!jwk.alg) {
        throw new Error(`JWK ${jwk.kid} is missing alg`);
      }
      const key = await importJWK(jwk, jwk.alg);
      keyCache.set(jwk.kid, { kid: jwk.kid, key, alg: jwk.alg });
    }),
  );
}

async function resolveKey(kid: string | undefined): Promise<InternalKey> {
  if (!kid) {
    throw new Error("JWT header missing kid");
  }
  const cached = keyCache.get(kid);
  if (!cached) {
    throw new Error(`Unknown kid ${kid}`);
  }
  return cached;
}

function normaliseRoles(raw: unknown): Role[] {
  if (!Array.isArray(raw)) {
    return [];
  }
  const roles = raw.filter((value): value is Role => typeof value === "string") as Role[];
  return Array.from(new Set(roles));
}

type VerifyOptions = {
  audience?: string;
  issuer?: string;
};

export async function verifyRequest(
  request: FastifyRequest,
  reply: FastifyReply,
  options?: VerifyOptions,
): Promise<Principal> {
  const header =
    request.headers.authorization ??
    request.headers["Authorization" as keyof typeof request.headers];

  const audience = options?.audience ?? process.env.AUTH_AUDIENCE;
  const issuer = options?.issuer ?? process.env.AUTH_ISSUER;
  if (!audience || !issuer) {
    throw new AuthError("JWT configuration missing", 500, "jwt_config_missing");
  }

  await loadKeys();

  const value = Array.isArray(header) ? header?.[0] : header;
  if (!value) {
    throw new AuthError("Authorization header missing");
  }
  const match = /^Bearer\s+(.+)$/i.exec(value.trim());
  if (!match) {
    throw new AuthError("Unsupported authorization scheme");
  }
  const token = match[1];

  const hasJwks = keyCache.size > 0;
  let payload: JWTPayload;
  let kid: string | undefined;

  if (hasJwks) {
    let verification;
    try {
      verification = await jwtVerify(token, async (header) => {
        const headerKid = header.kid;
        const key = await resolveKey(headerKid);
        kid = headerKid;
        return key.key as any;
      }, {
        audience,
        issuer,
        clockTolerance: clockToleranceSeconds,
      });
    } catch (error) {
      throw new AuthError("Token verification failed");
    }
    payload = verification.payload;
  } else {
    const secret = process.env.AUTH_DEV_SECRET;
    if (!secret) {
      throw new AuthError("Auth secret missing", 500, "auth_secret_missing");
    }
    try {
      payload = jwt.verify(token, secret, {
        audience,
        issuer,
        clockTolerance: clockToleranceSeconds,
      }) as JWTPayload;
    } catch (error) {
      throw new AuthError("Token verification failed");
    }
  }

  const principal = buildPrincipalFromPayload(payload, kid, token);
  request.log.debug(
    {
      principal: {
        id: principal.id,
        org: principal.orgId,
        roles: principal.roles,
        kid,
      },
    },
    "verified principal",
  );

  return principal;
}

function buildPrincipalFromPayload(
  payload: JWTPayload,
  kid: string | undefined,
  token: string,
): Principal {
  const sub = payload.sub;
  const orgId =
    typeof payload.orgId === "string"
      ? payload.orgId
      : typeof payload.org === "string"
      ? payload.org
      : undefined;
  const normalizedRoles =
    typeof payload.roles !== "undefined"
      ? payload.roles
      : typeof payload.role === "string"
      ? [payload.role]
      : undefined;
  const roles = normaliseRoles(normalizedRoles);
  const mfaEnabled = payload.mfaEnabled === true;
  const regulator = payload.regulator === true;
  const sessionId =
    typeof payload.sessionId === "string" ? payload.sessionId : undefined;

  if (!sub || !orgId) {
    throw new AuthError("Token missing required claims");
  }
  if (roles.length === 0) {
    throw new AuthError("Token missing roles claim");
  }

  return {
    id: sub,
    orgId,
    roles,
    token,
    mfaEnabled,
    regulator,
    sessionId,
  };
}

export function requireRole(
  principal: Principal,
  allowed: ReadonlyArray<Role>,
): void {
  if (allowed.length === 0) {
    return;
  }
  const hasRole = principal.roles.some((role) =>
    allowed.some((allowedRole) => timingSafeEqual(Buffer.from(role), Buffer.from(allowedRole))),
  );
  if (!hasRole) {
    throw new AuthError("Forbidden", 403, "forbidden");
  }
}

export function hashIdentifier(value: string): string {
  return createHash("sha256").update(value).digest("hex").slice(0, 16);
}

type MetricsRecorder = {
  recordSecurityEvent: (event: string) => void;
};

export async function authenticateRequest(
  app: FastifyInstance,
  request: FastifyRequest,
  reply: FastifyReply,
  roles: ReadonlyArray<Role>,
): Promise<Principal | null> {
  const metrics = (app as FastifyInstance & { metrics?: MetricsRecorder }).metrics;
  try {
    const principal = await verifyRequest(request, reply);
    requireRole(principal, roles);
    metrics?.recordSecurityEvent("auth.success");
    return principal;
  } catch (error) {
    if (error instanceof AuthError) {
      const code = error.statusCode === 403 ? "auth.forbidden" : "auth.unauthorized";
      metrics?.recordSecurityEvent(code);
      void reply.code(error.statusCode).send({ error: error.code ?? "unauthorized" });
      return null;
    }
    throw error;
  }
}



============================================================
FILE: C:\src\apgms-final\services\api-gateway\src\lib\encryption.ts
============================================================
import { decryptEnvelope, decryptJson, encryptEnvelope, encryptJson, type EncryptionEnvelope } from "@apgms/shared";

import { config } from "../config.js";

const masterKey = config.encryption.masterKey;

export type { EncryptionEnvelope } from "@apgms/shared";

export function sealSecret(value: string, context: string): EncryptionEnvelope {
  return encryptEnvelope(masterKey, value, Buffer.from(context, "utf8"));
}

export function unsealSecret(envelope: EncryptionEnvelope, context: string): string {
  const buffer = decryptEnvelope(masterKey, envelope, Buffer.from(context, "utf8"));
  return buffer.toString("utf8");
}

export function sealObject<T>(value: T, context: string): EncryptionEnvelope {
  return encryptJson(masterKey, value, Buffer.from(context, "utf8"));
}

export function unsealObject<T>(envelope: EncryptionEnvelope, context: string): T {
  return decryptJson<T>(masterKey, envelope, Buffer.from(context, "utf8"));
}



============================================================
FILE: C:\src\apgms-final\services\api-gateway\src\lib\errors.ts
============================================================
// services/api-gateway/src/lib/errors.ts

/**
 * Centralised error messages used across the API gateway.
 *
 * NOTE:
 * We export both UPPER_SNAKE keys and the existing lower_snake keys
 * so older call sites like ERROR_MESSAGES.cors_forbidden still type-check.
 */
export const ERROR_MESSAGES = {
  INTERNAL: "Internal server error",
  BAD_REQUEST: "Bad request",
  NOT_FOUND: "Not found",

  // CORS & legacy keys
  CORS_FORBIDDEN: "CORS origin not allowed",
  INTERNAL_ERROR: "Internal server error",

  // Backwards-compatible lower_snake aliases used in app.ts
  cors_forbidden: "CORS origin not allowed",
  internal_error: "Internal server error",
} as const;

/**
 * Simple domain error type that can be safely mapped to HTTP responses.
 */
export class DomainError extends Error {
  public readonly code: string;
  public readonly statusCode: number;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  public readonly details?: any;

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(code: string, message: string, statusCode = 500, details?: any) {
    super(message);
    this.code = code;
    this.statusCode = statusCode;
    this.details = details;
  }
}

export function internalError(
  message: string = ERROR_MESSAGES.INTERNAL,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  details?: any,
): DomainError {
  return new DomainError("internal_error", message, 500, details);
}

export function badRequest(
  message: string = ERROR_MESSAGES.BAD_REQUEST,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  details?: any,
): DomainError {
  return new DomainError("bad_request", message, 400, details);
}

export function notFound(
  message: string = ERROR_MESSAGES.NOT_FOUND,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  details?: any,
): DomainError {
  return new DomainError("not_found", message, 404, details);
}

/**
 * Normalise any thrown value into an HTTP-friendly shape.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function toHttpError(err: any): {
  statusCode: number;
  body: { code: string; message: string; details?: any };
} {
  if (err instanceof DomainError) {
    return {
      statusCode: err.statusCode,
      body: {
        code: err.code,
        message: err.message,
        details: err.details,
      },
    };
  }

  const statusCode =
    typeof err?.statusCode === "number" ? err.statusCode : 500;
  const code = typeof err?.code === "string" ? err.code : "internal_error";
  const message =
    typeof err?.message === "string"
      ? err.message
      : ERROR_MESSAGES.INTERNAL;

  return {
    statusCode,
    body: {
      code,
      message,
    },
  };
}



============================================================
FILE: C:\src\apgms-final\services\api-gateway\src\lib\idempotency.ts
============================================================
// services/api-gateway/src/lib/idempotency.ts
import { createHash } from "node:crypto";
import type { PrismaClient } from "@prisma/client";
import { conflict } from "@apgms/shared";

type Ctx = {
  prisma: PrismaClient;
  orgId: string;
  actorId?: string;          // not persisted
  requestPayload?: unknown;  // not persisted
  resource?: string | null;
};

type HandlerResult = {
  statusCode: number;
  resource?: string | null;
  resourceId?: string | null;
  body?: unknown;
};

function getIdempotencyKeyFromHeaders(req: any): string {
  const h = (req?.headers ?? {}) as Record<string, unknown>;
  for (const k of ["idempotency-key", "Idempotency-Key", "IDEMPOTENCY-KEY"]) {
    const v = h[k];
    if (typeof v === "string" && v.trim()) return v.trim();
  }
  return `auto:${cryptoSafe()}`;
}

function cryptoSafe(): string {
  return (
    Math.random().toString(36).slice(2, 10) +
    Math.random().toString(36).slice(2, 10)
  );
}

function hashPayload(payload: unknown): string {
  const raw = typeof payload === "string" ? payload : JSON.stringify(payload ?? null);
  return createHash("sha256").update(raw).digest("hex");
}

/**
 * Wrap a route handler with idempotency.
 * Prisma model uses: @@unique([orgId, key], name: "orgId_key")
 */
export async function withIdempotency<T extends HandlerResult>(
  request: unknown,
  _reply: unknown,
  ctx: Ctx,
  handler: (args: { idempotencyKey: string }) => Promise<T>
): Promise<T> {
  const key = getIdempotencyKeyFromHeaders(request as any);

  // 1) Guard: fail if key already seen for this org
  const existing = await ctx.prisma.idempotencyEntry.findUnique({
    where: { orgId_key: { orgId: ctx.orgId, key } },
    select: { id: true },
  });
  if (existing) {
    throw conflict("idempotent_replay", "Request already processed");
  }

  // 2) Create the record
  await ctx.prisma.idempotencyEntry.create({
    data: {
      key,
      orgId: ctx.orgId,
      actorId: ctx.actorId ?? "system",
      requestHash: hashPayload(ctx.requestPayload ?? null),
      responseHash: hashPayload(null),
      statusCode: 202,
      // Store null initially; we'll update after handler runs
      responsePayload: null as any,
      resource: ctx.resource ?? null,
      resourceId: null,
    },
  });

  // 3) Run the handler
  const result = await handler({ idempotencyKey: key });

  // 4) Best-effort update (resource/resourceId)
  try {
    const responsePayload =
      result.body === undefined ? null : (result.body as any);

    await ctx.prisma.idempotencyEntry.update({
      where: { orgId_key: { orgId: ctx.orgId, key } },
      data: {
        resource: result.resource ?? ctx.resource ?? null,
        resourceId: result.resourceId ?? null,
        statusCode: result.statusCode,
        responsePayload,
        responseHash: hashPayload(result.body ?? null),
      },
    });
  } catch {
    // ignore
  }

  return result;
}



============================================================
FILE: C:\src\apgms-final\services\api-gateway\src\lib\masking.ts
============================================================
// services/api-gateway/src/lib/masking.ts

const SENSITIVE_KEY_PATTERNS = [
  "password",
  "token",
  "secret",
  "key",
  "authorization",
  "cookie",
  "session",
  "database_url",
  "databaseurl",
  "dsn",
];

const MASK = "***redacted***";

function shouldMaskKey(key: string | undefined): boolean {
  if (!key) return false;
  const normalised = key.toLowerCase();
  return SENSITIVE_KEY_PATTERNS.some((pattern) =>
    normalised.includes(pattern)
  );
}

function maskString(value: string): string {
  if (!value) {
    return MASK;
  }
  if (value.length <= 8) {
    return MASK;
  }
  const start = value.slice(0, 4);
  const end = value.slice(-2);
  return `${start}${"*".repeat(Math.max(3, value.length - 6))}${end}`;
}

function maskPotentialSecret(value: string, key?: string): string {
  if (shouldMaskKey(key)) {
    return MASK;
  }
  if (/password|secret|token|key/i.test(value)) {
    return MASK;
  }
  if (
    /^postgres(?:ql)?:\/\//i.test(value) ||
    /^mongodb:\/\//i.test(value)
  ) {
    return maskString(value);
  }
  if (value.length > 32) {
    return maskString(value);
  }
  return value;
}

function maskValue(value: unknown, key?: string): unknown {
  if (value == null) return value;

  if (typeof value === "string") {
    return shouldMaskKey(key) ? MASK : maskPotentialSecret(value, key);
  }

  if (typeof value === "number" || typeof value === "boolean") {
    return value;
  }

  if (value instanceof Date) {
    return value;
  }

  if (Array.isArray(value)) {
    return value.map((item) => maskValue(item, key));
  }

  if (typeof value === "object") {
    return maskObject(value as Record<string, unknown>);
  }

  return value;
}

export function maskObject<T>(input: T): T {
  if (input == null) {
    return input;
  }

  if (Array.isArray(input)) {
    return input.map((value) => maskValue(value)) as unknown as T;
  }

  if (typeof input !== "object") {
    return maskValue(input) as T;
  }

  const entries = Object.entries(
    input as Record<string, unknown>
  ).map(([key, value]) => [key, maskValue(value, key)]);

  return Object.fromEntries(entries) as T;
}

export function maskError(err: unknown): Record<string, unknown> {
  if (err instanceof Error) {
    const serialised: Record<string, unknown> = {
      name: err.name,
      message: err.message,
    };

    if (err.stack) {
      serialised.stack = err.stack.split("\n").slice(0, 5).join("\n");
    }

    if ((err as any).cause) {
      serialised.cause = maskValue((err as any).cause);
    }

    return maskObject(serialised);
  }

  if (typeof err === "object" && err !== null) {
    return maskObject(err as Record<string, unknown>);
  }

  return { error: maskValue(err) };
}



============================================================
FILE: C:\src\apgms-final\services\api-gateway\src\lib\mfa-store.ts
============================================================
import crypto from "node:crypto";
import type { InputJsonValue } from "@prisma/client/runtime/library.js";
import type { MfaCredential } from "@prisma/client";

import { prisma } from "../db.js";
import { sealObject, unsealObject, type EncryptionEnvelope } from "./encryption.js";

const TOTP_CONTEXT_PREFIX = "mfa:totp:";
const PASSKEY_CONTEXT_PREFIX = "mfa:passkey:";
interface TotpCredentialPayload {
  secret: string;
  recoveryCodes: Array<{
    hash: string;
    used: boolean;
  }>;
}

interface PasskeyCredentialPayload {
  publicKey: string;
  counter: number;
}

