      url: "/bank-lines",
      headers: {
        origin: "http://localhost:5173",
        "access-control-request-method": "POST",
        "access-control-request-headers": "Idempotency-Key, Content-Type",
      },
    });

    assert.notEqual(response.statusCode, 403);
    const allowed = String(response.headers["access-control-allow-headers"] ?? "");
    assert.ok(
      allowed.toLowerCase().includes("idempotency-key"),
      `expected ACAH to include Idempotency-Key, got ${allowed}`,
    );
    const expose = String(response.headers["access-control-expose-headers"] ?? "");
    assert.ok(
      expose.toLowerCase().includes("idempotent-replay"),
      `expected ACEH to include Idempotent-Replay, got ${expose}`,
    );
  });
});



============================================================
FILE: C:\src\apgms-final\services\api-gateway\test\security-headers.runtime.test.ts
============================================================
import Fastify from "fastify";
import helmet from "@fastify/helmet";
import cors from "@fastify/cors";
import { Buffer } from "node:buffer";

import { helmetConfigFor } from "../src/security-headers";
import type { AppConfig } from "../src/config";

const testConfig: AppConfig = {
  env: "test",
  databaseUrl: "postgres://test:test@localhost:5432/testdb",
  shadowDatabaseUrl: undefined,
  rateLimit: {
    max: 60,
    window: "1 minute",
  },
  security: {
    authFailureThreshold: 5,
    kmsKeysetLoaded: true,
    requireHttps: false,
    enableIsolation: false,
  },
  cors: {
    allowedOrigins: ["http://localhost:5173"],
  },
  taxEngineUrl: "http://tax-engine:8000",
  auth: {
    audience: "test-audience",
    issuer: "https://auth.localhost",
    devSecret: "local-dev-secret",
  },
  regulator: {
    accessCode: "test-access-code",
    jwtAudience: "urn:apgms:regulator",
    sessionTtlMinutes: 60,
  },
  encryption: {
    masterKey: Buffer.alloc(32),
  },
  webauthn: {
    rpId: "localhost",
    rpName: "APGMS Test",
    origin: "http://localhost:5173",
  },
  banking: {
    providerId: "mock",
    maxReadTransactions: 1000,
    maxWriteCents: 5_000_000,
  },
  redis: undefined,
  nats: undefined,
};

describe("security headers runtime", () => {
  it("registers helmet and cors and applies headers at runtime", async () => {
    const app = Fastify();

    await app.register(cors, {
      origin: testConfig.cors.allowedOrigins,
    });

    await app.register(helmet, helmetConfigFor(testConfig));

    app.get("/test", async () => ({ ok: true }));

    const res = await app.inject({
      method: "GET",
      url: "/test",
    });

    expect(res.statusCode).toBe(200);

    const headers = res.headers;
    // Basic helmet expectations
    expect(headers["x-dns-prefetch-control"]).toBe("off");
    expect(headers["x-frame-options"]).toBe("DENY");
    expect(headers["referrer-policy"]).toBe("no-referrer");
  });
});



============================================================
FILE: C:\src\apgms-final\services\api-gateway\test\security-headers.test.ts
============================================================
import { helmetConfigFor } from "../src/security-headers";
import type { AppConfig } from "../src/config";

describe("helmet configuration", () => {
  it("sets strict CSP and includes allowed origins for connect-src", () => {
    const cfg: AppConfig = {
      env: "test",
      databaseUrl: "postgres://localhost:5432/apgms",
      shadowDatabaseUrl: undefined,
      rateLimit: { max: 100, window: "1 minute" },
      security: {
        authFailureThreshold: 5,
        kmsKeysetLoaded: true,
        requireHttps: false,
      },
      cors: {
        allowedOrigins: ["http://localhost:5173", "https://example.com"],
      },
      taxEngineUrl: "https://tax.example.com",
      auth: {
        audience: "aud",
        issuer: "iss",
        devSecret: "devsecret",
      },
      regulator: {
        accessCode: "code",
        jwtAudience: "reg-aud",
        sessionTtlMinutes: 30,
      },
      encryption: { masterKey: Buffer.alloc(32, 1) },
      webauthn: {
        rpId: "localhost",
        rpName: "APGMS",
        origin: "http://localhost:3000",
      },
      banking: {
        providerId: "mock",
        maxReadTransactions: 100,
        maxWriteCents: 10_000,
      },
      redis: undefined,
      nats: undefined,
    };

    const helmetCfg = helmetConfigFor(cfg);

    expect(helmetCfg.frameguard).toEqual({ action: "deny" });
    expect(helmetCfg.referrerPolicy).toEqual({ policy: "no-referrer" });
    expect(helmetCfg.crossOriginResourcePolicy).toEqual({
      policy: "same-site",
    });

    const csp = helmetCfg.contentSecurityPolicy as any;
    const directives = csp?.directives as
      | {
          defaultSrc?: string[];
          baseUri?: string[];
          connectSrc?: string[];
          scriptSrc?: string[];
          styleSrc?: string[];
          imgSrc?: string[];
          objectSrc?: string[];
          frameAncestors?: string[];
        }
      | undefined;

    expect(directives).toBeDefined();
    expect(directives?.defaultSrc).toContain("'self'");
    expect(directives?.connectSrc).toEqual(["'self'", ...cfg.cors.allowedOrigins]);
    expect(directives?.frameAncestors).toEqual(["'none'"]);
    expect(directives?.objectSrc).toEqual(["'none'"]);
  });
});



============================================================
FILE: C:\src\apgms-final\services\api-gateway\tsconfig.json
============================================================
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022"],
    "rootDir": "src",
    "outDir": "dist",
    "declaration": true,
    "declarationMap": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "skipLibCheck": true,
    "strict": true,
    "sourceMap": true,
    "baseUrl": "./src",
    "paths": {
      "@apgms/shared": ["../../shared/dist/index"],
      "@apgms/shared/*": ["../../shared/dist/*"],
      "@apgms/domain-policy": ["../../packages/domain-policy/dist/index"]
    }
  },
  "include": ["src/**/*.ts", "src/**/*.d.ts"]
}



============================================================
FILE: C:\src\apgms-final\services\api-gateway\types\prisma.d.ts
============================================================
declare module "@prisma/client" {
  export class PrismaClient {
    constructor(...args: any[]);
    $disconnect(): Promise<void>;
    [key: string]: any;
  }

  export type Org = any;
  export type User = any;
  export type BankLine = any;
  export type OrgTombstone = any;
  export type AuditLog = any;
}




============================================================
FILE: C:\src\apgms-final\services\audit\src\index.ts
============================================================
console.log('audit service');



============================================================
FILE: C:\src\apgms-final\services\cdr\src\index.ts
============================================================
console.log('cdr service');



============================================================
FILE: C:\src\apgms-final\services\connectors\package.json
============================================================
{
  "name": "@apgms/connectors",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": "./dist/index.js"
  },
  "scripts": {
    "build": "tsc -p tsconfig.json"
  },
  "dependencies": {
    "@apgms/domain-policy": "workspace:*",
    "@apgms/shared": "workspace:*",
    "@prisma/client": "6.17.1"
  },
  "devDependencies": {
    "prisma": "6.17.1",
    "typescript": "^5.9.3"
  }
}



============================================================
FILE: C:\src\apgms-final\services\connectors\src\index.d.ts
============================================================
import type { PrismaClient } from "@prisma/client";
import { applyDesignatedAccountTransfer, generateDesignatedAccountReconciliationArtifact, type ApplyDesignatedTransferResult, type DesignatedReconciliationSummary } from "@apgms/domain-policy";
export type ConnectorContext = {
    prisma: PrismaClient;
    auditLogger?: (entry: {
        orgId: string;
        actorId: string;
        action: string;
        metadata?: Record<string, unknown> | null;
    }) => Promise<void> | void;
};
export type CaptureInput = {
    orgId: string;
    amount: number;
    actorId: string;
};
type ConnectorDependencies = {
    applyTransfer: typeof applyDesignatedAccountTransfer;
    generateArtifact: typeof generateDesignatedAccountReconciliationArtifact;
};
type CaptureResult = {
    transfer: ApplyDesignatedTransferResult;
    artifact: {
        artifactId: string;
        sha256: string;
        summary: DesignatedReconciliationSummary;
    };
};
export declare function capturePayroll(context: ConnectorContext, input: CaptureInput, dependencies?: ConnectorDependencies): Promise<CaptureResult>;
export declare function capturePos(context: ConnectorContext, input: CaptureInput, dependencies?: ConnectorDependencies): Promise<CaptureResult>;
export {};
//# sourceMappingURL=index.d.ts.map

// --- Reconciliation types & stub implementation ---
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export type DesignatedReconciliationSummary = {
  orgId: string;
  accountId: string;
  asOfDate: string;
  status: "BALANCED" | "MISMATCH" | "NOT_IMPLEMENTED";
  openingBalance?: number;
  closingBalance?: number;
  totalCredits?: number;
  totalDebits?: number;
  // Allow extra fields so callers can extend this without breaking
  [key: string]: any;
};

export type DesignatedAccountReconciliationArtifact = {
  artifactId: string;
  sha256: string;
  summary: DesignatedReconciliationSummary;
};

// Very loose ctx on purpose for now; connectors only cares that this
// function exists and returns { artifactId, sha256, summary }.
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export async function generateDesignatedAccountReconciliationArtifact(
  _ctx: any,
): Promise<DesignatedAccountReconciliationArtifact> {
  const artifactId = `recon-${Date.now().toString(36)}`;

  const summary: DesignatedReconciliationSummary = {
    orgId: "",
    accountId: "",
    asOfDate: new Date().toISOString(),
    status: "NOT_IMPLEMENTED",
  };

  // Stub hash â€“ you can replace with real sha256 later.
  const sha256 = `stub-${artifactId}`;

  return { artifactId, sha256, summary };
}


============================================================
FILE: C:\src\apgms-final\services\connectors\src\index.js
============================================================
import { applyDesignatedAccountTransfer, generateDesignatedAccountReconciliationArtifact, } from "@apgms/domain-policy";
const defaultDependencies = {
    applyTransfer: applyDesignatedAccountTransfer,
    generateArtifact: generateDesignatedAccountReconciliationArtifact,
};
const ACCOUNT_TYPE_BY_CAPTURE = {
    payroll: "PAYGW",
    pos: "GST",
};
const SOURCE_BY_CAPTURE = {
    payroll: "PAYROLL_CAPTURE",
    pos: "GST_CAPTURE",
};
function captureError(type, orgId) {
    return new Error(`designated_account_missing:${type}:${orgId}`);
}
async function resolveAccount(context, input, accountType) {
    const account = await context.prisma.designatedAccount.findFirst({
        where: { orgId: input.orgId, type: accountType },
    });
    if (!account) {
        throw captureError(accountType, input.orgId);
    }
    return account;
}
async function captureFunds(context, input, captureType, dependencies) {
    const accountType = ACCOUNT_TYPE_BY_CAPTURE[captureType];
    const source = SOURCE_BY_CAPTURE[captureType];
    const account = await resolveAccount(context, input, accountType);
    const transfer = await dependencies.applyTransfer({
        prisma: context.prisma,
        auditLogger: context.auditLogger,
    }, {
        orgId: input.orgId,
        accountId: account.id,
        amount: input.amount,
        source,
        actorId: input.actorId,
    });
    const artifact = await dependencies.generateArtifact(context, input.orgId, input.actorId);
    return {
        transfer,
        artifact: {
            artifactId: artifact.artifactId,
            sha256: artifact.sha256,
            summary: artifact.summary,
        },
    };
}
export async function capturePayroll(context, input, dependencies = defaultDependencies) {
    return captureFunds(context, input, "payroll", dependencies);
}
export async function capturePos(context, input, dependencies = defaultDependencies) {
    return captureFunds(context, input, "pos", dependencies);
}
//# sourceMappingURL=index.js.map


============================================================
FILE: C:\src\apgms-final\services\connectors\src\index.ts
============================================================
// services/connectors/src/index.ts

import {
  applyDesignatedAccountTransfer,
  generateDesignatedAccountReconciliationArtifact,
  type ApplyDesignatedTransferResult,
  type DesignatedReconciliationSummary,
} from "@apgms/domain-policy";

export type ConnectorContext = {
  prisma: any;
  auditLogger?: (entry: {
    orgId: string;
    actorId: string;
    action: string;
    metadata?: Record<string, unknown> | null;
  }) => Promise<void> | void;
};

// Alias used by api-gateway/app.ts
export type ConnectorRoutesDeps = ConnectorContext;

export type CaptureInput = {
  orgId: string;
  amount: number;
  actorId: string;
};

type ConnectorDependencies = {
  applyTransfer: typeof applyDesignatedAccountTransfer;
  generateArtifact: typeof generateDesignatedAccountReconciliationArtifact;
};

type CaptureResult = {
  transfer: ApplyDesignatedTransferResult;
  artifact: {
    artifactId: string;
    sha256: string;
    summary: DesignatedReconciliationSummary;
  };
};

const DEFAULT_DEPS: ConnectorDependencies = {
  applyTransfer: applyDesignatedAccountTransfer,
  generateArtifact: generateDesignatedAccountReconciliationArtifact,
};

async function runCapture(
  context: ConnectorContext,
  input: CaptureInput,
  source: string,
  deps: ConnectorDependencies,
): Promise<CaptureResult> {
  const { prisma, auditLogger } = context;
  const { orgId, amount, actorId } = input;

  const transfer = await deps.applyTransfer(
    {
      prisma: prisma as any,
      auditLogger: auditLogger
        ? {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            log: async (event: Record<string, any>) => {
              await auditLogger({
                orgId: String(event.orgId ?? orgId),
                actorId: String(event.actorId ?? actorId ?? "system"),
                action: String(event.type ?? "DESIGNATED_ACCOUNT_TRANSFER"),
                metadata: event,
              });
            },
          }
        : undefined,
    },
    {
      orgId,
      accountId: "payroll-buffer",
      amount,
      source,
      actorId,
    },
  );

  const artifact = await deps.generateArtifact({
    orgId,
    accountId: transfer.accountId,
    asOfDate: new Date().toISOString(),
  });

  return {
    transfer,
    artifact,
  };
}

export async function capturePayroll(
  context: ConnectorContext,
  input: CaptureInput,
  dependencies?: ConnectorDependencies,
): Promise<CaptureResult> {
  const deps = dependencies ?? DEFAULT_DEPS;
  return runCapture(context, input, "PAYROLL_CAPTURE", deps);
}

export async function capturePos(
  context: ConnectorContext,
  input: CaptureInput,
  dependencies?: ConnectorDependencies,
): Promise<CaptureResult> {
  const deps = dependencies ?? DEFAULT_DEPS;
  return runCapture(context, input, "GST_CAPTURE", deps);
}



============================================================
FILE: C:\src\apgms-final\services\connectors\test\connectors.spec.ts
============================================================
import assert from "node:assert/strict";
import { test } from "node:test";

import { capturePayroll, capturePos, type ConnectorContext, type CaptureInput } from "../src/index.js";

const baseInput: CaptureInput = { orgId: "org-1", amount: 1200, actorId: "actor-1" };

function buildContext(accountType: string): ConnectorContext {
  return {
    prisma: {
      designatedAccount: {
        async findFirst({ where }: any) {
          if (where.type !== accountType) return null;
          return { id: `${accountType.toLowerCase()}-acct`, orgId: where.orgId, type: where.type };
        },
      },
    } as any,
  };
}

test("capturePayroll uses PAYROLL_CAPTURE source and generates artifact", async () => {
  const context = buildContext("PAYGW");
  const transferCalls: Array<any> = [];
  const artifactCalls: Array<any> = [];

  const result = await capturePayroll(
    context,
    baseInput,
    {
      applyTransfer: async (_ctx, payload) => {
        transferCalls.push(payload);
        return {
          accountId: payload.accountId,
          resource: "bank-line",
          newBalance: payload.amount,
          transferId: "transfer-payroll",
          source: payload.source,
        } as any;
      },
      generateArtifact: async (_ctx, orgId, actorId) => {
        artifactCalls.push({ orgId, actorId });
        return {
          summary: { generatedAt: new Date().toISOString(), totals: { paygw: 1, gst: 0 }, movementsLast24h: [] },
          artifactId: "payroll-artifact",
          sha256: "deadbeef",
        } as any;
      },
    },
  );

  assert.equal(transferCalls.length, 1);
  assert.equal(transferCalls[0].source, "PAYROLL_CAPTURE");
  assert.equal(result.artifact.artifactId, "payroll-artifact");
  assert.equal(artifactCalls[0].actorId, baseInput.actorId);
});

test("capturePos uses GST_CAPTURE source and returns summary", async () => {
  const context = buildContext("GST");
  const result = await capturePos(
    context,
    { ...baseInput, amount: 2000 },
    {
      applyTransfer: async (_ctx, payload) => ({
        accountId: payload.accountId,
        newBalance: payload.amount,
        resource: "pos",
        transferId: "transfer-pos",
        source: payload.source,
      } as any),
      generateArtifact: async () => ({
        summary: { generatedAt: new Date().toISOString(), totals: { paygw: 0, gst: 1 }, movementsLast24h: [] },
        artifactId: "pos-artifact",
        sha256: "cafebabe",
      } as any),
    },
  );

  assert.equal(result.transfer.source, "GST_CAPTURE");
  assert.equal(result.artifact.sha256, "cafebabe");
});

test("capture fails when target account missing", async () => {
  await assert.rejects(
    () =>
      capturePayroll(
        { prisma: { designatedAccount: { async findFirst() { return null; } } } as any },
        baseInput,
        {
          applyTransfer: async () => ({} as any),
          generateArtifact: async () => ({} as any),
        },
      ),
    /designated_account_missing/,
  );
});



============================================================
FILE: C:\src\apgms-final\services\connectors\tsconfig.json
============================================================
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "rootDir": "src",
    "outDir": "dist",
    "declaration": true,
    "declarationMap": false,
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "baseUrl": ".",
    "composite": false,
    "allowJs": true,
    "paths": {
      "@apgms/shared": ["../../shared/dist/index"],
      "@apgms/shared/*": ["../../shared/dist/*"],
      "@apgms/domain-policy": ["../../packages/domain-policy/dist/index"],
      "@apgms/domain-policy/*": ["../../packages/domain-policy/dist/*"]
    }
  },
  "include": ["src"]
}



============================================================
FILE: C:\src\apgms-final\services\domain-policy\src\index.ts
============================================================
// services/domain-policy/src/index.ts

export * from "./designated-accounts";
export * from "./reconciliation";



============================================================
FILE: C:\src\apgms-final\services\domain-policy\src\reconciliation.ts
============================================================
// services/domain-policy/src/reconciliation.ts

import type { PrismaClient, AuditLogger } from "./designated-accounts";

/**
 * Extremely loose shape â€“ just enough to satisfy connectors
 * and allow api-gateway to build and run.
 */
export interface DesignatedReconciliationSummary {
  orgId: string;
  accountId: string;
  asOfDate: string;
  status: "NOT_IMPLEMENTED" | string;
  // Allow anything else for now
  [key: string]: any;
}

export interface GenerateDesignatedAccountReconciliationArgs {
  prisma: PrismaClient;
  auditLogger?: AuditLogger;
  orgId: string;
  accountId: string;
  asOfDate?: Date | string;
}

/**
 * Stub implementation â€“ returns a synthetic summary and does NOT
 * hit the database. This lets the rest of the stack compile while
 * you flesh out real policy later.
 */
export async function generateDesignatedAccountReconciliationArtifact(
  args: GenerateDesignatedAccountReconciliationArgs,
): Promise<DesignatedReconciliationSummary> {
  const { orgId, accountId, asOfDate } = args;

  return {
    orgId,
    accountId,
    asOfDate:
      typeof asOfDate === "string"
        ? asOfDate
        : (asOfDate ?? new Date()).toISOString(),
    status: "NOT_IMPLEMENTED",
  };
}



============================================================
FILE: C:\src\apgms-final\services\payments\src\index.ts
============================================================
console.log('payments service');



============================================================
FILE: C:\src\apgms-final\services\recon\src\index.ts
============================================================
console.log('recon service');



============================================================
FILE: C:\src\apgms-final\services\registries\src\index.ts
============================================================
console.log('registries service');



============================================================
FILE: C:\src\apgms-final\services\sbr\src\index.ts
============================================================
console.log('sbr service');



============================================================
FILE: C:\src\apgms-final\shared\au\abn.js
============================================================
const ABN_WEIGHTS = [10, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19];
const DIGIT_ONLY = /\d+/g;
export function normalizeAbn(input) {
    const digits = input.match(DIGIT_ONLY)?.join("") ?? "";
    return digits;
}
export function isValidABN(input) {
    const normalized = normalizeAbn(input);
    if (normalized.length !== 11) {
        return false;
    }
    if (!/^\d{11}$/.test(normalized)) {
        return false;
    }
    const digits = normalized
        .split("")
        .map((char, index) => {
        const value = Number(char);
        return index === 0 ? value - 1 : value;
    });
    const weightedSum = digits.reduce((sum, digit, index) => sum + digit * ABN_WEIGHTS[index], 0);
    return weightedSum % 89 === 0;
}



============================================================
FILE: C:\src\apgms-final\shared\au\abn.ts
============================================================
const ABN_WEIGHTS = [10, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19] as const;

const DIGIT_ONLY = /\d+/g;

export function normalizeAbn(input: string): string {
  const digits = input.match(DIGIT_ONLY)?.join("") ?? "";
  return digits;
}

export function isValidABN(input: string): boolean {
  const normalized = normalizeAbn(input);
  if (normalized.length !== 11) {
    return false;
  }

  if (!/^\d{11}$/.test(normalized)) {
    return false;
  }

  const digits = normalized
    .split("")
    .map((char, index) => {
      const value = Number(char);
      return index === 0 ? value - 1 : value;
    });

  const weightedSum = digits.reduce((sum, digit, index) => sum + digit * ABN_WEIGHTS[index], 0);
  return weightedSum % 89 === 0;
}



============================================================
FILE: C:\src\apgms-final\shared\au\tfn.js
============================================================
const TFN_8_WEIGHTS = [10, 7, 8, 4, 6, 3, 5, 2];
const TFN_9_WEIGHTS = [1, 4, 7, 10, 3, 5, 8, 11, 2];
const DIGIT_ONLY = /\d+/g;
export function normalizeTfn(input) {
    const digits = input.match(DIGIT_ONLY)?.join("") ?? "";
    return digits;
}
export function isValidTFN(input) {
    const normalized = normalizeTfn(input);
    if (!/^\d{8,9}$/.test(normalized)) {
        return false;
    }
    const weights = normalized.length === 8 ? TFN_8_WEIGHTS : TFN_9_WEIGHTS;
    const weightedSum = normalized
        .split("")
        .reduce((sum, digit, index) => sum + Number(digit) * weights[index], 0);
    return weightedSum % 11 === 0;
}



============================================================
FILE: C:\src\apgms-final\shared\au\tfn.ts
============================================================
const TFN_8_WEIGHTS = [10, 7, 8, 4, 6, 3, 5, 2] as const;
const TFN_9_WEIGHTS = [1, 4, 7, 10, 3, 5, 8, 11, 2] as const;

const DIGIT_ONLY = /\d+/g;

export function normalizeTfn(input: string): string {
  const digits = input.match(DIGIT_ONLY)?.join("") ?? "";
  return digits;
}

export function isValidTFN(input: string): boolean {
  const normalized = normalizeTfn(input);
  if (!/^\d{8,9}$/.test(normalized)) {
    return false;
  }

  const weights = normalized.length === 8 ? TFN_8_WEIGHTS : TFN_9_WEIGHTS;
  const weightedSum = normalized
    .split("")
    .reduce((sum, digit, index) => sum + Number(digit) * weights[index], 0);

  return weightedSum % 11 === 0;
}



============================================================
FILE: C:\src\apgms-final\shared\package.json
============================================================
{
  "name": "@apgms/shared",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": "./dist/index.js"
  },
  "scripts": {
    "clean-dist": "node ./scripts/clean-dist.js",
    "build": "pnpm run clean-dist && tsc -p tsconfig.json",
    "typecheck": "tsc --noEmit -p tsconfig.json",
    "generate": "node ./scripts/run-prisma-generate.mjs",
    "prebuild": "pnpm run generate"
  },
  "dependencies": {
    "@apgms/domain-policy": "workspace:*",
    "@prisma/client": "6.19.0",
    "otplib": "^12.0.1"
  },
  "devDependencies": {
    "prisma": "6.19.0",
    "typescript": "^5.6.3"
  }
}



============================================================
FILE: C:\src\apgms-final\shared\prisma\check-user.sql
============================================================
SELECT "id", "email", "password", "orgId"
FROM "User"
WHERE "email" = 'dev@example.com';



============================================================
FILE: C:\src\apgms-final\shared\prisma\manual-seed.sql
============================================================
UPDATE "User"
SET "password" = '$2b$10$NI.M.PpurVnibAhEyGmM8eZpMS6NsSL24dBTlEGqKUvcaeOtBHU9G'
WHERE "email" = 'dev@example.com';


============================================================
FILE: C:\src\apgms-final\shared\prisma\migrations\20251010133921_init\migration.sql
============================================================
-- CreateTable
CREATE TABLE "Org" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "Org_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "User" (
    "id" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "password" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "orgId" TEXT NOT NULL,

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "BankLine" (
    "id" TEXT NOT NULL,
    "orgId" TEXT NOT NULL,
    "date" TIMESTAMP(3) NOT NULL,
    "amount" DECIMAL(65,30) NOT NULL,
    "payee" TEXT NOT NULL,
    "desc" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "BankLine_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

-- AddForeignKey
ALTER TABLE "User" ADD CONSTRAINT "User_orgId_fkey" FOREIGN KEY ("orgId") REFERENCES "Org"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "BankLine" ADD CONSTRAINT "BankLine_orgId_fkey" FOREIGN KEY ("orgId") REFERENCES "Org"("id") ON DELETE CASCADE ON UPDATE CASCADE;



============================================================
FILE: C:\src\apgms-final\shared\prisma\migrations\20251015000000_create_audit_log\migration.sql
============================================================
-- Create AuditLog table (baseline for later alterations)
CREATE TABLE "AuditLog" (
  "id" TEXT NOT NULL,
  "orgId" TEXT NOT NULL,
  "actorId" TEXT NOT NULL,
  "action" TEXT NOT NULL,
  "metadata" JSONB,
  "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT "AuditLog_pkey" PRIMARY KEY ("id")
);

CREATE INDEX "AuditLog_orgId_createdAt_idx"
  ON "AuditLog"("orgId", "createdAt");

CREATE INDEX "AuditLog_actorId_createdAt_idx"
  ON "AuditLog"("actorId", "createdAt");



============================================================
FILE: C:\src\apgms-final\shared\prisma\migrations\20251020170901_sync_deleted_at\migration.sql
============================================================
-- AlterTable
ALTER TABLE "Org" ADD COLUMN     "deletedAt" TIMESTAMP(3);

-- CreateTable
CREATE TABLE "OrgTombstone" (
    "id" TEXT NOT NULL,
    "orgId" TEXT NOT NULL,
    "payload" JSONB NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "OrgTombstone_pkey" PRIMARY KEY ("id")
);

-- AddForeignKey
ALTER TABLE "OrgTombstone" ADD CONSTRAINT "OrgTombstone_orgId_fkey" FOREIGN KEY ("orgId") REFERENCES "Org"("id") ON DELETE CASCADE ON UPDATE CASCADE;



============================================================
FILE: C:\src\apgms-final\shared\prisma\migrations\20251021094315_bankline_idempotency\migration.sql
============================================================
-- CreateIndex
CREATE INDEX "BankLine_orgId_idx" ON "BankLine"("orgId");



============================================================
FILE: C:\src\apgms-final\shared\prisma\migrations\20251023202136_\migration.sql
============================================================
-- AlterTable
ALTER TABLE "AuditLog" ALTER COLUMN "id" DROP DEFAULT,
ALTER COLUMN "createdAt" SET DATA TYPE TIMESTAMP(3);



============================================================
FILE: C:\src\apgms-final\shared\prisma\migrations\20251101_add_payroll.sql
============================================================
-- Employee table
CREATE TABLE IF NOT EXISTS "Employee" (
  "id" TEXT PRIMARY KEY,
  "orgId" TEXT NOT NULL,
  "fullNameCiphertext" TEXT NOT NULL,
  "fullNameKid" TEXT NOT NULL,
  "tfnProvided" BOOLEAN NOT NULL DEFAULT FALSE,
  "employmentType" TEXT NOT NULL,
  "baseRate" NUMERIC(12,2) NOT NULL,
  "superRate" NUMERIC(5,2) NOT NULL,
  "status" TEXT NOT NULL DEFAULT 'active',
  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  CONSTRAINT "Employee_orgId_fkey" FOREIGN KEY ("orgId")
    REFERENCES "Org"("id") ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS "Employee_orgId_idx"
  ON "Employee"("orgId");

-- PayRun table
CREATE TABLE IF NOT EXISTS "PayRun" (
  "id" TEXT PRIMARY KEY,
  "orgId" TEXT NOT NULL,
  "periodStart" TIMESTAMPTZ NOT NULL,
  "periodEnd" TIMESTAMPTZ NOT NULL,
  "paymentDate" TIMESTAMPTZ NOT NULL,
  "status" TEXT NOT NULL DEFAULT 'draft',
  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  CONSTRAINT "PayRun_orgId_fkey" FOREIGN KEY ("orgId")
    REFERENCES "Org"("id") ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS "PayRun_orgId_idx"
  ON "PayRun"("orgId");

-- Payslip table
CREATE TABLE IF NOT EXISTS "Payslip" (
  "id" TEXT PRIMARY KEY,
  "payRunId" TEXT NOT NULL,
  "employeeId" TEXT NOT NULL,
  "grossPay" NUMERIC(12,2) NOT NULL,
  "paygWithheld" NUMERIC(12,2) NOT NULL,
  "superAccrued" NUMERIC(12,2) NOT NULL,
  "notesCiphertext" TEXT NOT NULL,
  "notesKid" TEXT NOT NULL,
  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  CONSTRAINT "Payslip_payRunId_fkey" FOREIGN KEY ("payRunId")
    REFERENCES "PayRun"("id") ON DELETE CASCADE,

  CONSTRAINT "Payslip_employeeId_fkey" FOREIGN KEY ("employeeId")
    REFERENCES "Employee"("id") ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS "Payslip_payRunId_idx"
  ON "Payslip"("payRunId");

CREATE INDEX IF NOT EXISTS "Payslip_employeeId_idx"
  ON "Payslip"("employeeId");



============================================================
FILE: C:\src\apgms-final\shared\prisma\migrations\20251101090000_encrypt_bankline\migration.sql
============================================================
CREATE EXTENSION IF NOT EXISTS "pgcrypto";
ALTER TABLE "BankLine" ADD COLUMN "payeeCiphertext" TEXT;
ALTER TABLE "BankLine" ADD COLUMN "payeeKid" TEXT;
ALTER TABLE "BankLine" ADD COLUMN "descCiphertext" TEXT;
ALTER TABLE "BankLine" ADD COLUMN "descKid" TEXT;

UPDATE "BankLine"
SET
  "payeeCiphertext" = COALESCE("payee", ''),
  "payeeKid" = 'legacy',
  "descCiphertext" = COALESCE("desc", ''),
  "descKid" = 'legacy';

ALTER TABLE "BankLine" DROP COLUMN "payee";
ALTER TABLE "BankLine" DROP COLUMN "desc";

ALTER TABLE "BankLine"
  ALTER COLUMN "payeeCiphertext" SET NOT NULL,
  ALTER COLUMN "payeeKid" SET NOT NULL,
  ALTER COLUMN "descCiphertext" SET NOT NULL,
  ALTER COLUMN "descKid" SET NOT NULL;

DO $$
BEGIN
  CREATE TABLE "AuditLog" (
    "id" TEXT NOT NULL DEFAULT gen_random_uuid(),
    "orgId" TEXT NOT NULL,
    "actorId" TEXT NOT NULL,
    "action" TEXT NOT NULL,
    "metadata" JSONB,
    "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    CONSTRAINT "AuditLog_pkey" PRIMARY KEY ("id")
  );
EXCEPTION
  WHEN duplicate_table THEN NULL;
END $$;

CREATE INDEX IF NOT EXISTS "AuditLog_orgId_createdAt_idx" ON "AuditLog" ("orgId", "createdAt");
CREATE INDEX IF NOT EXISTS "AuditLog_actorId_createdAt_idx" ON "AuditLog" ("actorId", "createdAt");



============================================================
FILE: C:\src\apgms-final\shared\prisma\migrations\20251102090000_add_evidence_payload\migration.sql
============================================================
-- Ensure the EvidenceArtifact table exists before adding payload metadata
CREATE TABLE IF NOT EXISTS "EvidenceArtifact" (
  "id" UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  "orgId" UUID NOT NULL,
  "kind" TEXT NOT NULL,
  "wormUri" TEXT NOT NULL,
  "sha256" TEXT NOT NULL,
  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Add payload JSON column to store captured evidence snapshots
ALTER TABLE "EvidenceArtifact"
ADD COLUMN "payload" JSONB;



============================================================
FILE: C:\src\apgms-final\shared\prisma\migrations\20251102090000_phase2_alerts_bascycle\migration.sql
============================================================
-- Phase 2: Alerts, BAS cycles, and security columns

ALTER TABLE "User"
  ADD COLUMN "role" TEXT NOT NULL DEFAULT 'admin',
  ADD COLUMN "mfaEnabled" BOOLEAN NOT NULL DEFAULT false;

CREATE TABLE "Alert" (
  "id" TEXT NOT NULL PRIMARY KEY,
  "orgId" TEXT NOT NULL,
  "type" TEXT NOT NULL,
  "severity" TEXT NOT NULL,
  "message" TEXT NOT NULL,
  "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "resolvedAt" TIMESTAMP(3),
  "resolutionNote" TEXT,
  CONSTRAINT "Alert_orgId_fkey" FOREIGN KEY ("orgId") REFERENCES "Org"("id") ON DELETE CASCADE ON UPDATE CASCADE
);

CREATE INDEX "Alert_orgId_createdAt_idx" ON "Alert"("orgId", "createdAt");
CREATE INDEX "Alert_orgId_resolvedAt_idx" ON "Alert"("orgId", "resolvedAt");

CREATE TABLE "BasCycle" (
  "id" TEXT NOT NULL PRIMARY KEY,
  "orgId" TEXT NOT NULL,
  "periodStart" TIMESTAMP(3) NOT NULL,
  "periodEnd" TIMESTAMP(3) NOT NULL,
  "paygwRequired" DECIMAL NOT NULL,
  "paygwSecured" DECIMAL NOT NULL,
  "gstRequired" DECIMAL NOT NULL,
  "gstSecured" DECIMAL NOT NULL,
  "overallStatus" TEXT NOT NULL,
  "lodgedAt" TIMESTAMP(3),
  CONSTRAINT "BasCycle_orgId_fkey" FOREIGN KEY ("orgId") REFERENCES "Org"("id") ON DELETE CASCADE ON UPDATE CASCADE
);

CREATE INDEX "BasCycle_orgId_periodStart_periodEnd_idx" ON "BasCycle"("orgId", "periodStart", "periodEnd");
CREATE INDEX "BasCycle_orgId_lodgedAt_idx" ON "BasCycle"("orgId", "lodgedAt");



============================================================
FILE: C:\src\apgms-final\shared\prisma\migrations\20251102103000_phase3_designated_accounts\migration.sql
============================================================
-- Phase 3: Designated holding accounts and transfers

CREATE TABLE "DesignatedAccount" (
  "id" TEXT PRIMARY KEY,
  "orgId" TEXT NOT NULL,
  "type" TEXT NOT NULL,
  "balance" DECIMAL NOT NULL DEFAULT 0,
  "updatedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT "DesignatedAccount_orgId_fkey" FOREIGN KEY ("orgId") REFERENCES "Org"("id") ON DELETE CASCADE ON UPDATE CASCADE
);

CREATE INDEX "DesignatedAccount_orgId_type_idx"
  ON "DesignatedAccount"("orgId","type");

CREATE TABLE "DesignatedTransfer" (
  "id" TEXT PRIMARY KEY,
  "orgId" TEXT NOT NULL,
  "accountId" TEXT NOT NULL,
  "amount" DECIMAL NOT NULL,
  "source" TEXT NOT NULL,
  "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT "DesignatedTransfer_orgId_fkey" FOREIGN KEY ("orgId") REFERENCES "Org"("id") ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT "DesignatedTransfer_accountId_fkey" FOREIGN KEY ("accountId") REFERENCES "DesignatedAccount"("id") ON DELETE CASCADE ON UPDATE CASCADE
);

CREATE INDEX "DesignatedTransfer_orgId_accountId_createdAt_idx"
  ON "DesignatedTransfer"("orgId","accountId","createdAt");



============================================================
FILE: C:\src\apgms-final\shared\prisma\migrations\20251102120000_phase4_payment_plan\migration.sql
============================================================
-- Phase 4: Payment plan requests

CREATE TABLE "PaymentPlanRequest" (
  "id" TEXT PRIMARY KEY,
  "orgId" TEXT NOT NULL REFERENCES "Org"("id") ON DELETE CASCADE ON UPDATE CASCADE,
  "basCycleId" TEXT NOT NULL REFERENCES "BasCycle"("id") ON DELETE CASCADE ON UPDATE CASCADE,
  "requestedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "reason" TEXT NOT NULL,
  "status" TEXT NOT NULL DEFAULT 'SUBMITTED',
  "detailsJson" JSONB NOT NULL,
  "resolvedAt" TIMESTAMP(3)
);

CREATE INDEX "PaymentPlanRequest_orgId_basCycleId_idx"
  ON "PaymentPlanRequest"("orgId","basCycleId");

CREATE INDEX "PaymentPlanRequest_orgId_status_idx"
  ON "PaymentPlanRequest"("orgId","status");



============================================================
FILE: C:\src\apgms-final\shared\prisma\migrations\20251103090000_phase7_regulator_portal\migration.sql
============================================================
-- Phase 7: regulator workspace foundation

ALTER TABLE "AuditLog"
  ADD COLUMN "hash" TEXT NOT NULL DEFAULT 'legacy',
  ADD COLUMN "prevHash" TEXT;

CREATE TABLE "RegulatorSession" (
  "id" TEXT PRIMARY KEY,
  "orgId" TEXT NOT NULL,
  "tokenHash" TEXT NOT NULL,
  "issuedAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  "expiresAt" TIMESTAMP WITH TIME ZONE NOT NULL,
  "lastUsedAt" TIMESTAMP WITH TIME ZONE,
  "revokedAt" TIMESTAMP WITH TIME ZONE,
  "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  CONSTRAINT "RegulatorSession_orgId_fkey" FOREIGN KEY ("orgId") REFERENCES "Org"("id") ON DELETE CASCADE
);

CREATE INDEX "RegulatorSession_orgId_createdAt_idx"
  ON "RegulatorSession" ("orgId", "createdAt");

CREATE INDEX "RegulatorSession_orgId_expiresAt_idx"
  ON "RegulatorSession" ("orgId", "expiresAt");

CREATE TABLE "MonitoringSnapshot" (
  "id" TEXT PRIMARY KEY,
  "orgId" TEXT NOT NULL,
  "type" TEXT NOT NULL,
  "payload" JSONB NOT NULL,
  "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  CONSTRAINT "MonitoringSnapshot_orgId_fkey" FOREIGN KEY ("orgId") REFERENCES "Org"("id") ON DELETE CASCADE
);

CREATE INDEX "MonitoringSnapshot_orgId_createdAt_idx"
  ON "MonitoringSnapshot" ("orgId", "createdAt");

CREATE INDEX "MonitoringSnapshot_orgId_type_createdAt_idx"
  ON "MonitoringSnapshot" ("orgId", "type", "createdAt");



============================================================
FILE: C:\src\apgms-final\shared\prisma\migrations\20251104090000_mfa_credentials\migration.sql
============================================================
-- CreateTable
CREATE TABLE "MfaCredential" (
    "id" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "type" TEXT NOT NULL,
    "label" TEXT,
    "data" JSONB NOT NULL,
    "credentialId" TEXT,
    "primary" BOOLEAN NOT NULL DEFAULT FALSE,
    "status" TEXT NOT NULL DEFAULT 'active',
    "createdAt" TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "lastUsedAt" TIMESTAMPTZ,
    CONSTRAINT "MfaCredential_pkey" PRIMARY KEY ("id"),
    CONSTRAINT "MfaCredential_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE
);

-- Indexes
CREATE UNIQUE INDEX "MfaCredential_credentialId_key" ON "MfaCredential"("credentialId") WHERE "credentialId" IS NOT NULL;
CREATE INDEX "MfaCredential_userId_type_status_idx" ON "MfaCredential"("userId", "type", "status");



============================================================
FILE: C:\src\apgms-final\shared\prisma\migrations\20251104100000_idempotency_keys\migration.sql
============================================================
-- CreateTable
CREATE TABLE "IdempotencyEntry" (
    "id" TEXT NOT NULL,
    "orgId" TEXT NOT NULL,
    "actorId" TEXT NOT NULL,
    "key" TEXT NOT NULL,
    "requestHash" TEXT NOT NULL,
    "responseHash" TEXT NOT NULL,
    "statusCode" INTEGER NOT NULL,
    "responsePayload" JSONB,
    "resource" TEXT,
    "resourceId" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "IdempotencyEntry_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "IdempotencyEntry_orgId_key_key" ON "IdempotencyEntry"("orgId", "key");



============================================================
FILE: C:\src\apgms-final\shared\prisma\migrations\20251108120000_designated_contributions\migration.sql
============================================================
CREATE TABLE "PayrollContribution" (
  "id" TEXT PRIMARY KEY NOT NULL,
  "orgId" TEXT NOT NULL REFERENCES "Org"("id") ON DELETE CASCADE,
  "amount" NUMERIC(20,2) NOT NULL,
  "source" TEXT NOT NULL,
  "payload" JSONB,
  "actorId" TEXT,
  "idempotencyKey" TEXT,
  "appliedAt" TIMESTAMP,
  "transferId" TEXT,
  "createdAt" TIMESTAMP NOT NULL DEFAULT NOW()
);
CREATE UNIQUE INDEX "PayrollContribution_orgId_idempotencyKey_key" ON "PayrollContribution" ("orgId", "idempotencyKey");
CREATE INDEX "PayrollContribution_orgId_appliedAt_idx" ON "PayrollContribution" ("orgId", "appliedAt");

CREATE TABLE "PosTransaction" (
  "id" TEXT PRIMARY KEY NOT NULL,
  "orgId" TEXT NOT NULL REFERENCES "Org"("id") ON DELETE CASCADE,
  "amount" NUMERIC(20,2) NOT NULL,
  "source" TEXT NOT NULL,
  "payload" JSONB,
  "actorId" TEXT,
  "idempotencyKey" TEXT,
  "appliedAt" TIMESTAMP,
  "transferId" TEXT,
  "createdAt" TIMESTAMP NOT NULL DEFAULT NOW()
);
CREATE UNIQUE INDEX "PosTransaction_orgId_idempotencyKey_key" ON "PosTransaction" ("orgId", "idempotencyKey");
CREATE INDEX "PosTransaction_orgId_appliedAt_idx" ON "PosTransaction" ("orgId", "appliedAt");



============================================================
FILE: C:\src\apgms-final\shared\prisma\migrations\20251109120000_lock_desig_acc\migration.sql
============================================================
ALTER TABLE "DesignatedAccount" ADD COLUMN "locked" BOOLEAN NOT NULL DEFAULT FALSE;
ALTER TABLE "DesignatedAccount" ADD COLUMN "lockedAt" TIMESTAMP;



============================================================
FILE: C:\src\apgms-final\shared\prisma\schema.prisma
============================================================
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

// =========================
// Enums
// =========================

enum AccountType {
  ASSET
  LIABILITY
  INCOME
  EXPENSE
  EQUITY
}

enum AccountSubtype {
  BANK
  PAYGW_BUFFER
  GST_BUFFER
  CLEARING
  SUSPENSE
  RECEIVABLE
  PAYABLE
}

enum JournalType {
  PAYROLL_HOLD
  POS_GST
  BANK_SETTLEMENT
  BAS_RELEASE
  ADJUSTMENT
  REVERSAL
}

enum AlertStatus {
  OPEN
  ACKED
  CLOSED
}

// =========================
// Payroll domain
// =========================
//
// IDs are String to align with current Org/User tables.
// baseRate, superRate etc. use Decimal with @db.Decimal now.
// =========================

model Employee {
  id    String @id
  orgId String
  org   Org    @relation(fields: [orgId], references: [id], onDelete: Cascade)

  fullNameCiphertext String
  fullNameKid        String
  tfnProvided        Boolean @default(false)

  // "full_time" | "part_time" | "contractor" | etc.
  employmentType String

  // hourly rate or derived salary rate
  baseRate Decimal @default("0") @db.Decimal(12, 2)

  // superannuation %, e.g. 11.00
  superRate Decimal @default("11.0") @db.Decimal(5, 2)

  status    String   @default("active")
  createdAt DateTime @default(now())

  payslips Payslip[]

  @@index([orgId], map: "Employee_orgId_idx")
}

model PayRun {
  id    String @id
  orgId String
  org   Org    @relation(fields: [orgId], references: [id], onDelete: Cascade)

  periodStart DateTime
  periodEnd   DateTime
  paymentDate DateTime

  // "draft" | "committed"
  status String @default("draft")

  createdAt DateTime @default(now())

  payslips Payslip[]

  @@index([orgId], map: "PayRun_orgId_idx")
}

model Payslip {
  id String @id

  payRunId String
  payRun   PayRun @relation(fields: [payRunId], references: [id], onDelete: Cascade)

  employeeId String
  employee   Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  grossPay     Decimal @db.Decimal(12, 2)
  paygWithheld Decimal @db.Decimal(12, 2)
  superAccrued Decimal @db.Decimal(12, 2)

  notesCiphertext String
  notesKid        String

  createdAt DateTime @default(now())

  @@index([payRunId], map: "Payslip_payRunId_idx")
  @@index([employeeId], map: "Payslip_employeeId_idx")
}

// =========================
/**
 * Core ledger / compliance
 */
// =========================
//
// Production ledger covering:
// - GST collection
// - PAYGW / STSL accrual
// - BAS evidence trails
// =========================

model Organization {
  id        String   @id @default(uuid()) @db.Uuid
  name      String
  createdAt DateTime @default(now())

  accounts Account[]
  journals Journal[]
}

model Account {
  id        String          @id @default(uuid()) @db.Uuid
  orgId     String          @db.Uuid
  code      String
  name      String
  type      AccountType
  subtype   AccountSubtype?
  currency  String          @default("AUD")
  isActive  Boolean         @default(true)
  createdAt DateTime        @default(now())

  postings Posting[]
  balances BalanceSnapshot[]

  organization Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@unique([orgId, code])
  @@index([orgId, subtype])
}

model Journal {
  id          String      @id @default(uuid()) @db.Uuid
  orgId       String      @db.Uuid
  seq         BigInt      @db.BigInt
  type        JournalType
  eventId     String
  dedupeId    String
  occurredAt  DateTime
  recordedAt  DateTime    @default(now())
  source      String
  description String?
  hash        String?
  prevHash    String?

  postings     Posting[]
  organization Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@unique([orgId, dedupeId])
  @@unique([orgId, seq])
  @@index([orgId, occurredAt])
}

model Posting {
  id          String  @id @default(uuid()) @db.Uuid
  orgId       String  @db.Uuid
  journalId   String  @db.Uuid
  accountId   String  @db.Uuid
  amountCents BigInt  @db.BigInt
  memo        String?

  journal Journal @relation(fields: [journalId], references: [id], onDelete: Cascade)
  account Account @relation(fields: [accountId], references: [id], onDelete: Cascade)

  @@index([orgId, accountId])
  @@index([orgId, journalId])
}

model BalanceSnapshot {
  id           String   @id @default(uuid()) @db.Uuid
  orgId        String   @db.Uuid
  accountId    String   @db.Uuid
  asOfSeq      BigInt   @db.BigInt
  balanceCents BigInt   @db.BigInt
  createdAt    DateTime @default(now())

  account Account @relation(fields: [accountId], references: [id], onDelete: Cascade)

  @@unique([orgId, accountId, asOfSeq])
}

model EventEnvelope {
  id            String    @id
  orgId         String    @db.Uuid
  eventType     String
  key           String
  ts            DateTime
  schemaVersion String
  source        String
  traceId       String?
  payload       Json
  processedAt   DateTime?
  status        String    @default("processed")
  error         String?

  @@index([orgId, ts])
}

model BankTransaction {
  id               String   @id @default(uuid()) @db.Uuid
  orgId            String   @db.Uuid
  extRef           String?
  accountName      String
  txDate           DateTime
  amountCents      BigInt   @db.BigInt
  description      String?
  matchedJournalId String?

  @@index([orgId, txDate])
}

model GstTransaction {
  id          String   @id @default(uuid()) @db.Uuid
  orgId       String   @db.Uuid
  sourceRef   String?
  txDate      DateTime
  netCents    BigInt   @db.BigInt
  gstCents    BigInt   @db.BigInt
  code        String
  basPeriodId String?

  @@index([orgId, txDate])
}

model PayrollItem {
  id             String   @id @default(uuid()) @db.Uuid
  orgId          String   @db.Uuid
  employeeId     String
  payPeriodStart DateTime
  payPeriodEnd   DateTime
  grossCents     BigInt   @db.BigInt
  paygwCents     BigInt   @db.BigInt
  stslCents      BigInt   @db.BigInt
  journalId      String?

  @@index([orgId, employeeId])
}

model BasPeriod {
  id         String    @id @default(uuid()) @db.Uuid
  orgId      String    @db.Uuid
  start      DateTime
  end        DateTime
  status     String    @default("open")
  readyAt    DateTime?
  releasedAt DateTime?
  lodgedAt   DateTime?
  evidenceId String?

  @@unique([orgId, start, end])
}

model ReconciliationAlert {
  id         String      @id @default(uuid()) @db.Uuid
  orgId      String      @db.Uuid
  kind       String
  openedAt   DateTime    @default(now())
  status     AlertStatus @default(OPEN)
  details    Json
  resolvedAt DateTime?

  @@index([orgId, status])
}

model EvidenceArtifact {
  id        String   @id @default(uuid()) @db.Uuid
  orgId     String   @db.Uuid
  kind      String
  wormUri   String
  sha256    String
  payload   Json?
  createdAt DateTime @default(now())

  @@index([orgId, kind])
}

// =========================
// Legacy models still used by the live Fastify API
// =========================
//
// These match what the running api-gateway expects today
// (auth/login, /users, /bank-lines, /admin/export/:orgId).
// =========================

model IdempotencyEntry {
  id              String   @id @default(cuid())
  orgId           String
  actorId         String
  key             String
  requestHash     String
  responseHash    String
  statusCode      Int
  responsePayload Json?
  resource        String?
  resourceId      String?
  createdAt       DateTime @default(now())

  @@unique([orgId, key])
}

model Org {
  id        String    @id @default(cuid())
  name      String
  createdAt DateTime  @default(now())
  deletedAt DateTime?

  users                  User[]
  oneWayAccounts         OneWayAccount[]
  discrepancyAlerts      DiscrepancyAlert[]
  integrationObligations IntegrationObligation[]
  integrationEvents      IntegrationEvent[]
  basLodgments           BasLodgment[]
  transferInstructions   TransferInstruction[]
  governmentSubmissions  GovernmentSubmission[]
  riskEvents             RiskEvent[]
  lines                  BankLine[]
  tombstones             OrgTombstone[]
  alerts                 Alert[]
  basCycles              BasCycle[]
  designatedAccounts     DesignatedAccount[]
  designatedTransfers    DesignatedTransfer[]
  paymentPlanRequests    PaymentPlanRequest[]
  regulatorSessions      RegulatorSession[]
  monitoringSnapshots    MonitoringSnapshot[]

  // payroll backrefs
  employees Employee[]
  payRuns   PayRun[]

  // contributions / POS backrefs
  payrollContributions PayrollContribution[] @relation("OrgPayrollContributions")
  posTransactions      PosTransaction[]      @relation("OrgPosTransactions")
}

model User {
  id         String   @id @default(cuid())
  email      String   @unique
  password   String
  createdAt  DateTime @default(now())
  role       String   @default("admin")
  mfaEnabled Boolean  @default(false)

  org            Org             @relation(fields: [orgId], references: [id], onDelete: Cascade)
  orgId          String
  mfaCredentials MfaCredential[]
}

model MfaCredential {
  id           String    @id @default(cuid())
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId       String
  type         String
  label        String?
  data         Json
  credentialId String?   @unique
  primary      Boolean   @default(false)
  status       String    @default("active")
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  lastUsedAt   DateTime?

  @@index([userId, type, status])
}

model Alert {
  id             String    @id @default(cuid())
  org            Org       @relation(fields: [orgId], references: [id], onDelete: Cascade)
  orgId          String
  type           String
  severity       String
  message        String
  createdAt      DateTime  @default(now())
  resolvedAt     DateTime?
  resolutionNote String?

  @@index([orgId, createdAt])
  @@index([orgId, resolvedAt])
}

model BasCycle {
  id                  String               @id @default(cuid())
  org                 Org                  @relation(fields: [orgId], references: [id], onDelete: Cascade)
  orgId               String
  periodStart         DateTime
  periodEnd           DateTime
  paygwRequired       Decimal
  paygwSecured        Decimal
  gstRequired         Decimal
  gstSecured          Decimal
  overallStatus       String
  lodgedAt            DateTime?
  paymentPlanRequests PaymentPlanRequest[]

  @@index([orgId, periodStart, periodEnd])
  @@index([orgId, lodgedAt])
}

model DesignatedAccount {
  id        String    @id @default(cuid())
  org       Org       @relation(fields: [orgId], references: [id], onDelete: Cascade)
  orgId     String
  type      String
  balance   Decimal   @default(0)
  locked    Boolean   @default(false)
  lockedAt  DateTime?
  updatedAt DateTime  @default(now())

  transfers DesignatedTransfer[]

  @@index([orgId, type])
}

model DesignatedTransfer {
  id        String            @id @default(cuid())
  org       Org               @relation(fields: [orgId], references: [id], onDelete: Cascade)
  orgId     String
  account   DesignatedAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId String
  amount    Decimal
  source    String
  createdAt DateTime          @default(now())

  @@index([orgId, accountId, createdAt])
}

model PaymentPlanRequest {
  id          String    @id @default(cuid())
  org         Org       @relation(fields: [orgId], references: [id], onDelete: Cascade)
  orgId       String
  basCycle    BasCycle  @relation(fields: [basCycleId], references: [id], onDelete: Cascade)
  basCycleId  String
  requestedAt DateTime  @default(now())
  reason      String
  status      String    @default("SUBMITTED")
  detailsJson Json
  resolvedAt  DateTime?

  @@index([orgId, basCycleId])
  @@index([orgId, status])
}

model BankLine {
  id              String   @id @default(cuid())
  org             Org      @relation(fields: [orgId], references: [id], onDelete: Cascade)
  orgId           String
  date            DateTime
  amount          Decimal
  payeeCiphertext String
  payeeKid        String
  descCiphertext  String
  descKid         String
  createdAt       DateTime @default(now())
  idempotencyKey  String?

  @@unique([orgId, idempotencyKey])
  @@index([orgId])
}

model OrgTombstone {
  id        String   @id @default(cuid())
  org       Org      @relation(fields: [orgId], references: [id], onDelete: Cascade)
  orgId     String
  payload   Json
  createdAt DateTime @default(now())
}

model AuditLog {
  id        String   @id @default(cuid())
  orgId     String
  actorId   String
  action    String
  metadata  Json?
  createdAt DateTime @default(now())
  hash      String
  prevHash  String?

  @@index([orgId, createdAt])
  @@index([actorId, createdAt])
}

model RegulatorSession {
  id         String    @id @default(cuid())
  org        Org       @relation(fields: [orgId], references: [id], onDelete: Cascade)
  orgId      String
  tokenHash  String
  issuedAt   DateTime  @default(now())
  expiresAt  DateTime
  lastUsedAt DateTime?
  revokedAt  DateTime?
  createdAt  DateTime  @default(now())

  @@index([orgId, createdAt])
  @@index([orgId, expiresAt])
}

model MonitoringSnapshot {
  id        String   @id @default(cuid())
  org       Org      @relation(fields: [orgId], references: [id], onDelete: Cascade)
  orgId     String
  type      String
  payload   Json
  createdAt DateTime @default(now())

  @@index([orgId, createdAt])
  @@index([orgId, type, createdAt])
}

model OneWayAccount {
  id            String    @id @default(cuid())
  orgId         String
  org           Org       @relation(fields: [orgId], references: [id], onDelete: Cascade)
  taxType       String
  balance       Decimal   @default("0") @db.Decimal(24, 8)
  lastDepositAt DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@unique([orgId, taxType])
  @@index([taxType])
  @@index([orgId])
}

model PayrollContribution {
  id    String @id @default(cuid())
  orgId String

  org Org @relation("OrgPayrollContributions", fields: [orgId], references: [id], onDelete: Cascade)

  amount         Decimal   @db.Decimal(20, 2)
  source         String
  payload        Json?
  actorId        String?
  idempotencyKey String?
  appliedAt      DateTime?
  transferId     String?
  createdAt      DateTime  @default(now())

  @@unique([orgId, idempotencyKey])
  @@index([orgId, appliedAt])
}

model PosTransaction {
  id    String @id @default(cuid())
  orgId String

  org Org @relation("OrgPosTransactions", fields: [orgId], references: [id], onDelete: Cascade)

  amount         Decimal   @db.Decimal(20, 2)
  source         String
  payload        Json?
  actorId        String?
  idempotencyKey String?
  appliedAt      DateTime?
  transferId     String?
  createdAt      DateTime  @default(now())

  @@unique([orgId, idempotencyKey])
  @@index([orgId, appliedAt])
}

model DiscrepancyAlert {
  id             String   @id @default(cuid())
  orgId          String
  org            Org      @relation(fields: [orgId], references: [id], onDelete: Cascade)
  taxType        String
  eventId        String
  expectedAmount Decimal  @db.Decimal(24, 8)
  actualAmount   Decimal  @db.Decimal(24, 8)
  reason         String
  resolved       Boolean  @default(false)
  createdAt      DateTime @default(now())

  @@index([orgId, taxType])
  @@index([eventId])
}

model IntegrationObligation {
  id        String   @id @default(cuid())
  orgId     String
  org       Org      @relation(fields: [orgId], references: [id], onDelete: Cascade)
  taxType   String
  eventId   String
  amount    Decimal  @db.Decimal(24, 8)
  status    String   @default("pending")
  createdAt DateTime @default(now())

  @@index([orgId, taxType])
  @@index([eventId])
}

model BasLodgment {
  id          String    @id @default(cuid())
  orgId       String
  org         Org       @relation(fields: [orgId], references: [id], onDelete: Cascade)
  initiatedBy String?
  taxTypes    String[]
  result      Json?
  status      String    @default("queued")
  createdAt   DateTime  @default(now())
  processedAt DateTime?

  @@index([orgId, status])
}

model TransferInstruction {
  id          String   @id @default(cuid())
  orgId       String
  org         Org      @relation(fields: [orgId], references: [id], onDelete: Cascade)
  taxType     String
  amount      Decimal  @db.Decimal(24, 8)
  basId       String
  status      String   @default("queued")
  destination String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([orgId, taxType])
  @@index([basId])
}

model GovernmentSubmission {
  id        String   @id @default(cuid())
  orgId     String
  org       Org      @relation(fields: [orgId], references: [id], onDelete: Cascade)
  method    String
  payload   Json
  response  Json?
  status    String   @default("pending")
  createdAt DateTime @default(now())

  @@index([orgId, status])
}

model RiskEvent {
  id          String    @id @default(cuid())
  orgId       String
  org         Org       @relation(fields: [orgId], references: [id], onDelete: Cascade)
  taxType     String
  severity    String
  score       Float
  description String
  resolved    Boolean   @default(false)
  createdAt   DateTime  @default(now())
  resolvedAt  DateTime?

  @@index([orgId, severity, resolved])
}

model IntegrationEvent {
  id          String    @id @default(cuid())
  orgId       String
  org         Org       @relation(fields: [orgId], references: [id], onDelete: Cascade)
  taxType     String
  source      String
  amount      Decimal   @db.Decimal(24, 8)
  metadata    Json?
  status      String    @default("pending")
  createdAt   DateTime  @default(now())
  processedAt DateTime?

  @@index([orgId, taxType])
  @@index([taxType])
}



============================================================
FILE: C:\src\apgms-final\shared\prisma\seed.ts
============================================================
import { PrismaClient } from "@prisma/client";
import bcrypt from "bcryptjs";

const prisma = new PrismaClient();

async function main() {
  const hash = bcrypt.hashSync("admin123", 10);

  await prisma.user.upsert({
    where: { email: "dev@example.com" },
    update: {},
    create: {
      email: "dev@example.com",
      password: hash,
      role: "ADMIN",
    },
  });
}

main()
  .then(() => console.log("Seeded admin user"))
  .catch(e => console.error(e))
  .finally(() => prisma.$disconnect());



============================================================
FILE: C:\src\apgms-final\shared\scripts\clean-dist.js
============================================================
import { rm } from "node:fs/promises";
import { join } from "node:path";

const root = join(process.cwd(), "dist");
await rm(root, { recursive: true, force: true });
console.log("[shared/clean-dist] removed", root);




============================================================
FILE: C:\src\apgms-final\shared\scripts\run-prisma-generate.mjs
============================================================
// shared/scripts/run-prisma-generate.mjs
// Temporary shim: Prisma generate is handled by the root `pnpm db:gen` script.
// This exists so `pnpm run generate` / `prebuild` succeed without doing anything extra.

console.log("run-prisma-generate.mjs: skipping (handled by root db:gen).");



============================================================
FILE: C:\src\apgms-final\shared\src\analytics\anomaly.js
============================================================
import { Decimal } from "@prisma/client/runtime/library";
import { prisma } from "../db.js";
const SEVERITY_THRESHOLD = {
    medium: 0.3,
    high: 0.6,
};
export function formatCurrency(value) {
    return Number(value.toString()).toFixed(2);
}
export async function analyzeIntegrationAnomaly(orgId, taxType) {
    const events = await prisma.integrationEvent.findMany({
        where: {
            orgId,
            taxType,
            status: { in: ["processed", "verified"] },
        },
        orderBy: { createdAt: "desc" },
        take: 24,
    });
    const amounts = events.map((event) => {
        const decimal = new Decimal(event.amount);
        return Number(decimal.toString());
    });
    const latestAmount = amounts[0] ?? 0;
    const mean = amounts.length > 0
        ? amounts.reduce((sum, value) => sum + value, 0) / amounts.length
        : 0;
    const ratio = mean > 0 ? (latestAmount - mean) / mean : 0;
    let severity = "low";
    if (ratio >= SEVERITY_THRESHOLD.high) {
        severity = "high";
    }
    else if (ratio >= SEVERITY_THRESHOLD.medium) {
        severity = "medium";
    }
    const explanation = Math.abs(ratio) <= 0.1
        ? "Recent deposits are within normal historical variation."
        : ratio > 0
            ? `Recent deposits exceed the historical average by ${Math.round(ratio * 100)}%.`
            : `Recent deposits fall below the historical average by ${Math.round(-ratio * 100)}%.`;
    const template = `
    Latest ${taxType} deposit: $${latestAmount.toFixed(2)}.
    Historical average: $${mean.toFixed(2)}.
    Severity: ${severity}.
    Advice: ${ratio >= SEVERITY_THRESHOLD.medium
        ? "Monitor upcoming BAS lodgments closely."
        : "Status normal."}
  `;
    return {
        severity,
        score: Math.min(Math.max(ratio, -1), 1),
        latestAmount,
        mean,
        explanation: explanation.trim(),
        narrative: template.trim().replace(/\s+/g, " "),
    };
}



============================================================
FILE: C:\src\apgms-final\shared\src\analytics\anomaly.ts
============================================================
import { Decimal } from "@prisma/client/runtime/library";

import { prisma } from "../db.js";

export type AnomalySeverity = "low" | "medium" | "high";

const SEVERITY_THRESHOLD = {
  medium: 0.3,
  high: 0.6,
};

export function formatCurrency(value: Decimal) {
  return Number(value.toString()).toFixed(2);
}

type IntegrationEventLike = {
  amount: Decimal | number | string | null;
};

export async function analyzeIntegrationAnomaly(orgId: string, taxType: string) {
  const events = await prisma.integrationEvent.findMany({
    where: {
      orgId,
      taxType,
      status: { in: ["processed", "verified"] },
    },
    orderBy: { createdAt: "desc" },
    take: 24,
  });

  const amounts: number[] = events.map((event: IntegrationEventLike) => {
    const decimal = new Decimal(event.amount as Decimal | number | string);
    return Number(decimal.toString());
  });

  const latestAmount = amounts[0] ?? 0;

  const mean =
    amounts.length > 0
      ? amounts.reduce((sum: number, value: number) => sum + value, 0) / amounts.length
      : 0;

  const ratio = mean > 0 ? (latestAmount - mean) / mean : 0;

  let severity: AnomalySeverity = "low";
  if (ratio >= SEVERITY_THRESHOLD.high) {
    severity = "high";
  } else if (ratio >= SEVERITY_THRESHOLD.medium) {
    severity = "medium";
  }

  const explanation =
    Math.abs(ratio) <= 0.1
      ? "Recent deposits are within normal historical variation."
      : ratio > 0
      ? `Recent deposits exceed the historical average by ${Math.round(ratio * 100)}%.`
      : `Recent deposits fall below the historical average by ${Math.round(-ratio * 100)}%.`;

  const template = `
    Latest ${taxType} deposit: $${latestAmount.toFixed(2)}.
    Historical average: $${mean.toFixed(2)}.
    Severity: ${severity}.
    Advice: ${
      ratio >= SEVERITY_THRESHOLD.medium
        ? "Monitor upcoming BAS lodgments closely."
        : "Status normal."
    }
  `;

  return {
    severity,
    score: Math.min(Math.max(ratio, -1), 1),
    latestAmount,
    mean,
    explanation: explanation.trim(),
    narrative: template.trim().replace(/\s+/g, " "),
  };
}



============================================================
FILE: C:\src\apgms-final\shared\src\analytics\payment-plan-summary.js
============================================================
const describeDetails = (details) => {
    if (details === null) {
        return "no details provided";
    }
    if (typeof details === "string" || typeof details === "number" || typeof details === "boolean") {
        return details.toString();
    }
    try {
        return JSON.stringify(details);
    }
    catch {
        return "complex details";
    }
};
export function buildPaymentPlanNarrative(plan) {
    const formattedDate = plan.requestedAt instanceof Date ? plan.requestedAt.toISOString() : String(plan.requestedAt);
    const detailsDescription = describeDetails(plan.detailsJson);
    return `Payment plan ${plan.id} for cycle ${plan.basCycleId} is ${plan.status}. Reason: ${plan.reason}. Details: ${detailsDescription}. Requested at ${formattedDate}; org ${plan.orgId}.`;
}



============================================================
FILE: C:\src\apgms-final\shared\src\analytics\payment-plan-summary.ts
============================================================
import type { JsonValue } from "@prisma/client/runtime/library";

export type PaymentPlanSummaryInput = {
  id: string;
  orgId: string;
  basCycleId: string;
  reason: string;
  status: string;
  requestedAt: Date;
  detailsJson: JsonValue;
};

const describeDetails = (details: JsonValue): string => {
  if (details === null) {
    return "no details provided";
  }
  if (typeof details === "string" || typeof details === "number" || typeof details === "boolean") {
    return details.toString();
  }
  try {
    return JSON.stringify(details);
  } catch {
    return "complex details";
  }
};

export function buildPaymentPlanNarrative(plan: PaymentPlanSummaryInput): string {
  const formattedDate =
    plan.requestedAt instanceof Date ? plan.requestedAt.toISOString() : String(plan.requestedAt);
  const detailsDescription = describeDetails(plan.detailsJson);
  return `Payment plan ${plan.id} for cycle ${plan.basCycleId} is ${plan.status}. Reason: ${plan.reason}. Details: ${detailsDescription}. Requested at ${formattedDate}; org ${plan.orgId}.`;
}



============================================================
FILE: C:\src\apgms-final\shared\src\crypto\envelope.js
============================================================
import crypto from "node:crypto";
const DATA_KEY_LENGTH = 32;
const GCM_IV_LENGTH = 12;
function ensureBuffer(data) {
    return Buffer.isBuffer(data) ? data : Buffer.from(data, "utf8");
}
export function encryptEnvelope(masterKey, plaintext, associatedData) {
    if (masterKey.length !== 32) {
        throw new Error("master key must be 32 bytes");
    }
    const payload = ensureBuffer(plaintext);
    const aad = associatedData ? ensureBuffer(associatedData) : undefined;
    const dataKey = crypto.randomBytes(DATA_KEY_LENGTH);
    const payloadIv = crypto.randomBytes(GCM_IV_LENGTH);
    const payloadCipher = crypto.createCipheriv("aes-256-gcm", dataKey, payloadIv);
    if (aad) {
        payloadCipher.setAAD(aad, { plaintextLength: payload.length });
    }
    const ciphertext = Buffer.concat([payloadCipher.update(payload), payloadCipher.final()]);
    const payloadTag = payloadCipher.getAuthTag();
    const wrappedIv = crypto.randomBytes(GCM_IV_LENGTH);
    const wrapCipher = crypto.createCipheriv("aes-256-gcm", masterKey, wrappedIv);
    const wrappedKey = Buffer.concat([wrapCipher.update(dataKey), wrapCipher.final()]);
    const wrappedTag = wrapCipher.getAuthTag();
    return {
        alg: "AES-256-GCM",
        iv: payloadIv.toString("base64"),
        ciphertext: ciphertext.toString("base64"),
        tag: payloadTag.toString("base64"),
        key: {
            iv: wrappedIv.toString("base64"),
            ciphertext: wrappedKey.toString("base64"),
            tag: wrappedTag.toString("base64"),
        },
    };
}
export function decryptEnvelope(masterKey, envelope, associatedData) {
    if (masterKey.length !== 32) {
        throw new Error("master key must be 32 bytes");
    }
    const aad = associatedData ? ensureBuffer(associatedData) : undefined;
    const wrappedIv = Buffer.from(envelope.key.iv, "base64");
    const wrappedKey = Buffer.from(envelope.key.ciphertext, "base64");
    const wrappedTag = Buffer.from(envelope.key.tag, "base64");
    const unwrapCipher = crypto.createDecipheriv("aes-256-gcm", masterKey, wrappedIv);
    unwrapCipher.setAuthTag(wrappedTag);
    const dataKey = Buffer.concat([unwrapCipher.update(wrappedKey), unwrapCipher.final()]);
    const payloadIv = Buffer.from(envelope.iv, "base64");
    const ciphertext = Buffer.from(envelope.ciphertext, "base64");
    const payloadTag = Buffer.from(envelope.tag, "base64");
    const payloadCipher = crypto.createDecipheriv("aes-256-gcm", dataKey, payloadIv);
    if (aad) {
        payloadCipher.setAAD(aad, { plaintextLength: ciphertext.length });
    }
    payloadCipher.setAuthTag(payloadTag);
    const plaintext = Buffer.concat([payloadCipher.update(ciphertext), payloadCipher.final()]);
    return plaintext;
}
export function encryptJson(masterKey, value, associatedData) {
    const payload = Buffer.from(JSON.stringify(value), "utf8");
    return encryptEnvelope(masterKey, payload, associatedData);
}
export function decryptJson(masterKey, envelope, associatedData) {
    const payload = decryptEnvelope(masterKey, envelope, associatedData);
    return JSON.parse(payload.toString("utf8"));
}



============================================================
FILE: C:\src\apgms-final\shared\src\crypto\envelope.ts
============================================================
import crypto from "node:crypto";

export type EncryptionEnvelope = {
  alg: "AES-256-GCM";
  iv: string;
  ciphertext: string;
  tag: string;
  key: {
    iv: string;
    ciphertext: string;
    tag: string;
  };
};

const DATA_KEY_LENGTH = 32;
const GCM_IV_LENGTH = 12;

function ensureBuffer(data: string | Buffer): Buffer {
  return Buffer.isBuffer(data) ? data : Buffer.from(data, "utf8");
}

export function encryptEnvelope(
  masterKey: Buffer,
  plaintext: Buffer | string,
  associatedData?: Buffer | string,
): EncryptionEnvelope {
  if (masterKey.length !== 32) {
    throw new Error("master key must be 32 bytes");
  }

  const payload = ensureBuffer(plaintext);
  const aad = associatedData ? ensureBuffer(associatedData) : undefined;

  const dataKey = crypto.randomBytes(DATA_KEY_LENGTH);
  const payloadIv = crypto.randomBytes(GCM_IV_LENGTH);

  const payloadCipher = crypto.createCipheriv("aes-256-gcm", dataKey, payloadIv);
  if (aad) {
    payloadCipher.setAAD(aad, { plaintextLength: payload.length });
  }
  const ciphertext = Buffer.concat([payloadCipher.update(payload), payloadCipher.final()]);
  const payloadTag = payloadCipher.getAuthTag();

  const wrappedIv = crypto.randomBytes(GCM_IV_LENGTH);
  const wrapCipher = crypto.createCipheriv("aes-256-gcm", masterKey, wrappedIv);
  const wrappedKey = Buffer.concat([wrapCipher.update(dataKey), wrapCipher.final()]);
  const wrappedTag = wrapCipher.getAuthTag();

  return {
    alg: "AES-256-GCM",
    iv: payloadIv.toString("base64"),
    ciphertext: ciphertext.toString("base64"),
    tag: payloadTag.toString("base64"),
    key: {
      iv: wrappedIv.toString("base64"),
      ciphertext: wrappedKey.toString("base64"),
      tag: wrappedTag.toString("base64"),
    },
  };
}

export function decryptEnvelope(
  masterKey: Buffer,
  envelope: EncryptionEnvelope,
  associatedData?: Buffer | string,
): Buffer {
  if (masterKey.length !== 32) {
    throw new Error("master key must be 32 bytes");
  }

  const aad = associatedData ? ensureBuffer(associatedData) : undefined;

  const wrappedIv = Buffer.from(envelope.key.iv, "base64");
  const wrappedKey = Buffer.from(envelope.key.ciphertext, "base64");
  const wrappedTag = Buffer.from(envelope.key.tag, "base64");

  const unwrapCipher = crypto.createDecipheriv("aes-256-gcm", masterKey, wrappedIv);
  unwrapCipher.setAuthTag(wrappedTag);
  const dataKey = Buffer.concat([unwrapCipher.update(wrappedKey), unwrapCipher.final()]);

  const payloadIv = Buffer.from(envelope.iv, "base64");
  const ciphertext = Buffer.from(envelope.ciphertext, "base64");
  const payloadTag = Buffer.from(envelope.tag, "base64");

  const payloadCipher = crypto.createDecipheriv("aes-256-gcm", dataKey, payloadIv);
  if (aad) {
    payloadCipher.setAAD(aad, { plaintextLength: ciphertext.length });
  }
  payloadCipher.setAuthTag(payloadTag);
  const plaintext = Buffer.concat([payloadCipher.update(ciphertext), payloadCipher.final()]);
  return plaintext;
}

export function encryptJson<T>(
  masterKey: Buffer,
  value: T,
  associatedData?: Buffer | string,
): EncryptionEnvelope {
  const payload = Buffer.from(JSON.stringify(value), "utf8");
  return encryptEnvelope(masterKey, payload, associatedData);
}

export function decryptJson<T>(
  masterKey: Buffer,
  envelope: EncryptionEnvelope,
  associatedData?: Buffer | string,
): T {
  const payload = decryptEnvelope(masterKey, envelope, associatedData);
  return JSON.parse(payload.toString("utf8")) as T;
}



============================================================
FILE: C:\src\apgms-final\shared\src\db.js
============================================================
import prismaPkg from "@prisma/client";
const { PrismaClient } = prismaPkg;
// Prefer runtime DATABASE_URL. Fail loudly if missing to avoid silent fallbacks.
const url = process.env.DATABASE_URL;
if (!url) {
    throw new Error("DATABASE_URL is not set. Set it in services/api-gateway/.env (or process env).");
}
// Force Prisma to use this URL, bypassing any defaults like 'db:5432'
export const prisma = new PrismaClient({
    datasources: { db: { url } },
});
// Re-export a convenience alias if you import { db } elsewhere
export const db = prisma;



============================================================
FILE: C:\src\apgms-final\shared\src\db.ts
============================================================
import prismaPkg from "@prisma/client";

const { PrismaClient } = prismaPkg as { PrismaClient: new (...args: any[]) => import("@prisma/client").PrismaClient };

// Prefer runtime DATABASE_URL. Fail loudly if missing to avoid silent fallbacks.
const url = process.env.DATABASE_URL;
if (!url) {
  throw new Error("DATABASE_URL is not set. Set it in services/api-gateway/.env (or process env).");
}

// Force Prisma to use this URL, bypassing any defaults like 'db:5432'
export const prisma = new PrismaClient({
  datasources: { db: { url } },
});

// Re-export a convenience alias if you import { db } elsewhere
export const db = prisma;




============================================================
FILE: C:\src\apgms-final\shared\src\errors.js
============================================================
export class AppError extends Error {
    constructor(status, code, message, fields) {
        super(message);
        this.name = "AppError";
        this.status = status;
        this.code = code;
        this.fields = fields;
    }
}
const toFieldErrors = (issues) => issues.map((issue) => ({
    path: issue.path.join("."),
    message: issue.message,
}));
export const createError = (status, code, message, fields) => new AppError(status, code, message, fields);
export const badRequest = (code, message, fields) => createError(400, code, message, fields);
export const unauthorized = (code, message) => createError(401, code, message);
export const forbidden = (code, message) => createError(403, code, message);
export const notFound = (code, message) => createError(404, code, message);
export const conflict = (code, message) => createError(409, code, message);
export const validationError = (error) => {
    if (Array.isArray(error)) {
        return badRequest("invalid_body", "Validation failed", error);
    }
    return badRequest("invalid_body", "Validation failed", toFieldErrors(error.issues));
};



============================================================
FILE: C:\src\apgms-final\shared\src\errors.ts
============================================================
import { ZodError, ZodIssue } from "zod";

export type FieldError = {
  path: string;
  message: string;
};

export class AppError extends Error {
  readonly status: number;
  readonly code: string;
  readonly fields?: FieldError[];

  constructor(status: number, code: string, message: string, fields?: FieldError[]) {
    super(message);
    this.name = "AppError";
    this.status = status;
    this.code = code;
    this.fields = fields;
  }
}

const toFieldErrors = (issues: readonly ZodIssue[]): FieldError[] =>
  issues.map((issue) => ({
    path: issue.path.join("."),
    message: issue.message,
