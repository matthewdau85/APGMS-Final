import { analyzeIntegrationAnomaly } from "../analytics/anomaly.js";
import { aggregateObligations } from "../ledger/obligations.js";

export async function complianceSnapshot(orgId: string, taxType: string = "PAYGW") {
  const [openDiscrepancies, pendingPlans, obligations, anomaly] = await Promise.all([
    prisma.discrepancyAlert.count({
      where: { orgId, resolved: false, taxType },
    }),
    prisma.paymentPlanRequest.count({
      where: { orgId, status: { in: ["SUBMITTED", "APPROVED"] } },
    }),
    aggregateObligations(orgId, taxType),
    analyzeIntegrationAnomaly(orgId, taxType),
  ]);

  return {
    taxType,
    pendingObligations: obligations.toString(),
    unresolvedDiscrepancies: openDiscrepancies,
    activePaymentPlans: pendingPlans,
    anomaly,
  };
}



============================================================
FILE: C:\src\apgms-final\shared\src\operations\government.js
============================================================
import { prisma } from "../db.js";
export async function logGovernmentSubmission(params) {
    return prisma.governmentSubmission.create({
        data: {
            orgId: params.orgId,
            method: params.method,
            payload: params.payload,
            response: params.response ? params.response : null,
            status: params.status ?? "pending",
        },
    });
}



============================================================
FILE: C:\src\apgms-final\shared\src\operations\government.ts
============================================================
import { InputJsonValue } from "@prisma/client/runtime/library";

import { prisma } from "../db.js";

export async function logGovernmentSubmission(params: {
  orgId: string;
  method: string;
  payload: Record<string, unknown>;
  status?: string;
  response?: Record<string, unknown>;
}) {
  return prisma.governmentSubmission.create({
    data: {
      orgId: params.orgId,
      method: params.method,
      payload: params.payload as InputJsonValue,
      response: params.response ? (params.response as InputJsonValue) : null,
      status: params.status ?? "pending",
    },
  });
}



============================================================
FILE: C:\src\apgms-final\shared\src\operations\risk.js
============================================================
import { prisma } from "../db.js";
import { complianceSnapshot } from "../observability/compliance-health.js";
const RISK_THRESHOLD = {
    high: 0.5,
    medium: 0.2,
};
export async function detectRisk(orgId, taxType = "PAYGW") {
    const snapshot = await complianceSnapshot(orgId, taxType);
    const score = snapshot.anomaly.score;
    let severity = "low";
    if (score >= RISK_THRESHOLD.high || snapshot.unresolvedDiscrepancies > 3)
        severity = "high";
    else if (score >= RISK_THRESHOLD.medium || snapshot.activePaymentPlans > 1)
        severity = "medium";
    const description = severity === "high"
        ? "Repeated shortfalls or severe anomalies detected."
        : severity === "medium"
            ? "Moderate anomaly score or multiple payment plans outstanding."
            : "Normal variance observed.";
    const record = await prisma.riskEvent.create({
        data: {
            orgId,
            taxType,
            severity,
            score,
            description,
        },
    });
    return { record, snapshot };
}
export async function listRiskEvents(orgId) {
    return prisma.riskEvent.findMany({
        where: { orgId },
        orderBy: { createdAt: "desc" },
        take: 20,
    });
}



============================================================
FILE: C:\src\apgms-final\shared\src\operations\risk.ts
============================================================
import { Decimal } from "@prisma/client/runtime/library";

import { prisma } from "../db.js";
import { analyzeIntegrationAnomaly } from "../analytics/anomaly.js";
import { complianceSnapshot } from "../observability/compliance-health.js";

const RISK_THRESHOLD = {
  high: 0.5,
  medium: 0.2,
};

export type RiskSeverity = "low" | "medium" | "high";

export async function detectRisk(orgId: string, taxType: string = "PAYGW") {
  const snapshot = await complianceSnapshot(orgId, taxType);
  const score = snapshot.anomaly.score;
  let severity: RiskSeverity = "low";
  if (score >= RISK_THRESHOLD.high || snapshot.unresolvedDiscrepancies > 3) severity = "high";
  else if (score >= RISK_THRESHOLD.medium || snapshot.activePaymentPlans > 1) severity = "medium";
  const description =
    severity === "high"
      ? "Repeated shortfalls or severe anomalies detected."
      : severity === "medium"
      ? "Moderate anomaly score or multiple payment plans outstanding."
      : "Normal variance observed.";
  const record = await prisma.riskEvent.create({
    data: {
      orgId,
      taxType,
      severity,
      score,
      description,
    },
  });
  return { record, snapshot };
}

export async function listRiskEvents(orgId: string) {
  return prisma.riskEvent.findMany({
    where: { orgId },
    orderBy: { createdAt: "desc" },
    take: 20,
  });
}



============================================================
FILE: C:\src\apgms-final\shared\src\redaction.js
============================================================
import { maskValue, maskObject, maskError as maskErrorBase } from "./masking.js";
const REDACTED = "[REDACTED]";
const EMAIL_REGEX = /[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}/gi;
const TFN_REGEX = /\b\d{3}\s?\d{3}\s?\d{3}\b/g;
const ABN_REGEX = /\b\d{2}\s?\d{3}\s?\d{3}\s?\d{3}\b/g;
const IBAN_REGEX = /\b[A-Z]{2}\d{2}[A-Z0-9]{11,30}\b/g;
function redactIdentifiers(value) {
    let redacted = value.replace(EMAIL_REGEX, "[REDACTED:EMAIL]");
    redacted = redacted.replace(ABN_REGEX, "[REDACTED:ABN]");
    redacted = redacted.replace(TFN_REGEX, "[REDACTED:TFN]");
    redacted = redacted.replace(IBAN_REGEX, "[REDACTED:IBAN]");
    return redacted;
}
function redactInternal(value, key) {
    if (value == null) {
        return value;
    }
    if (typeof value === "string") {
        const scrubbed = redactIdentifiers(value);
        return maskValue(scrubbed, key);
    }
    if (Array.isArray(value)) {
        return value.map((entry) => redactInternal(entry, key));
    }
    if (value instanceof Date) {
        return value;
    }
    if (typeof value === "object") {
        return Object.fromEntries(Object.entries(value).map(([k, v]) => [
            k,
            redactInternal(v, k),
        ]));
    }
    return maskValue(value, key);
}
export function redactValue(input) {
    return redactInternal(input);
}
export function redactObject(input) {
    return maskObject(redactInternal(input));
}
export function redactError(err) {
    if (err instanceof Error) {
        const base = {
            name: err.name,
            message: maskValue(redactIdentifiers(err.message ?? ""), "message"),
            stack: REDACTED,
        };
        const possibleCause = err.cause;
        if (possibleCause !== undefined) {
            base.cause = redactInternal(possibleCause);
        }
        return base;
    }
    const masked = maskErrorBase(err);
    return Object.fromEntries(Object.entries(masked).map(([k, v]) => [k, redactInternal(v, k)]));
}
export function redactLogPayload(payload) {
    return redactInternal(payload);
}



============================================================
FILE: C:\src\apgms-final\shared\src\redaction.ts
============================================================
import { maskValue, maskObject, maskError as maskErrorBase } from "./masking.js";

const REDACTED = "[REDACTED]";

const EMAIL_REGEX =
  /[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}/gi;
const TFN_REGEX =
  /\b\d{3}\s?\d{3}\s?\d{3}\b/g;
const ABN_REGEX =
  /\b\d{2}\s?\d{3}\s?\d{3}\s?\d{3}\b/g;
const IBAN_REGEX =
  /\b[A-Z]{2}\d{2}[A-Z0-9]{11,30}\b/g;

function redactIdentifiers(value: string): string {
  let redacted = value.replace(EMAIL_REGEX, "[REDACTED:EMAIL]");
  redacted = redacted.replace(ABN_REGEX, "[REDACTED:ABN]");
  redacted = redacted.replace(TFN_REGEX, "[REDACTED:TFN]");
  redacted = redacted.replace(IBAN_REGEX, "[REDACTED:IBAN]");
  return redacted;
}

function redactInternal(value: unknown, key?: string): unknown {
  if (value == null) {
    return value;
  }

  if (typeof value === "string") {
    const scrubbed = redactIdentifiers(value);
    return maskValue(scrubbed, key);
  }

  if (Array.isArray(value)) {
    return value.map((entry) => redactInternal(entry, key));
  }

  if (value instanceof Date) {
    return value;
  }

  if (typeof value === "object") {
    return Object.fromEntries(
      Object.entries(value as Record<string, unknown>).map(([k, v]) => [
        k,
        redactInternal(v, k),
      ]),
    );
  }

  return maskValue(value, key);
}

export function redactValue<T>(input: T): T {
  return redactInternal(input) as T;
}

export function redactObject<T extends Record<string, unknown>>(input: T): T {
  return maskObject(redactInternal(input)) as T;
}

export function redactError(err: unknown): Record<string, unknown> {
  if (err instanceof Error) {
    const base = {
      name: err.name,
      message: maskValue(redactIdentifiers(err.message ?? ""), "message"),
      stack: REDACTED,
    } as Record<string, unknown>;

    const possibleCause = (err as { cause?: unknown }).cause;
    if (possibleCause !== undefined) {
      base.cause = redactInternal(possibleCause);
    }

    return base;
  }

  const masked = maskErrorBase(err);
  return Object.fromEntries(
    Object.entries(masked).map(([k, v]) => [k, redactInternal(v, k)]),
  );
}

export function redactLogPayload(payload: unknown): unknown {
  return redactInternal(payload);
}



============================================================
FILE: C:\src\apgms-final\shared\src\security\password.js
============================================================
import argon2 from "argon2";
const DEFAULT_MEMORY_COST = Number(process.env.PASSWORD_MEM_KIB ?? "65536");
const DEFAULT_TIME_COST = Number(process.env.PASSWORD_TIME_COST ?? "3");
const DEFAULT_PARALLELISM = Number(process.env.PASSWORD_PARALLELISM ?? "1");
const pepper = process.env.PASSWORD_PEPPER ?? "";
const argon2Options = {
    type: argon2.argon2id,
    memoryCost: DEFAULT_MEMORY_COST,
    timeCost: DEFAULT_TIME_COST,
    parallelism: DEFAULT_PARALLELISM,
};
function applyPepper(password) {
    return pepper ? `${password}.${pepper}` : password;
}
export async function hashPassword(password) {
    return argon2.hash(applyPepper(password), argon2Options);
}
export async function verifyPassword(hash, password) {
    try {
        return await argon2.verify(hash, applyPepper(password), argon2Options);
    }
    catch {
        return false;
    }
}



============================================================
FILE: C:\src\apgms-final\shared\src\security\password.ts
============================================================
import argon2 from "argon2";

const DEFAULT_MEMORY_COST = Number(process.env.PASSWORD_MEM_KIB ?? "65536");
const DEFAULT_TIME_COST = Number(process.env.PASSWORD_TIME_COST ?? "3");
const DEFAULT_PARALLELISM = Number(process.env.PASSWORD_PARALLELISM ?? "1");

const pepper = process.env.PASSWORD_PEPPER ?? "";

const argon2Options: argon2.Options & { raw?: false } = {
  type: argon2.argon2id,
  memoryCost: DEFAULT_MEMORY_COST,
  timeCost: DEFAULT_TIME_COST,
  parallelism: DEFAULT_PARALLELISM,
};

function applyPepper(password: string): string {
  return pepper ? `${password}.${pepper}` : password;
}

export async function hashPassword(password: string): Promise<string> {
  return argon2.hash(applyPepper(password), argon2Options);
}

export async function verifyPassword(hash: string, password: string): Promise<boolean> {
  try {
    return await argon2.verify(hash, applyPepper(password), argon2Options);
  } catch {
    return false;
  }
}




============================================================
FILE: C:\src\apgms-final\shared\src\security\secret-manager.js
============================================================
// shared/src/security/secret-manager.ts
import assert from "node:assert/strict";
export function createSecretManager() {
    const provider = (process.env.SECRETS_PROVIDER ?? "env").toLowerCase();
    if (provider === "vault") {
        const addr = process.env.VAULT_ADDR;
        const token = process.env.VAULT_TOKEN;
        assert(addr, "VAULT_ADDR is required when SECRETS_PROVIDER=vault");
        assert(token, "VAULT_TOKEN is required when SECRETS_PROVIDER=vault");
        return new VaultSecretManager(addr, token, process.env.VAULT_NAMESPACE);
    }
    return new EnvSecretManager();
}
class EnvSecretManager {
    async getSecret(identifier) {
        return process.env[identifier];
    }
}
class VaultSecretManager {
    constructor(addr, token, namespace) {
        this.addr = addr;
        this.token = token;
        this.namespace = namespace;
    }
    async getSecret(identifier) {
        // allow either a full URL or a KV path
        const path = identifier.startsWith("http")
            ? identifier
            : `${this.addr.replace(/\/$/, "")}/v1/${identifier.replace(/^\//, "")}`;
        const headers = {
            "X-Vault-Token": this.token,
        };
        if (this.namespace) {
            headers["X-Vault-Namespace"] = this.namespace;
        }
        const response = await fetch(path, { headers });
        if (response.status === 404) {
            return undefined;
        }
        if (!response.ok) {
            throw new Error(`Failed to read secret from vault at ${identifier}: ${response.statusText}`);
        }
        const body = (await response.json());
        const payload = extractVaultData(body);
        if (payload === undefined) {
            return undefined;
        }
        if (typeof payload === "string") {
            return payload;
        }
        return JSON.stringify(payload);
    }
}
function extractVaultData(body) {
    if (!body.data) {
        return undefined;
    }
    // Vault KV v2 returns { data: { data: {...}, metadata: {...} } }
    if (typeof body.data === "object" &&
        body.data !== null &&
        "data" in body.data &&
        typeof body.data.data === "object") {
        return body.data.data;
    }
    return body.data;
}



============================================================
FILE: C:\src\apgms-final\shared\src\security\secret-manager.ts
============================================================
// shared/src/security/secret-manager.ts

import assert from "node:assert/strict";

export type SecretManagerProvider = "env" | "vault";

export interface SecretManager {
  getSecret(identifier: string): Promise<string | undefined>;
}

export function createSecretManager(): SecretManager {
  const provider = (
    process.env.SECRETS_PROVIDER ?? "env"
  ).toLowerCase() as SecretManagerProvider;

  if (provider === "vault") {
    const addr = process.env.VAULT_ADDR;
    const token = process.env.VAULT_TOKEN;
    assert(
      addr,
      "VAULT_ADDR is required when SECRETS_PROVIDER=vault"
    );
    assert(
      token,
      "VAULT_TOKEN is required when SECRETS_PROVIDER=vault"
    );
    return new VaultSecretManager(
      addr,
      token,
      process.env.VAULT_NAMESPACE
    );
  }

  return new EnvSecretManager();
}

class EnvSecretManager implements SecretManager {
  async getSecret(identifier: string): Promise<string | undefined> {
    return process.env[identifier];
  }
}

class VaultSecretManager implements SecretManager {
  constructor(
    private readonly addr: string,
    private readonly token: string,
    private readonly namespace?: string
  ) {}

  async getSecret(identifier: string): Promise<string | undefined> {
    // allow either a full URL or a KV path
    const path = identifier.startsWith("http")
      ? identifier
      : `${this.addr.replace(/\/$/, "")}/v1/${identifier.replace(
          /^\//,
          ""
        )}`;

    const headers: Record<string, string> = {
      "X-Vault-Token": this.token,
    };

    if (this.namespace) {
      headers["X-Vault-Namespace"] = this.namespace;
    }

    const response = await fetch(path, { headers });

    if (response.status === 404) {
      return undefined;
    }

    if (!response.ok) {
      throw new Error(
        `Failed to read secret from vault at ${identifier}: ${response.statusText}`
      );
    }

    const body = (await response.json()) as { data?: unknown };
    const payload = extractVaultData(body);

    if (payload === undefined) {
      return undefined;
    }
    if (typeof payload === "string") {
      return payload;
    }
    return JSON.stringify(payload);
  }
}

function extractVaultData(body: { data?: unknown }): unknown {
  if (!body.data) {
    return undefined;
  }

  // Vault KV v2 returns { data: { data: {...}, metadata: {...} } }
  if (
    typeof body.data === "object" &&
    body.data !== null &&
    "data" in (body.data as Record<string, unknown>) &&
    typeof (body.data as Record<string, unknown>).data === "object"
  ) {
    return (body.data as Record<string, unknown>).data;
  }

  return body.data;
}



============================================================
FILE: C:\src\apgms-final\shared\src\security\totp.js
============================================================
import { authenticator } from "otplib";
authenticator.options = {
    step: 30,
    window: 1,
};
export function generateTotpSecret() {
    return authenticator.generateSecret();
}
export function generateTotpToken(secret) {
    return authenticator.generate(secret);
}
export function verifyTotpToken(secret, token) {
    return authenticator.verify({ token, secret });
}
export function buildTotpUri(secret, label, issuer) {
    return authenticator.keyuri(label, issuer, secret);
}



============================================================
FILE: C:\src\apgms-final\shared\src\security\totp.ts
============================================================
import { authenticator } from "otplib";

authenticator.options = {
  step: 30,
  window: 1,
};

export function generateTotpSecret(): string {
  return authenticator.generateSecret();
}

export function generateTotpToken(secret: string): string {
  return authenticator.generate(secret);
}

export function verifyTotpToken(secret: string, token: string): boolean {
  return authenticator.verify({ token, secret });
}

export function buildTotpUri(
  secret: string,
  label: string,
  issuer: string,
): string {
  return authenticator.keyuri(label, issuer, secret);
}



============================================================
FILE: C:\src\apgms-final\shared\src\security-log.js
============================================================
import { safeLogAttributes } from "./logging.js";
const CORRELATION_HEADERS = ["x-correlation-id", "X-Correlation-Id"];
function extractCorrelationFromHeaders(headers) {
    if (!headers) {
        return undefined;
    }
    for (const headerName of CORRELATION_HEADERS) {
        const raw = headers[headerName];
        if (typeof raw === "string") {
            return raw.trim() || undefined;
        }
        if (Array.isArray(raw) && raw.length > 0) {
            return raw[0]?.trim() || undefined;
        }
    }
    return undefined;
}
export function buildSecurityContextFromRequest(request) {
    const correlationId = extractCorrelationFromHeaders(request?.headers);
    return {
        correlationId,
        requestId: request?.id,
    };
}
export function buildSecurityLogEntry(payload, context = {}) {
    const mergedMetadata = context.metadata
        ? Object.assign({}, payload.metadata ?? {}, context.metadata)
        : payload.metadata;
    const entry = {
        ...payload,
        metadata: mergedMetadata,
        correlationId: context.correlationId ?? payload.correlationId,
        requestId: context.requestId ?? payload.requestId,
        occurredAt: payload.occurredAt ?? new Date().toISOString(),
    };
    return safeLogAttributes(entry);
}
export function logSecurityEvent(logger, entry) {
    logger.info({ security: entry }, "security_event");
}



============================================================
FILE: C:\src\apgms-final\shared\src\security-log.ts
============================================================
import { safeLogAttributes } from "./logging.js";

export type SecurityLogMode = "anonymized" | "deleted" | "exported" | "deleted_export" | "data_retention";

export interface SecurityLogPayload {
  event: string;
  orgId: string;
  principal: string;
  subjectUserId?: string;
  subjectEmail?: string;
  mode?: SecurityLogMode;
  metadata?: Record<string, unknown>;
  correlationId?: string;
  requestId?: string | number;
  occurredAt?: string;
}

export interface SecurityLogContext {
  correlationId?: string;
  requestId?: string | number;
  metadata?: Record<string, unknown>;
}

export interface SecurityLogEntry extends SecurityLogPayload {
  correlationId?: string;
  requestId?: string | number;
  occurredAt: string;
}

const CORRELATION_HEADERS = ["x-correlation-id", "X-Correlation-Id"];

function extractCorrelationFromHeaders(
  headers: Record<string, string | string[] | undefined> | undefined,
): string | undefined {
  if (!headers) {
    return undefined;
  }
  for (const headerName of CORRELATION_HEADERS) {
    const raw = headers[headerName];
    if (typeof raw === "string") {
      return raw.trim() || undefined;
    }
    if (Array.isArray(raw) && raw.length > 0) {
      return raw[0]?.trim() || undefined;
    }
  }
  return undefined;
}

export interface RequestContext {
  id?: string;
  headers?: Record<string, string | string[] | undefined>;
}

export function buildSecurityContextFromRequest(request?: RequestContext): SecurityLogContext {
  const correlationId = extractCorrelationFromHeaders(request?.headers);
  return {
    correlationId,
    requestId: request?.id,
  };
}

export type SecurityLogger = (entry: SecurityLogEntry) => Promise<void> | void;

export function buildSecurityLogEntry(
  payload: SecurityLogPayload,
  context: SecurityLogContext = {},
): SecurityLogEntry {
  const mergedMetadata = context.metadata
    ? Object.assign({}, payload.metadata ?? {}, context.metadata)
    : payload.metadata;
  const entry: SecurityLogEntry = {
    ...payload,
    metadata: mergedMetadata,
    correlationId: context.correlationId ?? payload.correlationId,
    requestId: context.requestId ?? payload.requestId,
    occurredAt: payload.occurredAt ?? new Date().toISOString(),
  };
  return safeLogAttributes(entry) as SecurityLogEntry;
}

export function logSecurityEvent(logger: { info: (payload: unknown, message?: string) => void }, entry: SecurityLogEntry) {
  logger.info({ security: entry }, "security_event");
}



============================================================
FILE: C:\src\apgms-final\shared\src\tax\index.js
============================================================
export function calculateGst({ amount, rate = 0.1 }) {
    if (amount <= 0 || rate <= 0) {
        return { gstPortion: 0, netOfGst: amount };
    }
    const divisor = 1 + rate;
    const netOfGst = amount / divisor;
    const gstPortion = amount - netOfGst;
    return {
        gstPortion: roundCurrency(gstPortion),
        netOfGst: roundCurrency(netOfGst),
    };
}
export function calculatePaygw(input) {
    if (input.taxableIncome <= 0 || input.brackets.length === 0) {
        return { withheld: 0, effectiveRate: 0 };
    }
    const sorted = [...input.brackets].sort((a, b) => a.threshold - b.threshold);
    let withheld = 0;
    for (const bracket of sorted) {
        withheld = Math.max(0, bracket.base + bracket.rate * input.taxableIncome);
        if (input.taxableIncome <= bracket.threshold) {
            break;
        }
    }
    const effectiveRate = Math.min(1, withheld / input.taxableIncome);
    return {
        withheld: roundCurrency(withheld),
        effectiveRate,
    };
}
export function calculateWorkingHolidayMakerWithholding({ taxableIncome, brackets, }) {
    if (taxableIncome <= 0) {
        return { withheld: 0, effectiveRate: 0 };
    }
    const matched = brackets.find((bracket) => {
        const lowerBound = bracket.over ?? 0;
        const upperBound = bracket.upTo ?? Number.POSITIVE_INFINITY;
        return taxableIncome > lowerBound && taxableIncome <= upperBound;
    }) ?? brackets[brackets.length - 1];
    const withheld = matched.base + matched.marginalRate * (taxableIncome - (matched.over ?? 0));
    return {
        withheld: roundCurrency(withheld),
        effectiveRate: Math.min(1, withheld / taxableIncome),
    };
}
export function calculateStslRepayment({ taxableIncome, thresholds }) {
    const match = thresholds.find((entry) => {
        const withinMin = taxableIncome >= entry.min;
        const withinMax = entry.max === undefined ? true : taxableIncome <= entry.max;
        return withinMin && withinMax;
    }) ?? thresholds[thresholds.length - 1];
    switch (match.repayment.type) {
        case "none":
            return 0;
        case "marginal_over_min": {
            const over = Math.max(0, taxableIncome - match.repayment.minRef);
            return roundCurrency(match.repayment.base + over * match.repayment.centsPerDollar);
        }
        case "base_plus_marginal": {
            const over = Math.max(0, taxableIncome - match.repayment.minRef);
            return roundCurrency(match.repayment.base + over * match.repayment.centsPerDollar);
        }
        case "percent_of_total_income":
            return roundCurrency(taxableIncome * match.repayment.rate);
        default:
            return 0;
    }
}
export function calculateSchedule1Withholding({ gross, payPeriod, scale, coefficients, }) {
    if (gross <= 0) {
        return { withheld: 0, effectiveRate: 0 };
    }
    const rows = coefficients[scale] ?? [];
    if (rows.length === 0) {
        return { withheld: 0, effectiveRate: 0 };
    }
    const weeklyGross = toWeekly(gross, payPeriod);
    const x = Math.floor(weeklyGross) + 0.99;
    const row = rows.find((candidate) => {
        if (candidate.weeklyLessThan === null) {
            return true;
        }
        return weeklyGross < candidate.weeklyLessThan;
    }) ?? rows[rows.length - 1];
    if (row.a === null || row.b === null) {
        return { withheld: 0, effectiveRate: 0 };
    }
    const weeklyWithholding = Math.max(0, row.a * x - row.b);
    const periodWithholding = fromWeekly(weeklyWithholding, payPeriod);
    const rounded = roundWholeDollar(periodWithholding);
    return {
        withheld: rounded,
        effectiveRate: Math.min(1, rounded / gross),
    };
}
function roundCurrency(value) {
    return Math.round((value + Number.EPSILON) * 100) / 100;
}
function roundWholeDollar(value) {
    return Math.floor(value + 0.5);
}
function toWeekly(gross, period) {
    switch (period) {
        case "weekly":
            return gross;
        case "fortnightly":
            return gross / 2;
        case "monthly":
            return (gross * 3) / 13;
        case "quarterly":
            return gross / 13;
        default:
            return gross;
    }
}
function fromWeekly(weeklyAmount, period) {
    switch (period) {
        case "weekly":
            return weeklyAmount;
        case "fortnightly":
            return weeklyAmount * 2;
        case "monthly":
            return (weeklyAmount * 13) / 3;
        case "quarterly":
            return weeklyAmount * 13;
        default:
            return weeklyAmount;
    }
}



============================================================
FILE: C:\src\apgms-final\shared\src\tax\index.ts
============================================================
/**
 * Simple PAYGW and GST calculation helpers.
 * These are deliberately opinionated and rely on injectable tax tables so that
 * downstream services can swap in updated formulas without code changes.
 */
export type PaygwBracketSet = ReadonlyArray<PaygwBracket>;

export interface GstInput {
  readonly amount: number;
  readonly rate?: number;
}

export interface GstResult {
  readonly gstPortion: number;
  readonly netOfGst: number;
}

export type PayPeriod = "weekly" | "fortnightly" | "monthly" | "quarterly";

export interface Schedule1Row {
  readonly weeklyLessThan: number | null;
  readonly a: number | null;
  readonly b: number | null;
}

export type Schedule1ScaleKey =
  | "scale1NoTaxFreeThreshold"
  | "scale2WithTaxFreeThreshold"
  | "scale3ForeignResident";

export interface PaygwBracket {
  readonly threshold: number;
  readonly rate: number;
  readonly base: number;
}

export interface PaygwInput {
  readonly taxableIncome: number;
  readonly brackets: PaygwBracketSet;
}

export interface PaygwResult {
  readonly withheld: number;
  readonly effectiveRate: number;
}

export function calculateGst({ amount, rate = 0.1 }: GstInput): GstResult {
  if (amount <= 0 || rate <= 0) {
    return { gstPortion: 0, netOfGst: amount };
  }
  const divisor = 1 + rate;
  const netOfGst = amount / divisor;
  const gstPortion = amount - netOfGst;
  return {
    gstPortion: roundCurrency(gstPortion),
    netOfGst: roundCurrency(netOfGst),
  };
}

export function calculatePaygw(input: PaygwInput): PaygwResult {
  if (input.taxableIncome <= 0 || input.brackets.length === 0) {
    return { withheld: 0, effectiveRate: 0 };
  }

  const sorted = [...input.brackets].sort((a, b) => a.threshold - b.threshold);
  let withheld = 0;

  for (const bracket of sorted) {
    withheld = Math.max(0, bracket.base + bracket.rate * input.taxableIncome);
    if (input.taxableIncome <= bracket.threshold) {
      break;
    }
  }

  const effectiveRate = Math.min(1, withheld / input.taxableIncome);
  return {
    withheld: roundCurrency(withheld),
    effectiveRate,
  };
}

export interface WorkingHolidayBracket {
  readonly upTo?: number;
  readonly over?: number;
  readonly base: number;
  readonly marginalRate: number;
}

export interface WorkingHolidayInput {
  readonly taxableIncome: number;
  readonly brackets: ReadonlyArray<WorkingHolidayBracket>;
}

export function calculateWorkingHolidayMakerWithholding({
  taxableIncome,
  brackets,
}: WorkingHolidayInput): PaygwResult {
  if (taxableIncome <= 0) {
    return { withheld: 0, effectiveRate: 0 };
  }

  const matched = brackets.find((bracket) => {
    const lowerBound = bracket.over ?? 0;
    const upperBound = bracket.upTo ?? Number.POSITIVE_INFINITY;
    return taxableIncome > lowerBound && taxableIncome <= upperBound;
  }) ?? brackets[brackets.length - 1];

  const withheld = matched.base + matched.marginalRate * (taxableIncome - (matched.over ?? 0));
  return {
    withheld: roundCurrency(withheld),
    effectiveRate: Math.min(1, withheld / taxableIncome),
  };
}

export interface StslThreshold {
  readonly min: number;
  readonly max?: number;
  readonly repayment:
    | { type: "none" }
    | { type: "marginal_over_min"; centsPerDollar: number; minRef: number; base: number }
    | { type: "base_plus_marginal"; centsPerDollar: number; minRef: number; base: number }
    | { type: "percent_of_total_income"; rate: number };
}

export interface StslInput {
  readonly taxableIncome: number;
  readonly thresholds: ReadonlyArray<StslThreshold>;
}

export function calculateStslRepayment({ taxableIncome, thresholds }: StslInput): number {
  const match =
    thresholds.find((entry) => {
      const withinMin = taxableIncome >= entry.min;
      const withinMax = entry.max === undefined ? true : taxableIncome <= entry.max;
      return withinMin && withinMax;
    }) ?? thresholds[thresholds.length - 1];

  switch (match.repayment.type) {
    case "none":
      return 0;
    case "marginal_over_min": {
      const over = Math.max(0, taxableIncome - match.repayment.minRef);
      return roundCurrency(match.repayment.base + over * match.repayment.centsPerDollar);
    }
    case "base_plus_marginal": {
      const over = Math.max(0, taxableIncome - match.repayment.minRef);
      return roundCurrency(match.repayment.base + over * match.repayment.centsPerDollar);
    }
    case "percent_of_total_income":
  return roundCurrency(taxableIncome * match.repayment.rate);
  default:
    return 0;
  }
}

export interface Schedule1Input {
  readonly gross: number;
  readonly payPeriod: PayPeriod;
  readonly scale: Schedule1ScaleKey;
  readonly coefficients: Record<Schedule1ScaleKey, ReadonlyArray<Schedule1Row>>;
}

export function calculateSchedule1Withholding({
  gross,
  payPeriod,
  scale,
  coefficients,
}: Schedule1Input): PaygwResult {
  if (gross <= 0) {
    return { withheld: 0, effectiveRate: 0 };
  }

  const rows = coefficients[scale] ?? [];
  if (rows.length === 0) {
    return { withheld: 0, effectiveRate: 0 };
  }

  const weeklyGross = toWeekly(gross, payPeriod);
  const x = Math.floor(weeklyGross) + 0.99;
  const row =
    rows.find((candidate) => {
      if (candidate.weeklyLessThan === null) {
        return true;
      }
      return weeklyGross < candidate.weeklyLessThan;
    }) ?? rows[rows.length - 1];

  if (row.a === null || row.b === null) {
    return { withheld: 0, effectiveRate: 0 };
  }

  const weeklyWithholding = Math.max(0, row.a * x - row.b);
  const periodWithholding = fromWeekly(weeklyWithholding, payPeriod);
  const rounded = roundWholeDollar(periodWithholding);
  return {
    withheld: rounded,
    effectiveRate: Math.min(1, rounded / gross),
  };
}

function roundCurrency(value: number): number {
  return Math.round((value + Number.EPSILON) * 100) / 100;
}

function roundWholeDollar(value: number): number {
  return Math.floor(value + 0.5);
}

function toWeekly(gross: number, period: PayPeriod): number {
  switch (period) {
    case "weekly":
      return gross;
    case "fortnightly":
      return gross / 2;
    case "monthly":
      return (gross * 3) / 13;
    case "quarterly":
      return gross / 13;
    default:
      return gross;
  }
}

function fromWeekly(weeklyAmount: number, period: PayPeriod): number {
  switch (period) {
    case "weekly":
      return weeklyAmount;
    case "fortnightly":
      return weeklyAmount * 2;
    case "monthly":
      return (weeklyAmount * 13) / 3;
    case "quarterly":
      return weeklyAmount * 13;
    default:
      return weeklyAmount;
  }
}



============================================================
FILE: C:\src\apgms-final\shared\src\tax\tables.js
============================================================
export const GST_RATE = 0.1;
export const GST_CLASSIFICATIONS = ["taxable", "gst_free", "input_taxed"];
export const PAYGW_WORKING_HOLIDAY_BRACKETS = [
    { upTo: 45000, marginalRate: 0.15, base: 0, over: 0 },
    { over: 45000, upTo: 135000, marginalRate: 0.3, base: 6750 },
    { over: 135000, upTo: 190000, marginalRate: 0.37, base: 33750 },
    { over: 190000, marginalRate: 0.45, base: 54100 },
];
export const STSL_THRESHOLDS = [
    {
        min: 0,
        max: 67000,
        repayment: { type: "none" },
    },
    {
        min: 67001,
        max: 125000,
        repayment: {
            type: "marginal_over_min",
            centsPerDollar: 0.15,
            base: 0,
            minRef: 67000,
        },
    },
    {
        min: 125001,
        max: 179285,
        repayment: {
            type: "base_plus_marginal",
            base: 6700,
            centsPerDollar: 0.17,
            minRef: 125000,
        },
    },
    {
        min: 179286,
        repayment: {
            type: "percent_of_total_income",
            rate: 0.1,
        },
    },
];
export const NO_TFN_WITHHOLDING = {
    residentRate: 0.47,
    foreignResidentRate: 0.45,
};
export const PAYGW_SCHEDULE1_METADATA = {
    schemaVersion: "apgms.tax.v3",
    effectiveFrom: "2024-07-01",
    formula: "y = a*x âˆ’ b",
    references: {
        residentWithTft: "Schedule 1 coefficients (Scale 2)",
        residentNoTft: "Schedule 1 coefficients (Scale 1)",
        foreignResident: "Schedule 1 coefficients (Scale 3)",
    },
};
export const PAYGW_SCHEDULE1_COEFFICIENTS = {
    scale1NoTaxFreeThreshold: [
        { weeklyLessThan: 150, a: 0.16, b: 0.16 },
        { weeklyLessThan: 371, a: 0.2117, b: 7.755 },
        { weeklyLessThan: 515, a: 0.189, b: -0.6702 },
        { weeklyLessThan: 932, a: 0.3227, b: 68.2367 },
        { weeklyLessThan: 2246, a: 0.32, b: 65.7202 },
        { weeklyLessThan: 3303, a: 0.39, b: 222.951 },
        { weeklyLessThan: null, a: 0.47, b: 487.2587 },
    ],
    scale2WithTaxFreeThreshold: [
        { weeklyLessThan: 361, a: null, b: null },
        { weeklyLessThan: 500, a: 0.16, b: 57.8462 },
        { weeklyLessThan: 625, a: 0.26, b: 107.8462 },
        { weeklyLessThan: 721, a: 0.18, b: 57.8462 },
        { weeklyLessThan: 865, a: 0.189, b: 64.3365 },
        { weeklyLessThan: 1282, a: 0.3227, b: 180.0385 },
        { weeklyLessThan: 2596, a: 0.32, b: 176.5769 },
        { weeklyLessThan: 3653, a: 0.39, b: 358.3077 },
        { weeklyLessThan: null, a: 0.47, b: 650.6154 },
    ],
    scale3ForeignResident: [
        { weeklyLessThan: 2596, a: 0.3, b: 0.3 },
        { weeklyLessThan: 3653, a: 0.37, b: 181.7308 },
        { weeklyLessThan: null, a: 0.45, b: 474.0385 },
    ],
};



============================================================
FILE: C:\src\apgms-final\shared\src\tax\tables.ts
============================================================
export const GST_RATE = 0.1;

export const GST_CLASSIFICATIONS = ["taxable", "gst_free", "input_taxed"] as const;

export const PAYGW_WORKING_HOLIDAY_BRACKETS = [
  { upTo: 45_000, marginalRate: 0.15, base: 0, over: 0 },
  { over: 45_000, upTo: 135_000, marginalRate: 0.3, base: 6_750 },
  { over: 135_000, upTo: 190_000, marginalRate: 0.37, base: 33_750 },
  { over: 190_000, marginalRate: 0.45, base: 54_100 },
] as const;

export const STSL_THRESHOLDS = [
  {
    min: 0,
    max: 67_000,
    repayment: { type: "none" } as const,
  },
  {
    min: 67_001,
    max: 125_000,
    repayment: {
      type: "marginal_over_min" as const,
      centsPerDollar: 0.15,
      base: 0,
      minRef: 67_000,
    },
  },
  {
    min: 125_001,
    max: 179_285,
    repayment: {
      type: "base_plus_marginal" as const,
      base: 6_700,
      centsPerDollar: 0.17,
      minRef: 125_000,
    },
  },
  {
    min: 179_286,
    repayment: {
      type: "percent_of_total_income" as const,
      rate: 0.1,
    },
  },
] as const;

export const NO_TFN_WITHHOLDING = {
  residentRate: 0.47,
  foreignResidentRate: 0.45,
} as const;

export const PAYGW_SCHEDULE1_METADATA = {
  schemaVersion: "apgms.tax.v3",
  effectiveFrom: "2024-07-01",
  formula: "y = a*x âˆ’ b",
  references: {
    residentWithTft: "Schedule 1 coefficients (Scale 2)",
    residentNoTft: "Schedule 1 coefficients (Scale 1)",
    foreignResident: "Schedule 1 coefficients (Scale 3)",
  },
} as const;

export const PAYGW_SCHEDULE1_COEFFICIENTS = {
  scale1NoTaxFreeThreshold: [
    { weeklyLessThan: 150, a: 0.16, b: 0.16 },
    { weeklyLessThan: 371, a: 0.2117, b: 7.755 },
    { weeklyLessThan: 515, a: 0.189, b: -0.6702 },
    { weeklyLessThan: 932, a: 0.3227, b: 68.2367 },
    { weeklyLessThan: 2_246, a: 0.32, b: 65.7202 },
    { weeklyLessThan: 3_303, a: 0.39, b: 222.951 },
    { weeklyLessThan: null, a: 0.47, b: 487.2587 },
  ],
  scale2WithTaxFreeThreshold: [
    { weeklyLessThan: 361, a: null, b: null },
    { weeklyLessThan: 500, a: 0.16, b: 57.8462 },
    { weeklyLessThan: 625, a: 0.26, b: 107.8462 },
    { weeklyLessThan: 721, a: 0.18, b: 57.8462 },
    { weeklyLessThan: 865, a: 0.189, b: 64.3365 },
    { weeklyLessThan: 1_282, a: 0.3227, b: 180.0385 },
    { weeklyLessThan: 2_596, a: 0.32, b: 176.5769 },
    { weeklyLessThan: 3_653, a: 0.39, b: 358.3077 },
    { weeklyLessThan: null, a: 0.47, b: 650.6154 },
  ],
  scale3ForeignResident: [
    { weeklyLessThan: 2_596, a: 0.3, b: 0.3 },
    { weeklyLessThan: 3_653, a: 0.37, b: 181.7308 },
    { weeklyLessThan: null, a: 0.45, b: 474.0385 },
  ],
} as const;




============================================================
FILE: C:\src\apgms-final\shared\src\types\domain-policy-shim.d.ts
============================================================
// shared/src/types/domain-policy-shim.d.ts

declare module "@apgms/domain-policy" {
  import type { PrismaClient } from "@prisma/client";

  export interface AuditLoggerEntry {
    orgId: string;
    actorId?: string;
    event: string;
    details?: unknown;
    createdAt?: Date;
  }

  export interface AuditLogger {
    log(entry: AuditLoggerEntry): void | Promise<void>;
  }

  export interface DesignatedAccountTransferParams {
    orgId: string;
    accountId: string;
    amount: number;
    source: string;
    actorId: string;
  }

  export interface DesignatedAccountTransferResult {
    transferId: string;
  }

  export interface DomainPolicyContext {
    prisma: PrismaClient;
    auditLogger?: AuditLogger;
  }

  export function applyDesignatedAccountTransfer(
    ctx: DomainPolicyContext,
    params: DesignatedAccountTransferParams,
  ): Promise<DesignatedAccountTransferResult>;
}



============================================================
FILE: C:\src\apgms-final\shared\src\validation\api.js
============================================================
import { z } from "zod";
const trimmed = () => z.string().trim().min(1);
export const LoginBodySchema = z
    .object({
    email: trimmed().email(),
    password: z.string().min(8).max(128),
})
    .strict();
export const BankLineCreateSchema = z
    .object({
    date: z.string().datetime({ offset: true }),
    amount: z
        .union([z.string(), z.number()])
        .transform((value) => (typeof value === "number" ? value.toString() : value.trim()))
        .refine((value) => /^-?\d+(\.\d{1,2})?$/.test(value), "Amount must be a decimal with up to 2 places"),
    payee: trimmed().max(120),
    desc: trimmed().max(512),
})
    .strict();
export const OrgScopedParamsSchema = z
    .object({
    orgId: trimmed(),
})
    .strict();
export const AlertResolveBodySchema = z
    .object({
    note: trimmed().max(1000),
    mfaCode: z.string().trim().min(6).max(12).optional(),
})
    .strict();
export const AlertResolveParamsSchema = z
    .object({
    id: trimmed(),
})
    .strict();
export const BasPaymentPlanQuerySchema = z
    .object({
    basCycleId: trimmed().optional(),
})
    .strict();
export const BasPaymentPlanBodySchema = z
    .object({
    basCycleId: trimmed(),
    reason: trimmed().max(500),
    weeklyAmount: z
        .union([z.number(), z.string()])
        .transform((value) => (typeof value === "number" ? value : Number.parseFloat(value)))
        .refine((value) => Number.isFinite(value) && value > 0, "weeklyAmount must be a positive number"),
    startDate: z.string().datetime({ offset: true }),
    notes: z.string().trim().max(1000).nullable().optional(),
})
    .strict();
export const BasLodgeBodySchema = z
    .object({
    mfaCode: z.string().trim().min(6).max(12).optional(),
})
    .strict();
export const TotpConfirmBodySchema = z
    .object({
    token: z.string().trim().min(6).max(12),
})
    .strict();
export const MfaStepUpBodySchema = z
    .object({
    code: z.string().trim().min(6).max(12),
})
    .strict();
const PasskeyRegistrationPayloadSchema = z
    .object({
    credential: z.unknown().optional(),
    response: z.unknown().optional(),
})
    .strict()
    .refine((payload) => payload.credential !== undefined || payload.response !== undefined, {
    message: "registration payload is required",
});
export const PasskeyRegistrationBodySchema = PasskeyRegistrationPayloadSchema;
const PasskeyAuthenticationPayloadSchema = z
    .object({
    credential: z.unknown().optional(),
    response: z.unknown().optional(),
})
    .strict()
    .refine((payload) => payload.credential !== undefined || payload.response !== undefined, {
    message: "authentication payload is required",
});
export const PasskeyVerifyBodySchema = PasskeyAuthenticationPayloadSchema;



============================================================
FILE: C:\src\apgms-final\shared\src\validation\api.ts
============================================================
import { z } from "zod";

const trimmed = () => z.string().trim().min(1);

export const LoginBodySchema = z
  .object({
    email: trimmed().email(),
    password: z.string().min(8).max(128),
  })
  .strict();

export const BankLineCreateSchema = z
  .object({
    date: z.string().datetime({ offset: true }),
    amount: z
      .union([z.string(), z.number()])
      .transform((value) => (typeof value === "number" ? value.toString() : value.trim()))
      .refine((value) => /^-?\d+(\.\d{1,2})?$/.test(value), "Amount must be a decimal with up to 2 places"),
    payee: trimmed().max(120),
    desc: trimmed().max(512),
  })
  .strict();

export const OrgScopedParamsSchema = z
  .object({
    orgId: trimmed(),
  })
  .strict();

export const AlertResolveBodySchema = z
  .object({
    note: trimmed().max(1000),
    mfaCode: z.string().trim().min(6).max(12).optional(),
  })
  .strict();

export const AlertResolveParamsSchema = z
  .object({
    id: trimmed(),
  })
  .strict();

export const BasPaymentPlanQuerySchema = z
  .object({
    basCycleId: trimmed().optional(),
  })
  .strict();

export const BasPaymentPlanBodySchema = z
  .object({
    basCycleId: trimmed(),
    reason: trimmed().max(500),
    weeklyAmount: z
      .union([z.number(), z.string()])
      .transform((value) => (typeof value === "number" ? value : Number.parseFloat(value)))
      .refine((value) => Number.isFinite(value) && value > 0, "weeklyAmount must be a positive number"),
    startDate: z.string().datetime({ offset: true }),
    notes: z.string().trim().max(1000).nullable().optional(),
  })
  .strict();

export const BasLodgeBodySchema = z
  .object({
    mfaCode: z.string().trim().min(6).max(12).optional(),
  })
  .strict();

export const TotpConfirmBodySchema = z
  .object({
    token: z.string().trim().min(6).max(12),
  })
  .strict();

export const MfaStepUpBodySchema = z
  .object({
    code: z.string().trim().min(6).max(12),
  })
  .strict();

const PasskeyRegistrationPayloadSchema = z
  .object({
    credential: z.unknown().optional(),
    response: z.unknown().optional(),
  })
  .strict()
  .refine((payload) => payload.credential !== undefined || payload.response !== undefined, {
    message: "registration payload is required",
  });

export const PasskeyRegistrationBodySchema = PasskeyRegistrationPayloadSchema;

const PasskeyAuthenticationPayloadSchema = z
  .object({
    credential: z.unknown().optional(),
    response: z.unknown().optional(),
  })
  .strict()
  .refine((payload) => payload.credential !== undefined || payload.response !== undefined, {
    message: "authentication payload is required",
  });

export const PasskeyVerifyBodySchema = PasskeyAuthenticationPayloadSchema;



============================================================
FILE: C:\src\apgms-final\shared\src\validation\index.js
============================================================
export * from "./api.js";



============================================================
FILE: C:\src\apgms-final\shared\src\validation\index.ts
============================================================
export * from "./api.js";



============================================================
FILE: C:\src\apgms-final\shared\test\envelope.test.ts
============================================================
import assert from "node:assert/strict";
import { test } from "node:test";

import {
  encryptEnvelope,
  decryptEnvelope,
  encryptJson,
  decryptJson,
} from "../src/crypto/envelope.js";

const MASTER_KEY = Buffer.alloc(32, 7);

test("encrypt/decrypt envelope round trips", () => {
  const envelope = encryptEnvelope(MASTER_KEY, "secret payload", "context");
  const plaintext = decryptEnvelope(MASTER_KEY, envelope, "context");
  assert.equal(plaintext.toString("utf8"), "secret payload");
});

test("encrypt/decrypt json round trips", () => {
  const payload = { hello: "world", count: 3 };
  const envelope = encryptJson(MASTER_KEY, payload);
  const decoded = decryptJson<typeof payload>(MASTER_KEY, envelope);
  assert.deepEqual(decoded, payload);
});



============================================================
FILE: C:\src\apgms-final\shared\test\event-bus.test.ts
============================================================
import { describe, it } from "node:test";
import assert from "node:assert/strict";

import { InMemoryEventBus } from "../src/messaging/in-memory-bus.js";
import type { BusEnvelope } from "../src/messaging/event-bus.js";

describe("InMemoryEventBus", () => {
  it("invokes subscribers with payload", async () => {
    const bus = new InMemoryEventBus();
    let callCount = 0;

    const unsubscribe = await bus.subscribe("subject", "durable", async (message: BusEnvelope) => {
      callCount += 1;
      assert.equal(message.orgId, "org-123");
    });

    await bus.publish("subject", {
      id: "evt-1",
      orgId: "org-123",
      eventType: "test",
      key: "org-123",
      ts: new Date().toISOString(),
      schemaVersion: "v1",
      source: "test",
      dedupeId: "dup-1",
      payload: { amount: 1000 },
    });

    await new Promise((resolve) => setImmediate(resolve));

    assert.equal(callCount, 1);
    await unsubscribe();
  });
});



============================================================
FILE: C:\src\apgms-final\shared\test\redaction.test.ts
============================================================
import assert from "node:assert/strict";
import { test } from "node:test";
import { maskValue, maskObject, maskError } from "../src/masking";
import { redactValue, redactError, redactLogPayload } from "../src/redaction";

test("maskValue masks by key patterns and URLs", () => {
  const input = {
    password: "hunter2",
    apiToken: "supersecrettoken",
    nested: { dsn: "postgres://user:pass@host:5432/db" },
    short: "secret",
    number: 42,
    bool: true,
    when: new Date("2025-01-01"),
  };
  const masked = maskObject(input);
  assert.equal(masked.password, "***redacted***");
  assert.equal(masked.apiToken, "***redacted***");
  assert.match(String((masked.nested as any).dsn), /^\w{4}\*+..$/); // masked DSN
  assert.equal(masked.short, "***redacted***");
  assert.equal(masked.number, 42);
  assert.equal(masked.bool, true);
  assert.ok(masked.when instanceof Date);
});

test("maskError redacts stack and cause", () => {
  const err = new Error("Failed with token=abc");
  (err as any).cause = { secret: "abc123" };
  const masked = maskError(err);
  assert.equal(masked.name, "Error");
  assert.ok(!(masked.message as string).includes("abc"));
  assert.ok((masked.stack as string).split("\n").length <= 5);
  assert.equal((masked.cause as any).secret, "***redacted***");
});

test("redactValue scrubs identifiers and secrets recursively", () => {
  const sample = {
    email: "dev@example.com",
    abn: "12 345 678 901",
    tfn: "123 456 789",
    iban: "DE89370400440532013000",
    notes: "contact dev@example.com or use token=supersecret",
    items: [{ cookie: "abcd" }, "plain"],
  };
  const result = redactValue(sample) as Record<string, unknown>;
  assert.ok(!(result.email as string).includes("dev@example.com"));
  assert.ok(!(result.abn as string).replace(/\D/g, "").includes("12345678901"));
  assert.ok(!(result.tfn as string).replace(/\D/g, "").includes("123456789"));
  assert.ok(!(result.iban as string).includes("DE89370400440532013000"));
  assert.ok(!(result.notes as string).includes("token=supersecret"));
  assert.equal((result.items as any)[0].cookie, "***redacted***");
  assert.equal((result.items as any)[1], "plain");
});

test("redactError hides stack and identifiers in message/cause", () => {
  const err = new Error("Email dev@example.com failed with secret token=abc");
  (err as any).cause = { abn: "12 345 678 901" };
  const redacted = redactError(err);
  assert.equal(redacted.stack, "[REDACTED]");
  assert.ok(!(redacted.message as string).includes("dev@example.com"));
  assert.ok(!(redacted.message as string).includes("token=abc"));
  assert.ok(!(String((redacted.cause as any).abn)).includes("12345678901"));
});

test("redactLogPayload handles mixed shapes", () => {
  const payload = [
    { authorization: "Bearer supersecret" },
    "value",
    5,
    { nested: [{ email: "a@b.com" }] },
  ];
  const redacted = redactLogPayload(payload) as any[];
  assert.equal(redacted[0].authorization, "***redacted***");
  assert.equal(redacted[1], "value");
  assert.equal(redacted[2], 5);
  assert.ok(!(redacted[3].nested[0].email as string).includes("a@b.com"));
});



============================================================
FILE: C:\src\apgms-final\shared\test\tax.test.ts
============================================================
import { describe, it } from "node:test";
import assert from "node:assert/strict";

import {
  calculateGst,
  calculatePaygw,
  calculateSchedule1Withholding,
  calculateStslRepayment,
  calculateWorkingHolidayMakerWithholding,
} from "../src/tax/index.js";
import {
  GST_RATE,
  PAYGW_SCHEDULE1_COEFFICIENTS,
  PAYGW_WORKING_HOLIDAY_BRACKETS,
  STSL_THRESHOLDS,
} from "../src/tax/tables.js";

describe("tax calculators", () => {
  it("calculates GST with default rate", () => {
    const result = calculateGst({ amount: 110, rate: GST_RATE });
    assert.equal(result.gstPortion, 10);
    assert.equal(result.netOfGst, 100);
  });

  it("calculates PAYGW using provided brackets", () => {
    const result = calculatePaygw({
      taxableIncome: 2000,
      brackets: [
        { threshold: 720, rate: 0.0, base: 0 },
        { threshold: 3610, rate: 0.19, base: 0 },
      ],
    });

    assert.equal(result.withheld, 380);
    assert.ok(result.effectiveRate > 0);
  });

  it("handles non-positive amounts gracefully", () => {
    const gst = calculateGst({ amount: -50, rate: GST_RATE });
    assert.equal(gst.gstPortion, 0);
    assert.equal(gst.netOfGst, -50);

    const paygw = calculatePaygw({
      taxableIncome: 0,
      brackets: [],
    });
    assert.equal(paygw.withheld, 0);
  });

  it("calculates working holiday maker withholding", () => {
    const result = calculateWorkingHolidayMakerWithholding({
      taxableIncome: 50_000,
      brackets: PAYGW_WORKING_HOLIDAY_BRACKETS,
    });
    assert.equal(result.withheld, 8_250);
  });

  it("calculates STSL repayment", () => {
    const repayment = calculateStslRepayment({
      taxableIncome: 130_000,
      thresholds: STSL_THRESHOLDS,
    });
    assert.equal(repayment, 7_550);
  });

  it("calculates Schedule 1 withholding for scale 2 weekly payments", () => {
    const withholding = calculateSchedule1Withholding({
      gross: 900,
      payPeriod: "weekly",
      scale: "scale2WithTaxFreeThreshold",
      coefficients: PAYGW_SCHEDULE1_COEFFICIENTS,
    });

    assert.equal(withholding.withheld, 111);
  });

  it("calculates Schedule 1 withholding for scale 1 monthly payments", () => {
    const withholding = calculateSchedule1Withholding({
      gross: 4_000,
      payPeriod: "monthly",
      scale: "scale1NoTaxFreeThreshold",
      coefficients: PAYGW_SCHEDULE1_COEFFICIENTS,
    });

    assert.ok(withholding.withheld > 0);
  });
});



============================================================
FILE: C:\src\apgms-final\shared\tsconfig.json
============================================================
{
    "extends": "../tsconfig.json",
    "compilerOptions": {
        "module": "ESNext",
        "moduleResolution": "Node",
        "rootDir": "./src",
        "outDir": "./dist",
        "declaration": true
    },
    "include": [
        "src",
        "types"
    ]
}



============================================================
FILE: C:\src\apgms-final\shared\types\prisma.d.ts
============================================================
declare module "@prisma/client" {
  export class PrismaClient {
    constructor(...args: any[]);
    $disconnect(): Promise<void>;
    [key: string]: any;
  }
}




============================================================
FILE: C:\src\apgms-final\status\incidents\incident-template.md
============================================================
# Incident Report Template

- **Incident ID**: <yyyy-mm-dd>-<slug>
- **Summary**: <one-line description>
- **Impact**: <systems/users affected, duration>
- **Detection**: <how it was detected>
- **Timeline**:
  - <timestamp> <event>
- **Mitigation**: <actions taken>
- **Root Cause**: <once identified>
- **Follow-up Actions**: <tickets/tasks>
- **Evidence**: `artifacts/compliance/<incident-id>.md`
- **Dashboards**: <links from docs/ops/dashboards.md>




============================================================
FILE: C:\src\apgms-final\status\README.md
============================================================
# Status Site Guidance

Update this directory when publishing incident notes, maintenance windows, or dashboard links.

- Store incident timelines in `status/incidents/<yyyymmdd>-<slug>.md` (link Prometheus/Grafana dashboards from `docs/ops/dashboards.md`).
- Include links to accessibility smoke reports (`docs/accessibility/smoke.md`) and compliance evidence (`docs/compliance/checklist.md`).
- After each release, summarise health checks (k6 smoke, readiness, CI status) here for customer visibility.




============================================================
FILE: C:\src\apgms-final\test-login.cjs
============================================================
const { PrismaClient } = require("@prisma/client");
const bcrypt = require("bcryptjs");

// Paste your real DATABASE_URL from shared/prisma/prisma/.env:
const DATABASE_URL = "postgresql://apgms:apgms@localhost:5432/apgms?schema=public"; // <-- replace this

const prisma = new PrismaClient({
  datasources: {
    db: {
      url: DATABASE_URL,
    },
  },
});

async function main() {
  const email = "dev@example.com";
  const plain = "admin123";

  console.log("Using DATABASE_URL:", DATABASE_URL);

  const user = await prisma.user.findUnique({ where: { email } });

  console.log("User row:", user);

  if (!user) {
    console.log("No user found with that email.");
    return;
  }

  const ok = await bcrypt.compare(plain, user.password);
  console.log("Does admin123 match stored hash?", ok);
}

main()
  .catch(err => console.error("Error in test-login:", err))
  .finally(async () => {
    await prisma.$disconnect();
  });



============================================================
FILE: C:\src\apgms-final\test-login.js
============================================================
const { PrismaClient } = require("@prisma/client");
const bcrypt = require("bcryptjs"); // we installed this

const prisma = new PrismaClient();

async function main() {
  const email = "dev@example.com";
  const plain = "admin123";

  const user = await prisma.user.findUnique({ where: { email } });

  console.log("User row:", user);

  if (!user) {
    console.log("No user found with that email.");
    return;
  }

  const ok = await bcrypt.compare(plain, user.password);
  console.log("Does admin123 match stored hash?", ok);
}

main()
  .catch(err => console.error(err))
  .finally(() => prisma.$disconnect());



============================================================
FILE: C:\src\apgms-final\tests\fixtures\ato-examples.ts
============================================================
// services/api-gateway/test/fixtures/ato-examples.ts
// ATO-aligned PAYGW and GST examples for 2024-25.
// These numbers are illustrative but should be kept consistent with
// whatever seeded TaxParameterSet / TaxRateSchedule youâ€™re using.

export interface PaygwExample {
  description: string;
  gross: number;
  expectedWithholding: number;
  parameterSetCode: string;
}

export interface GstExample {
  description: string;
  taxableAmount: number;
  gstIncluded: boolean;
  expectedNetGst: number;
  parameterSetCode: string;
}

export const paygwExamples2024_25: PaygwExample[] = [
  {
    description: "Weekly, no HELP/STSL, tax-free threshold claimed",
    gross: 1000,
    expectedWithholding: 192,
    parameterSetCode: "PAYGW_2024_25_STANDARD",
  },
  {
    description: "Weekly, with HELP/STSL, tax-free threshold claimed",
    gross: 1000,
    expectedWithholding: 230,
    parameterSetCode: "PAYGW_2024_25_STANDARD_HELP",
  },
];

export const gstExamples2024_25: GstExample[] = [
  {
    description: "Simple taxable supply 1100 including GST (100 GST)",
    taxableAmount: 1100,
    gstIncluded: true,
    expectedNetGst: 100,
    parameterSetCode: "GST_2024_25_STANDARD",
  },
  {
    description: "Mixed supplies, 1000 taxable, 500 GST-free",
    taxableAmount: 1500,
    gstIncluded: false,
    expectedNetGst: 100,
    parameterSetCode: "GST_2024_25_STANDARD",
  },
];



============================================================
FILE: C:\src\apgms-final\tsconfig.json
============================================================
{
    "compilerOptions": {
        "target": "ES2020",
        "module": "ESNext",
        "moduleResolution": "Node",
        "strict": true,
        "esModuleInterop": true,
        "skipLibCheck": true,
        "resolveJsonModule": true,
        "outDir": "dist",
        "baseUrl": ".",
        "paths": {
            "@apgms/shared/*": [
                "shared/src/*"
            ],
            "@apgms/shared": [
                "shared/src/index"
            ],
            "@apgms/domain-policy": [
                "packages/domain-policy/dist/index"
            ]
        },
        "types": [
            "node",
            "jest"
        ]
    }
}



============================================================
FILE: C:\src\apgms-final\webapp\index.html
============================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>APGMS Admin</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      http-equiv="Content-Security-Policy"
      content="default-src 'self'; base-uri 'self'; img-src 'self' data:; style-src 'self' 'unsafe-inline'; script-src 'self'; connect-src 'self' http://localhost:3000 http://localhost:5173; frame-ancestors 'none'; object-src 'none';"
    />
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>



============================================================
FILE: C:\src\apgms-final\webapp\package.json
============================================================
{
  "name": "apgms-webapp",
  "version": "0.1.0",
  "private": true,
  "scripts": {
  "dev": "vite",
  "build": "vite build",
  "typecheck": "tsc --noEmit -p tsconfig.json",
  "preview": "vite preview",
  "lint": "eslint src --ext .ts,.tsx"
},
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.30.1"
  },
  "devDependencies": {
    "@types/react": "^18.3.12",
    "@types/react-dom": "^18.3.1",
    "@types/react-router-dom": "^5.3.3",
    "@types/axe-core": "^3.0.6",
    "axe-core": "^4.9.0",
    "@vitejs/plugin-react": "^4.2.0",
    "typescript": "^5.3.0",
    "vite": "^5.4.8"
  }
}



============================================================
FILE: C:\src\apgms-final\webapp\playwright.config.ts
============================================================
import { defineConfig, devices } from '@playwright/test';

const PORT = Number(process.env.WEBAPP_PORT || 5173);
const BASE_URL = process.env.WEBAPP_BASE_URL || (`http://localhost:${PORT}`);

export default defineConfig({
  testDir: './tests',
  use: {
    baseURL: BASE_URL,
    trace: 'on-first-retry',
  },
  webServer: {
    command: process.env.CI ? `pnpm preview --port ${PORT}` : `pnpm dev --port ${PORT}`,
    url: BASE_URL,
    reuseExistingServer: !process.env.CI,
    timeout: 120000,
    stdout: 'pipe',
    stderr: 'pipe',
  },
  projects: [
    { name: 'chromium', use: { ...devices['Desktop Chrome'] } },
  ],
});


============================================================
FILE: C:\src\apgms-final\webapp\public\accessibility.html
============================================================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>APGMS Accessibility Statement</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" />
    <style>
      :root {
        color-scheme: light dark;
        font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        line-height: 1.6;
      }

      body {
        margin: 0;
        padding: 0;
        background: #f8fafc;
        color: #0f172a;
      }

      header,
      main,
      footer {
        max-width: 960px;
        margin: 0 auto;
        padding: 1.5rem;
      }

      header {
        background: #0f172a;
        color: #f1f5f9;
      }

      header h1 {
        margin: 0 0 0.5rem;
        font-size: 2rem;
      }

      a {
        color: #2563eb;
      }

      a:focus,
      button:focus,
      summary:focus {
        outline: 3px solid #fbbf24;
        outline-offset: 2px;
      }

      main section {
        background: #ffffff;
        border-radius: 12px;
        box-shadow: 0 1px 3px rgba(15, 23, 42, 0.1);
        padding: 1.5rem;
        margin-bottom: 1.5rem;
      }

      footer {
        font-size: 0.875rem;
        color: #475569;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background: #020617;
          color: #e2e8f0;
        }

        main section {
          background: #111827;
          box-shadow: 0 1px 4px rgba(15, 23, 42, 0.45);
        }

        a {
          color: #93c5fd;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>APGMS Accessibility Statement</h1>
      <p>
        APGMS is committed to ensuring digital accessibility for all visitors and strives to meet the
        <abbr title="Web Content Accessibility Guidelines">WCAG</abbr> 2.1 Level AA success criteria across our customer experiences.
      </p>
    </header>
    <main>
      <section aria-labelledby="commitment-heading">
        <h2 id="commitment-heading">Our Commitment</h2>
        <p>
          We design, build, and test APGMS experiences so that people with disabilities can perceive, operate, and understand our
          content. This includes the home page, account onboarding flows, and banking management features such as
          <code>/bank-lines</code>.
        </p>
      </section>
      <section aria-labelledby="testing-heading">
        <h2 id="testing-heading">Testing and Monitoring</h2>
        <p>
          Accessibility checks are integrated into our continuous integration pipeline using Playwright and axe. These automated
          checks run on key routes to catch regressions aligned with WCAG 2.1 Level AA criteria.
        </p>
      </section>
      <section aria-labelledby="feedback-heading">
        <h2 id="feedback-heading">Feedback</h2>
        <p>
          Your feedback helps us improve. Email <a href="mailto:accessibility@apgms.example">accessibility@apgms.example</a> if
          you encounter a barrier or need assistance. We aim to respond within five business days.
        </p>
      </section>
      <section aria-labelledby="documentation-heading">
        <h2 id="documentation-heading">Additional Documentation</h2>
        <p>
          For more detail about our accessibility program, review the
          <a
            href="https://github.com/APGMS/apgms/tree/main/docs/a11y-statement.md"
            rel="noopener"
          >engineering documentation</a>
          or the
          <a href="https://www.w3.org/TR/WCAG21/" rel="noreferrer">WCAG 2.1 specification</a>.
        </p>
      </section>
    </main>
    <footer>
      <p>Last updated: <time datetime="2024-10-01">October 1, 2024</time></p>
    </footer>
  </body>
</html>



============================================================
FILE: C:\src\apgms-final\webapp\scripts\clean-dist.js
============================================================
import { rm } from "node:fs/promises";
import { join } from "node:path";

async function main() {
  const dir = join(process.cwd(), "dist");
  try {
    await rm(dir, { recursive: true, force: true });
    console.log("[clean-dist] removed", dir);
  } catch (error) {
    console.warn("[clean-dist] failed to remove", dir, error);
  }
}

await main();



============================================================
FILE: C:\src\apgms-final\webapp\src\AlertsPage.tsx
============================================================
import React, { useEffect, useState } from "react";
import { fetchAlerts, resolveAlert, initiateMfa } from "./api";
import { getToken, getSessionUser } from "./auth";
import { ErrorState, SkeletonBlock, StatusChip } from "./components/UI";

type AlertRecord = Awaited<ReturnType<typeof fetchAlerts>>["alerts"][number];

export default function AlertsPage() {
  const token = getToken();
  const sessionUser = getSessionUser();
  const [alerts, setAlerts] = useState<AlertRecord[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [submittingId, setSubmittingId] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);

  const loadAlerts = async () => {
    if (!token) return;
    setError(null);
    try {
      const result = await fetchAlerts(token);
      setAlerts(result.alerts);
    } catch (err) {
      console.error(err);
      setError("Unable to load alerts");
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (!token) return;
    void loadAlerts();
  }, [token]);

  async function handleResolve(alert: AlertRecord) {
    if (!token) return;
    const note = window.prompt("Add a resolution note for the audit log:", "We transferred the missing GST this morning.") ?? "";
    if (!note.trim()) return;

    setSubmittingId(alert.id);
    setError(null);
    setSuccess(null);

    let resolved = false;
    let requiresMfa = false;

    try {
      await resolveAlert(token, alert.id, note.trim());
      resolved = true;
    } catch (err) {
      if (
        err instanceof Error &&
        err.message === "mfa_required" &&
        sessionUser?.mfaEnabled &&
        alert.severity.toUpperCase() === "HIGH"
      ) {
        requiresMfa = true;
      } else {
        console.error(err);
        setError("Failed to resolve alert.");
      }
    }

    if (!resolved && requiresMfa) {
      try {
        const challenge = await initiateMfa(token);
        window.alert(`MFA verification required.\n\nDev stub code: ${challenge.code} (expires in ${challenge.expiresInSeconds}s).`);
        const supplied = window.prompt("Enter the MFA code to resolve this high-severity alert:", challenge.code);
        if (!supplied || supplied.trim().length === 0) {
          setError("MFA verification cancelled.");
        } else {
          await resolveAlert(token, alert.id, note.trim(), supplied.trim());
          resolved = true;
        }
      } catch (err) {
        console.error(err);
        setError("MFA verification failed. Please try again.");
      }
    }

    if (resolved) {
      await loadAlerts();
      setSuccess("Alert resolved and logged.");
    }

    setSubmittingId(null);
  }

  if (!token) return null;

  return (
    <div style={{ display: "grid", gap: "20px" }}>
      <header>
        <h1 style={pageTitleStyle}>Alerts</h1>
        <p style={pageSubtitleStyle}>
          Real-time compliance alerts flag shortfalls and anomalies that could block BAS lodgment.
        </p>
      </header>

      {loading && (
        <div style={{ display: "grid", gap: 8 }}>
          <SkeletonBlock width="60%" />
          <SkeletonBlock width="100%" height={140} />
        </div>
      )}
      {error && <ErrorState message={error} onRetry={loadAlerts} detail="We could not load alerts right now." />}
      {success && <div style={successTextStyle}>{success}</div>}

      {!loading && !error && (
        <section style={cardStyle}>
          {alerts.length === 0 ? (
            <div style={infoTextStyle}>No alerts to display. Run a pre-check or ingest demo data to populate.</div>
          ) : (
            <ul style={alertListStyle}>
              {alerts.map((alert) => (
                <li key={alert.id} style={alertRowStyle}>
                  <div style={{ display: "grid", gap: "4px" }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px" }}>
                      <StatusChip tone={severityTone(alert.severity)}>{alert.severity.toUpperCase()}</StatusChip>
                      <span style={alertTitleStyle}>{alert.message}</span>
                    </div>
                    <div style={metaTextStyle}>
                      {alert.type} • {new Date(alert.createdAt).toLocaleString()}
                    </div>
                    {alert.resolutionNote && <div style={resolutionNoteStyle}>Note: {alert.resolutionNote}</div>}
                  </div>
                  <div style={{ display: "flex", gap: "8px", alignItems: "center" }}>
                    <StatusChip tone={alert.resolved ? "success" : "warning"}>
                      {alert.resolved ? "Resolved" : "Needs Attention"}
                    </StatusChip>
                    {!alert.resolved && (
                      <button
                        type="button"
                        style={{
                          ...resolveButtonStyle,
                          opacity: submittingId === alert.id ? 0.6 : 1,
                          cursor: submittingId === alert.id ? "wait" : "pointer",
                        }}
                        disabled={submittingId === alert.id}
                        onClick={() => void handleResolve(alert)}
                      >
                        {submittingId === alert.id ? "Resolving..." : "Resolve"}
                      </button>
                    )}
                  </div>
                </li>
              ))}
            </ul>
          )}
        </section>
      )}
    </div>
  );
}

function severityTone(severity: string) {
  const upper = severity.toUpperCase();
  if (upper === "HIGH") return "danger";
  if (upper === "MEDIUM") return "warning";
  return "neutral";
}

const pageTitleStyle: React.CSSProperties = {
  fontSize: "24px",
  fontWeight: 700,
  marginBottom: "8px",
};

const pageSubtitleStyle: React.CSSProperties = {
  color: "#4b5563",
  margin: 0,
  fontSize: "14px",
  maxWidth: "600px",
};

const cardStyle: React.CSSProperties = {
  backgroundColor: "#ffffff",
  borderRadius: "12px",
  border: "1px solid #e2e8f0",
  boxShadow: "0 1px 2px rgba(15, 23, 42, 0.08)",
};

const alertListStyle: React.CSSProperties = {
  listStyle: "none",
  margin: 0,
  padding: 0,
};

const alertRowStyle: React.CSSProperties = {
  display: "flex",
  justifyContent: "space-between",
  alignItems: "center",
  padding: "18px 24px",
  borderBottom: "1px solid #f1f5f9",
};

const alertTitleStyle: React.CSSProperties = {
  fontSize: "15px",
  fontWeight: 600,
  color: "#111827",
};

const metaTextStyle: React.CSSProperties = {
  fontSize: "12px",
  color: "#6b7280",
  textTransform: "uppercase",
  letterSpacing: "0.06em",
};

const infoTextStyle: React.CSSProperties = {
  fontSize: "14px",
  color: "#6b7280",
};

const successTextStyle: React.CSSProperties = {
  fontSize: "14px",
  color: "#047857",
};

const resolutionNoteStyle: React.CSSProperties = {
  fontSize: "12px",
  color: "#4b5563",
};

const resolveButtonStyle: React.CSSProperties = {
  padding: "6px 12px",
  borderRadius: "999px",
  border: "1px solid #d1d5db",
  backgroundColor: "#ffffff",
  fontSize: "12px",
  fontWeight: 600,
  cursor: "pointer",
};



============================================================
FILE: C:\src\apgms-final\webapp\src\api.ts
============================================================
// webapp/src/api.ts
const API_BASE = import.meta.env.VITE_API_BASE_URL ?? "http://localhost:3000";

function authHeaders(token?: string): Record<string, string> {
  const headers: Record<string, string> = {
    "Content-Type": "application/json",
  };
  if (token) {
    headers.Authorization = `Bearer ${token}`;
  }
  return headers;
}

export type ApiSession = {
  token: string;
  user: {
    id: string;
    orgId: string;
    role: string;
    mfaEnabled: boolean;
  };
};

export type BankLine = {
  id: string;
  postedAt: string;
  amount: number;
  description: string;
  createdAt: string;
};

export async function login(email: string, password: string) {
  const res = await fetch(`${API_BASE}/auth/login`, {
    method: "POST",
    headers: authHeaders(),
    body: JSON.stringify({ email, password }),
  });

  if (!res.ok) {
    throw new Error("Login failed");
  }

  return res.json() as Promise<ApiSession>;
}

export async function initiateMfa(token: string) {
  const res = await fetch(`${API_BASE}/auth/mfa/initiate`, {
    method: "POST",
    headers: authHeaders(token),
  });
  if (!res.ok) {
    throw new Error("failed_mfa_initiate");
  }
  return res.json() as Promise<{
    delivery: string;
    code: string;
    expiresInSeconds: number;
  }>;
}

export async function verifyMfa(token: string, code: string) {
  const res = await fetch(`${API_BASE}/auth/mfa/verify`, {
    method: "POST",
    headers: authHeaders(token),
    body: JSON.stringify({ code }),
  });
  if (!res.ok) {
    throw new Error("failed_mfa_verify");
  }
  return res.json() as Promise<{
    token: string;
    user: ApiSession["user"];
    session: {
      expiresInSeconds: number;
      verifiedAt: string;
    };
  }>;
}

export async function fetchUsers(token: string) {
  const res = await fetch(`${API_BASE}/users`, {
    headers: authHeaders(token),
  });
  if (!res.ok) throw new Error("unauthorized");
  return res.json() as Promise<{
    users: Array<{
      userId: string;
      email: string;
      createdAt: string;
    }>;
  }>;
}

export async function fetchBankLines(token: string) {
  const res = await fetch(`${API_BASE}/bank-lines`, {
    headers: authHeaders(token),
  });
  if (!res.ok) throw new Error("unauthorized");
  return res.json() as Promise<{
    lines: BankLine[];
  }>;
}
