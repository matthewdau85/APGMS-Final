import fs from "fs";
import path from "path";

function posixJoin(...parts) {
  return parts.join("/").replace(/\\/g, "/");
}

function exists(p) {
  try {
    fs.accessSync(p, fs.constants.F_OK);
    return true;
  } catch {
    return false;
  }
}

function readDirSorted(dir) {
  return fs
    .readdirSync(dir, { withFileTypes: true })
    .filter((d) => d.isFile())
    .map((d) => d.name)
    .sort((a, b) => a.localeCompare(b));
}

function classifyRoute(filename) {
  const base = filename.replace(/\.ts$/i, "");

  // Always public
  if (base === "health" || base === "version") return "public";

  // Always admin pack
  if (base.startsWith("admin-") || base === "admin") return "admin";

  // Prototype/demo-ish pack
  if (
    base.startsWith("prototype") ||
    base.startsWith("demo") ||
    base.includes("prototype-") ||
    base.includes("prototype_") ||
    base.includes("prototype") ||
    /^\d+-prototype/.test(base)
  ) {
    return "prototype";
  }

  // Public/auth-ish pack
  if (
    base.startsWith("auth") ||
    base.startsWith("regulator-auth") ||
    base === "schemas"
  ) {
    return "public";
  }

  // Everything else: core pack
  return "core";
}

function preferKebabCaseDuplicates(files) {
  // If both "admin-agent.ts" and "admin.agent.ts" exist, keep kebab-case.
  // Also handles "foo-bar.ts" vs "foo.bar.ts" generally.
  const byNormalized = new Map();

  for (const f of files) {
    const base = f.replace(/\.ts$/i, "");
    const norm = base.replace(/\./g, "-");
    if (!byNormalized.has(norm)) byNormalized.set(norm, []);
    byNormalized.get(norm).push(f);
  }

  const keep = [];
  const dropped = [];

  for (const [norm, group] of byNormalized.entries()) {
    if (group.length === 1) {
      keep.push(group[0]);
      continue;
    }

    const kebab = group.find((x) => x.includes("-"));
    if (kebab) {
      keep.push(kebab);
      for (const g of group) if (g !== kebab) dropped.push(g);
    } else {
      // No kebab-case present; keep first deterministically
      keep.push(group[0]);
      for (const g of group.slice(1)) dropped.push(g);
    }
  }

  keep.sort((a, b) => a.localeCompare(b));
  dropped.sort((a, b) => a.localeCompare(b));
  return { keep, dropped };
}

function makeImportName(base) {
  // registerXRoutes
  const parts = base
    .replace(/[^a-zA-Z0-9]+/g, " ")
    .trim()
    .split(/\s+/)
    .filter(Boolean);

  const pascal = parts
    .map((p) => p.charAt(0).toUpperCase() + p.slice(1))
    .join("");

  return `register${pascal}Routes`;
}

function buildIndexTs(keepFiles, droppedFiles) {
  const entries = keepFiles
    .filter((f) => f.endsWith(".ts"))
    .filter((f) => f !== "index.ts");

  const packs = {
    public: [],
    core: [],
    prototype: [],
    admin: [],
  };

  for (const f of entries) {
    const base = f.replace(/\.ts$/i, "");
    const pack = classifyRoute(f);
    packs[pack].push({ file: f, base });
  }

  for (const k of Object.keys(packs)) {
    packs[k].sort((a, b) => a.base.localeCompare(b.base));
  }

  const lines = [];
  lines.push("/* eslint-disable @typescript-eslint/no-unused-vars */");
  lines.push("import type { FastifyInstance } from \"fastify\";");
  lines.push("");
  lines.push("// AUTO-GENERATED by scripts/gen-api-gateway-routes-index.mjs");
  lines.push("// Do not hand-edit. Re-run the generator instead.");
  lines.push("");

  if (droppedFiles.length) {
    lines.push("// NOTE: Dropped duplicate route filenames (preferred kebab-case):");
    for (const d of droppedFiles) lines.push(`// - ${d}`);
    lines.push("");
  }

  const all = [].concat(
    packs.public,
    packs.core,
    packs.prototype,
    packs.admin,
  );

  for (const r of all) {
    const importName = makeImportName(r.base);
    lines.push(`import { ${importName} } from "./${r.base}.js";`);
  }

  lines.push("");
  lines.push("export type RegisterRoutesOptions = {");
  lines.push("  enablePublic?: boolean;");
  lines.push("  enableCore?: boolean;");
  lines.push("  enablePrototype?: boolean;");
  lines.push("  enableAdmin?: boolean;");
  lines.push("};");
  lines.push("");
  lines.push("export function registerAllRoutes(app: FastifyInstance, opts: RegisterRoutesOptions = {}): void {");
  lines.push("  const enablePublic = opts.enablePublic ?? true;");
  lines.push("  const enableCore = opts.enableCore ?? true;");
  lines.push("  const enablePrototype = opts.enablePrototype ?? false;");
  lines.push("  const enableAdmin = opts.enableAdmin ?? true;");
  lines.push("");

  function emitPack(packName, arr, guardExpr) {
    lines.push(`  // ${packName} routes`);
    lines.push(`  if (${guardExpr}) {`);
    for (const r of arr) {
      const importName = makeImportName(r.base);
      lines.push(`    ${importName}(app);`);
    }
    lines.push("  }");
    lines.push("");
  }

  emitPack("public", packs.public, "enablePublic");
  emitPack("core", packs.core, "enableCore");
  emitPack("prototype", packs.prototype, "enablePrototype");
  emitPack("admin", packs.admin, "enableAdmin");

  lines.push("}");
  lines.push("");

  return lines.join("\n");
}

function main() {
  const repoRoot = process.cwd();
  const routesDir = path.join(repoRoot, "services", "api-gateway", "src", "routes");
  const outFile = path.join(routesDir, "index.ts");

  if (!exists(routesDir)) {
    console.error(`[FAIL] routes dir not found: ${routesDir}`);
    process.exit(1);
  }

  const allFiles = readDirSorted(routesDir).filter((f) => f.endsWith(".ts"));
  const { keep, dropped } = preferKebabCaseDuplicates(allFiles);

  const content = buildIndexTs(keep, dropped);
  fs.writeFileSync(outFile, content, { encoding: "utf-8" });

  console.log(`[OK] wrote ${posixJoin("services/api-gateway/src/routes/index.ts")}`);
  if (dropped.length) {
    console.log("[NOTE] duplicates detected and excluded from index:");
    for (const d of dropped) console.log(`  - ${d}`);
  }
}

main();
