# =====================================================================
# bootstrap-regwatcher-email.sh
# One-shot setup for APGMS RegWatcher daily email digests (WSL-safe).
# - Creates/overwrites regwatcher files (mailer, index, CLI, pkg.json)
# - Adds root npm scripts
# - Adds GitHub Actions workflow
# - Creates .env.local.example
# - Installs deps and runs a smoke test
# =====================================================================
#!/usr/bin/env bash
set -euo pipefail

REPO_DIR="${REPO_DIR:-$HOME/src/APGMS}"
TS="$(date -u +%Y%m%dT%H%M%SZ)"
LOG_DIR="$REPO_DIR/logs"
LOG_FILE="$LOG_DIR/regwatcher-setup-$TS.log"

mkdir -p "$LOG_DIR"
exec > >(tee -a "$LOG_FILE") 2>&1

echo "=== APGMS RegWatcher Email Bootstrap ==="
echo "[repo] $REPO_DIR"
echo "[log ] $LOG_FILE"

need() { command -v "$1" >/dev/null 2>&1 || { echo "Missing: $1"; exit 2; }; }
need node
need git

if [ ! -d "$REPO_DIR" ]; then
  echo "Repo dir not found: $REPO_DIR"
  exit 2
fi

cd "$REPO_DIR"

# ------------------------------------------------------------
# Ensure pnpm via corepack
# ------------------------------------------------------------
if ! command -v pnpm >/dev/null 2>&1; then
  echo "[corepack] enabling pnpm"
  corepack enable || true
  corepack prepare pnpm@9 --activate
fi
echo "[pnpm] $(pnpm --version)"

# ------------------------------------------------------------
# Helpers: backup-if-exists and write file
# ------------------------------------------------------------
backup_if_exists() {
  local f="$1"
  if [ -f "$f" ]; then
    cp -f "$f" "${f}.bak-$TS"
    echo "[backup] ${f} -> ${f}.bak-$TS"
  fi
}

write_file() {
  local f="$1"
  local dir
  dir="$(dirname "$f")"
  mkdir -p "$dir"
  backup_if_exists "$f"
  cat > "$f"
  echo "[write] $f"
}

# ------------------------------------------------------------
# 1) Create regwatcher package files
# ------------------------------------------------------------
PKG_DIR="$REPO_DIR/packages/regwatcher"
BIN_DIR="$PKG_DIR/bin"
mkdir -p "$BIN_DIR"

# packages/regwatcher/mailer.mjs
write_file "$PKG_DIR/mailer.mjs" <<'EOF'
import nodemailer from "nodemailer";

export function getEmailConfig() {
  const cfg = {
    host: process.env.SMTP_HOST || "",
    port: Number(process.env.SMTP_PORT || "587"),
    secure: String(process.env.SMTP_SECURE || "false").toLowerCase() === "true",
    auth: {
      user: process.env.SMTP_USER || "",
      pass: process.env.SMTP_PASS || ""
    },
    from: process.env.EMAIL_FROM || "regwatcher@example.com",
    to: (process.env.EMAIL_TO || "").split(",").map(s => s.trim()).filter(Boolean),
    subjectPrefix: process.env.EMAIL_SUBJECT_PREFIX || "APGMS RegWatcher"
  };
  if (!cfg.host || !cfg.port || !cfg.auth.user || !cfg.auth.pass || cfg.to.length === 0) {
    throw new Error("Email config missing: set SMTP_HOST, SMTP_PORT, SMTP_SECURE, SMTP_USER, SMTP_PASS, EMAIL_FROM, EMAIL_TO");
  }
  return cfg;
}

export async function sendDigestEmail({ summary, alerts, runAtIso }) {
  const cfg = getEmailConfig();
  const transporter = nodemailer.createTransport({
    host: cfg.host,
    port: cfg.port,
    secure: cfg.secure,
    auth: cfg.auth
  });

  const dateLabel = new Date(runAtIso || Date.now()).toISOString().replace("T", " ").replace(/\.\d+Z$/, "Z");
  const changedCount = alerts.filter(a => a._thisRun === true).length;
  const subject = `${cfg.subjectPrefix} – ${changedCount} change(s) – ${dateLabel}`;

  const rows = alerts
    .filter(a => a._thisRun === true)
    .map(a => {
      const tt = (a.tax_types || []).join(", ");
      return `
        <tr>
          <td>${a.detected_at}</td>
          <td>${a.source_id}</td>
          <td>${a.materiality}</td>
          <td>${tt}</td>
          <td>${escapeHtml(a.summary || "")}</td>
          <td><a href="${a.url}">open</a></td>
        </tr>`;
    })
    .join("");

  const html =
`<div style="font-family: Arial, Helvetica, sans-serif; font-size:14px;">
  <h2 style="margin:0 0 8px 0;">${cfg.subjectPrefix} – Daily Digest</h2>
  <p style="margin:0 0 12px 0;">${summary}</p>
  ${
    changedCount === 0
    ? `<p>No changes detected in this run.</p>`
    : `<table border="1" cellpadding="6" cellspacing="0" style="border-collapse:collapse;">
         <thead>
           <tr>
             <th>When</th><th>Source</th><th>Materiality</th><th>Tax types</th><th>Summary</th><th>Link</th>
           </tr>
         </thead>
         <tbody>${rows}</tbody>
       </table>`
  }
  <p style="color:#888; margin-top:12px;">This automated message was generated by APGMS RegWatcher.</p>
</div>`;

  const textLines = [
    `${cfg.subjectPrefix} – Daily Digest`,
    summary,
    changedCount === 0 ? "No changes detected in this run." : "",
    ...alerts
      .filter(a => a._thisRun === true)
      .map(a => `- ${a.detected_at} | ${a.source_id} | ${a.materiality} | ${(a.tax_types||[]).join(", ")} | ${a.url}`)
  ].filter(Boolean);

  await transporter.sendMail({
    from: cfg.from,
    to: cfg.to,
    subject,
    text: textLines.join("\n"),
    html
  });
}

function escapeHtml(s) {
  return String(s)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;");
}
EOF

# packages/regwatcher/index.mjs
write_file "$PKG_DIR/index.mjs" <<'EOF'
import fs from "node:fs";
import path from "node:path";
import crypto from "node:crypto";
import * as yaml from "js-yaml";
import { XMLParser } from "fast-xml-parser";
import cheerio from "cheerio";
import { sendDigestEmail } from "./mailer.mjs";

const ROOT = process.env.APGMS_ROOT || process.cwd();
const DATA_DIR = path.join(ROOT, ".regwatcher");
const STATE_FILE = path.join(DATA_DIR, "state.json");
const WATCHLIST = path.join(ROOT, "packages", "regwatcher", "watchlist.yaml");

function ensureDirs() {
  if (!fs.existsSync(DATA_DIR)) fs.mkdirSync(DATA_DIR, { recursive: true });
  if (!fs.existsSync(STATE_FILE)) fs.writeFileSync(STATE_FILE, JSON.stringify({ items: {}, alerts: [] }, null, 2));
}

function loadWatchlist() {
  const raw = fs.readFileSync(WATCHLIST, "utf8");
  return yaml.load(raw);
}

function loadState() {
  ensureDirs();
  return JSON.parse(fs.readFileSync(STATE_FILE, "utf8"));
}

function saveState(s) {
  fs.writeFileSync(STATE_FILE, JSON.stringify(s, null, 2));
}

async function fetchText(url) {
  const res = await fetch(url, { headers: { "user-agent": "APGMS-RegWatcher/1.0" } });
  if (!res.ok) throw new Error(`Fetch failed ${res.status} for ${url}`);
  return await res.text();
}

function hashText(txt) {
  return crypto.createHash("sha256").update(txt).digest("hex");
}

function extractMainHtml(html, selector) {
  const $ = cheerio.load(html);
  const el = selector ? $(selector) : $("main");
  const text = el.text().replace(/\s+/g, " ").trim();
  return text;
}

function extractRssItems(xmlText) {
  const parser = new XMLParser({ ignoreAttributes: false });
  const xml = parser.parse(xmlText);
  const channel = xml?.rss?.channel || xml?.feed;
  if (!channel) return [];
  const items = xml?.rss ? channel.item : channel.entry;
  return Array.isArray(items) ? items : items ? [items] : [];
}

function classifyMateriality(text, watch, wl) {
  const lower = text.toLowerCase();
  let score = 0;
  for (const k of (watch.keywords || [])) if (lower.includes(k.toLowerCase())) score += 1;
  for (const k of (wl.materiality?.high_terms || [])) if (lower.includes(k.toLowerCase())) score += 1;
  const hasDateTerm = (wl.materiality?.date_terms || []).some(t => lower.includes(t.toLowerCase()));
  const high = score >= 3 || (score >= 2 && hasDateTerm);
  const medium = !high && score >= 1;
  return high ? "HIGH" : medium ? "MEDIUM" : "LOW";
}

async function maybeSlackAlert(title, url, materiality, summary) {
  const hook = process.env.REGWATCHER_SLACK_WEBHOOK;
  if (!hook) return;
  const payload = {
    text: `RegWatcher ${materiality}: ${title}\n${url}\n${summary || ""}`
  };
  await fetch(hook, { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify(payload) });
}

async function processSource(watch, wl, state, alertsThisRun) {
  const url = watch.url;
  const kind = watch.kind || "html";
  let textForHash = "";

  if (kind === "html") {
    const html = await fetchText(url);
    textForHash = extractMainHtml(html, watch.selectors?.main);
  } else if (kind === "rss" || kind === "atom") {
    const xml = await fetchText(url);
    const items = extractRssItems(xml);
    textForHash = JSON.stringify(items.map(i => i.title || i.id || i.link || "").slice(0, 10));
  } else {
    throw new Error(`Unknown kind: ${kind}`);
  }

  const h = hashText(textForHash);
  const prev = state.items[watch.id];
  const changed = !prev || prev.hash !== h;

  if (changed) {
    const materiality = classifyMateriality(textForHash, watch, wl);
    const summary = (textForHash.slice(0, 400) + (textForHash.length > 400 ? " ..." : "")).trim();
    const alert = {
      id: `${watch.id}:${Date.now()}`,
      source_id: watch.id,
      url,
      tax_types: watch.tax_types || [],
      materiality,
      detected_at: new Date().toISOString(),
      summary,
      _thisRun: true
    };
    state.alerts.unshift(alert);
    state.items[watch.id] = { hash: h, last_seen: new Date().toISOString(), url, tax_types: watch.tax_types || [] };
    state.alerts = state.alerts.slice(0, 200);
    alertsThisRun.push(alert);
    await maybeSlackAlert(watch.id, url, materiality, summary);
    return { changed: true, materiality };
  }

  return { changed: false, materiality: "NONE" };
}

export async function runWatcher({ once = true, json = false, email = false, emailAlways = false } = {}) {
  const wl = loadWatchlist();
  const state = loadState();
  const results = [];
  const alertsThisRun = [];
  for (const src of wl.sources || []) {
    try {
      const r = await processSource(src, wl, state, alertsThisRun);
      results.push({ id: src.id, changed: r.changed, materiality: r.materiality });
    } catch (e) {
      results.push({ id: src.id, error: String(e) });
    }
  }
  saveState(state);
  const changedCount = results.filter(r => r.changed).length;
  const summary = `${changedCount} change(s), ${results.length} checked`;
  const res = { summary, results };

  if (email) {
    try {
      const runAtIso = new Date().toISOString();
      if (emailAlways || changedCount > 0) {
        await sendDigestEmail({
          summary,
          alerts: state.alerts,
          runAtIso
        });
      }
    } catch (err) {
      console.error("[regwatcher] email failed:", err?.stack || err);
    }
  }

  return res;
}
EOF

# packages/regwatcher/bin/run.mjs
write_file "$BIN_DIR/run.mjs" <<'EOF'
#!/usr/bin/env node
import { runWatcher } from "../index.mjs";

const once = true;
const json = process.argv.includes("--json");
const email = process.argv.includes("--email");
const emailAlways = process.argv.includes("--always");

runWatcher({ once, json, email, emailAlways })
  .then((res) => {
    if (json) {
      process.stdout.write(JSON.stringify(res, null, 2) + "\n");
    } else {
      console.log("[regwatcher] run complete:", res.summary);
    }
    process.exit(0);
  })
  .catch((err) => {
    console.error("[regwatcher] ERROR:", err?.stack || err);
    process.exit(1);
  });
EOF
chmod +x "$BIN_DIR/run.mjs"

# packages/regwatcher/package.json
write_file "$PKG_DIR/package.json" <<'EOF'
{
  "name": "regwatcher",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "main": "index.mjs",
  "bin": {
    "regwatcher": "./bin/run.mjs"
  },
  "scripts": {
    "run": "node ./bin/run.mjs",
    "test:email": "node ./bin/run.mjs --email --always --json"
  },
  "dependencies": {
    "cheerio": "^1.0.0",
    "fast-xml-parser": "^4.4.0",
    "js-yaml": "^4.1.0",
    "nodemailer": "^6.9.9"
  }
}
EOF

# watchlist.yaml (create a starter if missing)
if [ ! -f "$PKG_DIR/watchlist.yaml" ]; then
  write_file "$PKG_DIR/watchlist.yaml" <<'EOF'
# packages/regwatcher/watchlist.yaml
materiality:
  high_terms:
    - law
    - legislative
    - instrument
    - determination
    - commencement
    - date
    - transitional
    - penalty
  date_terms:
    - effective
    - applies from
    - starts on
sources:
  - id: ato-tax-rates
    kind: html
    url: https://www.ato.gov.au/tax-rates-and-codes/
    tax_types: [income-tax, gst, witholding]
    keywords: [rates, thresholds, interest]
    selectors:
      main: main
  - id: ato-gic
    kind: html
    url: https://www.ato.gov.au/tax-rates-and-codes/general-interest-charge-rates
    tax_types: [gic]
    keywords: [general interest charge, gic]
    selectors:
      main: main
  - id: ato-news
    kind: rss
    url: https://www.ato.gov.au/RSS/Newsroom/
    tax_types: [general]
    keywords: [gst, paygw, paygi, bas, super]
EOF
fi

# ------------------------------------------------------------
# 2) Add root scripts safely using Node (no jq dependency)
# ------------------------------------------------------------
ROOT_PKG="$REPO_DIR/package.json"
if [ ! -f "$ROOT_PKG" ]; then
  echo "Root package.json not found: $ROOT_PKG"
  exit 2
fi
backup_if_exists "$ROOT_PKG"
node - <<'NODE'
const fs = require("fs");
const p = "package.json";
const j = JSON.parse(fs.readFileSync(p, "utf8"));
j.scripts = j.scripts || {};
j.scripts["regwatcher:once"] = "node packages/regwatcher/bin/run.mjs --json";
j.scripts["regwatcher:email"] = "node packages/regwatcher/bin/run.mjs --email --always --json";
fs.writeFileSync(p, JSON.stringify(j, null, 2) + "\n");
console.log("[root scripts] added regwatcher:once, regwatcher:email");
NODE

# ------------------------------------------------------------
# 3) GitHub Actions workflow
# ------------------------------------------------------------
WORKFLOW="$REPO_DIR/.github/workflows/regwatcher.yml"
write_file "$WORKFLOW" <<'EOF'
name: regwatcher
on:
  schedule:
    - cron: "0 22 * * *"
  workflow_dispatch: {}

jobs:
  run:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "pnpm"
      - name: Enable pnpm
        run: |
          corepack enable
          corepack prepare pnpm@9 --activate
      - name: Install
        run: pnpm install --frozen-lockfile
      - name: Run RegWatcher with email
        env:
          SMTP_HOST: ${{ secrets.SMTP_HOST }}
          SMTP_PORT: ${{ secrets.SMTP_PORT }}
          SMTP_SECURE: ${{ secrets.SMTP_SECURE }}
          SMTP_USER: ${{ secrets.SMTP_USER }}
          SMTP_PASS: ${{ secrets.SMTP_PASS }}
          EMAIL_FROM: ${{ secrets.EMAIL_FROM }}
          EMAIL_TO: ${{ secrets.EMAIL_TO }}
          EMAIL_SUBJECT_PREFIX: "APGMS RegWatcher"
          REGWATCHER_SLACK_WEBHOOK: ${{ secrets.REGWATCHER_SLACK_WEBHOOK }}
        run: pnpm regwatcher:email
EOF

# ------------------------------------------------------------
# 4) Env example
# ------------------------------------------------------------
ENV_EX="$REPO_DIR/.env.local.example"
write_file "$ENV_EX" <<'EOF'
# SMTP config (example)
SMTP_HOST=smtp.yourprovider.com
SMTP_PORT=587
SMTP_SECURE=false
SMTP_USER=your_smtp_user
SMTP_PASS=your_smtp_pass
EMAIL_FROM=APGMS RegWatcher <no-reply@yourdomain.com>
EMAIL_TO=you@yourdomain.com
EMAIL_SUBJECT_PREFIX=APGMS RegWatcher

# Optional Slack webhook for change pings
REGWATCHER_SLACK_WEBHOOK=
EOF

# ------------------------------------------------------------
# 5) Install and smoke test
# ------------------------------------------------------------
echo "[install] pnpm install --frozen-lockfile (falling back to plain install on lock mismatch)"
if pnpm install --frozen-lockfile; then
  echo "[install] frozen-lockfile OK"
else
  echo "[install] retry plain pnpm install"
  pnpm install
fi

echo "[smoke] pnpm run regwatcher:once"
pnpm run -s regwatcher:once || true

cat <<'NEXT'
============================================================
Done.

Next steps:
1) Duplicate .env.local.example to .env.local and fill SMTP_* and EMAIL_*.
   Then test email locally:
     export $(grep -v '^#' .env.local | xargs -d '\n')
     pnpm run regwatcher:email

2) In GitHub > Settings > Secrets and variables > Actions, add:
   SMTP_HOST, SMTP_PORT, SMTP_SECURE, SMTP_USER, SMTP_PASS, EMAIL_FROM, EMAIL_TO
   (optionally) REGWATCHER_SLACK_WEBHOOK

3) Commit and push. The regwatcher workflow will run nightly.
============================================================
NEXT
