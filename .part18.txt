
// Backwards-compatible helper used by legacy components
export async function getBankLines(token: string) {
  return fetchBankLines(token);
}

export async function createBankLine(
  token: string,
  line: { date: string; amount: string; payee: string; desc: string }
) {
  const res = await fetch(`${API_BASE}/bank-lines`, {
    method: "POST",
    headers: authHeaders(token),
    body: JSON.stringify(line),
  });
  if (!res.ok) throw new Error("create failed");
  return res.json();
}

export async function fetchCurrentObligations(token: string) {
  const res = await fetch(`${API_BASE}/org/obligations/current`, {
    headers: authHeaders(token),
  });
  if (!res.ok) throw new Error("failed_obligations");
  return res.json() as Promise<{
    basCycleId: string | null;
    basPeriodStart: string;
    basPeriodEnd: string;
    paygw: {
      required: number;
      secured: number;
      shortfall: number;
      status: string;
    };
    gst: {
      required: number;
      secured: number;
      shortfall: number;
      status: string;
    };
    nextBasDue: string | null;
  }>;
}

export async function fetchPayrollFeeds(token: string) {
  const res = await fetch(`${API_BASE}/feeds/payroll`, {
    headers: authHeaders(token),
  });
  if (!res.ok) throw new Error("failed_payroll");
  return res.json() as Promise<{
    runs: Array<{
      id: string;
      date: string;
      grossWages: number;
      paygwCalculated: number;
      paygwSecured: number;
      status: string;
    }>;
  }>;
}

export async function fetchGstFeeds(token: string) {
  const res = await fetch(`${API_BASE}/feeds/gst`, {
    headers: authHeaders(token),
  });
  if (!res.ok) throw new Error("failed_gst");
  return res.json() as Promise<{
    days: Array<{
      date: string;
      salesTotal: number;
      gstCalculated: number;
      gstSecured: number;
      status: string;
    }>;
  }>;
}

export async function fetchAlerts(token: string) {
  const res = await fetch(`${API_BASE}/alerts`, {
    headers: authHeaders(token),
  });
  if (!res.ok) throw new Error("failed_alerts");
  return res.json() as Promise<{
    alerts: Array<{
      id: string;
      type: string;
      severity: string;
      message: string;
      createdAt: string;
      resolved: boolean;
      resolvedAt: string | null;
      resolutionNote: string | null;
    }>;
  }>;
}

export async function resolveAlert(
  token: string,
  alertId: string,
  note: string,
  mfaCode?: string
) {
  const payload: Record<string, unknown> = { note };
  if (mfaCode) {
    payload.mfaCode = mfaCode;
  }
  const res = await fetch(`${API_BASE}/alerts/${alertId}/resolve`, {
    method: "POST",
    headers: authHeaders(token),
    body: JSON.stringify(payload),
  });
  if (!res.ok) {
    const errorBody = await res.json().catch(() => null);
    const errorCode =
      (errorBody as { error?: { code?: string } } | null)?.error?.code ??
      "failed_resolve_alert";
    const error = new Error(errorCode);
    (error as any).payload = errorBody;
    throw error;
  }
  return res.json() as Promise<{
    alert: {
      id: string;
      resolved: boolean;
      resolvedAt: string | null;
      resolutionNote: string | null;
    };
  }>;
}

export async function fetchBasPreview(token: string) {
  const res = await fetch(`${API_BASE}/bas/preview`, {
    headers: authHeaders(token),
  });
  if (!res.ok) throw new Error("failed_bas_preview");
  return res.json() as Promise<{
    basCycleId: string | null;
    periodStart: string | null;
    periodEnd: string | null;
    paygw: { required: number; secured: number; status: string };
    gst: { required: number; secured: number; status: string };
    overallStatus: string;
    blockers: string[];
  }>;
}

export async function lodgeBas(
  token: string,
  options?: {
    mfaCode?: string;
  }
) {
  const payload: Record<string, unknown> = {};
  if (options?.mfaCode) {
    payload.mfaCode = options.mfaCode;
  }
  const res = await fetch(`${API_BASE}/bas/lodge`, {
    method: "POST",
    headers: authHeaders(token),
    body: JSON.stringify(payload),
  });
  if (!res.ok) {
    const errorBody = await res.json().catch(() => null);
    const errorCode =
      (errorBody as { error?: { code?: string } } | null)?.error?.code ??
      "failed_bas_lodge";
    const error = new Error(errorCode);
    (error as any).payload = errorBody;
    throw error;
  }
  return res.json() as Promise<{
    basCycle: { id: string; status: string; lodgedAt: string };
  }>;
}

export async function fetchComplianceReport(token: string) {
  const res = await fetch(`${API_BASE}/compliance/report`, {
    headers: authHeaders(token),
  });
  if (!res.ok) throw new Error("failed_compliance");
  return res.json() as Promise<{
    orgId: string;
    basHistory: Array<{
      period: string;
      lodgedAt: string;
      status: string;
      notes: string;
    }>;
    alertsSummary: {
      openHighSeverity: number;
      resolvedThisQuarter: number;
    };
    nextBasDue: string | null;
    designatedTotals: {
      paygw: number;
      gst: number;
    };
    paymentPlans: Array<{
      id: string;
      basCycleId: string;
      requestedAt: string;
      status: string;
      reason: string;
      details: Record<string, unknown>;
      resolvedAt: string | null;
    }>;
  }>;
}

export async function fetchSecurityUsers(token: string) {
  const res = await fetch(`${API_BASE}/security/users`, {
    headers: authHeaders(token),
  });
  if (!res.ok) throw new Error("failed_security_users");
  return res.json() as Promise<{
    users: Array<{
      id: string;
      email: string;
      role: string;
      mfaEnabled: boolean;
      createdAt: string;
      lastLogin: string | null;
    }>;
  }>;
}

export async function fetchDesignatedAccounts(token: string) {
  const res = await fetch(`${API_BASE}/org/designated-accounts`, {
    headers: authHeaders(token),
  });
  if (!res.ok) throw new Error("failed_designated_accounts");
  return res.json() as Promise<{
    totals: {
      paygw: number;
      gst: number;
    };
    accounts: Array<{
      id: string;
      type: string;
      balance: number;
      updatedAt: string;
      transfers: Array<{
        id: string;
        amount: number;
        source: string;
        createdAt: string;
      }>;
    }>;
  }>;
}

export async function fetchPaymentPlanRequest(
  token: string,
  basCycleId?: string
) {
  const url =
    basCycleId === undefined
      ? `${API_BASE}/bas/payment-plan-request`
      : `${API_BASE}/bas/payment-plan-request?basCycleId=${encodeURIComponent(
          basCycleId
        )}`;
  const res = await fetch(url, {
    headers: authHeaders(token),
  });
  if (!res.ok) throw new Error("failed_payment_plan_fetch");
  return res.json() as Promise<{
    request: {
      id: string;
      basCycleId: string;
      requestedAt: string;
      status: string;
      reason: string;
      details: Record<string, unknown>;
      resolvedAt: string | null;
    } | null;
  }>;
}

export async function createPaymentPlanRequest(
  token: string,
  payload: {
    basCycleId: string;
    reason: string;
    weeklyAmount: number;
    startDate: string;
    notes?: string;
  }
) {
  const res = await fetch(`${API_BASE}/bas/payment-plan-request`, {
    method: "POST",
    headers: authHeaders(token),
    body: JSON.stringify(payload),
  });
  if (!res.ok) throw new Error("failed_payment_plan_create");
  return res.json() as Promise<{
    request: {
      id: string;
      basCycleId: string;
      requestedAt: string;
      status: string;
      reason: string;
      details: Record<string, unknown>;
      resolvedAt: string | null;
    };
  }>;
}

export async function fetchEvidenceArtifacts(token: string) {
  const res = await fetch(`${API_BASE}/compliance/evidence`, {
    headers: authHeaders(token),
  });
  if (!res.ok) throw new Error("failed_evidence_list");
  return res.json() as Promise<{
    artifacts: Array<{
      id: string;
      kind: string;
      sha256: string;
      wormUri: string;
      createdAt: string;
    }>;
  }>;
}

export async function createEvidenceArtifact(token: string) {
  const res = await fetch(`${API_BASE}/compliance/evidence`, {
    method: "POST",
    headers: authHeaders(token),
  });
  if (!res.ok) throw new Error("failed_evidence_create");
  return res.json() as Promise<{
    artifact: {
      id: string;
      sha256: string;
      createdAt: string;
      wormUri: string;
    };
  }>;
}

export async function fetchEvidenceArtifactDetail(token: string, artifactId: string) {
  const res = await fetch(`${API_BASE}/compliance/evidence/${artifactId}`, {
    headers: authHeaders(token),
  });
  if (!res.ok) throw new Error("failed_evidence_detail");
  return res.json() as Promise<{
    artifact: {
      id: string;
      kind: string;
      sha256: string;
      wormUri: string;
      createdAt: string;
      payload: Record<string, unknown> | null;
    };
  }>;
}

export type RegulatorLoginResponse = {
  token: string;
  session: {
    id: string;
    issuedAt: string;
    expiresAt: string;
    sessionToken: string;
  };
};

export async function regulatorLogin(accessCode: string, orgId?: string) {
  const trimmedCode = accessCode.trim();
  const resolvedOrgId = orgId?.trim() && orgId.trim().length > 0 ? orgId.trim() : undefined;
  const res = await fetch(`${API_BASE}/regulator/login`, {
    method: "POST",
    headers: authHeaders(),
    body: JSON.stringify({
      accessCode: trimmedCode,
      orgId: resolvedOrgId,
    }),
  });

  if (!res.ok) {
    const body = await res.json().catch(() => null);
    const code =
      (body as { error?: { code?: string } } | null)?.error?.code ?? "regulator_login_failed";
    const error = new Error(code);
    (error as any).payload = body;
    throw error;
  }

  const payload = (await res.json()) as RegulatorLoginResponse;
  return {
    ...payload,
    orgId: resolvedOrgId ?? "dev-org",
  };
}

export async function fetchRegulatorComplianceReport(token: string) {
  const res = await fetch(`${API_BASE}/regulator/compliance/report`, {
    headers: authHeaders(token),
  });
  if (!res.ok) throw new Error("failed_regulator_compliance");
  return res.json() as Promise<{
    orgId: string;
    basHistory: Array<{
      period: string;
      lodgedAt: string | null;
      status: string;
      notes: string;
    }>;
    paymentPlans: Array<{
      id: string;
      basCycleId: string;
      requestedAt: string;
      status: string;
      reason: string;
      details: Record<string, unknown>;
      resolvedAt: string | null;
    }>;
    alertsSummary: {
      openHighSeverity: number;
      resolvedThisQuarter: number;
    };
    nextBasDue: string | null;
    designatedTotals: {
      paygw: number;
      gst: number;
    };
  }>;
}

export async function fetchRegulatorAlerts(token: string) {
  const res = await fetch(`${API_BASE}/regulator/alerts`, {
    headers: authHeaders(token),
  });
  if (!res.ok) throw new Error("failed_regulator_alerts");
  return res.json() as Promise<{
    alerts: Array<{
      id: string;
      type: string;
      severity: string;
      message: string;
      createdAt: string;
      resolved: boolean;
      resolvedAt: string | null;
    }>;
  }>;
}

export async function fetchRegulatorMonitoringSnapshots(token: string, limit = 5) {
  const params = new URLSearchParams({ limit: String(limit) });
  const res = await fetch(`${API_BASE}/regulator/monitoring/snapshots?${params.toString()}`, {
    headers: authHeaders(token),
  });
  if (!res.ok) throw new Error("failed_regulator_snapshots");
  return res.json() as Promise<{
    snapshots: Array<{
      id: string;
      type: string;
      createdAt: string;
      payload: {
        generatedAt: string;
        alerts: {
          total: number;
          openHigh: number;
          openMedium: number;
          recent: Array<{
            id: string;
            type: string;
            severity: string;
            createdAt: string;
            resolved: boolean;
          }>;
        };
        paymentPlansOpen: number;
        designatedTotals: {
          paygw: number;
          gst: number;
        };
        bas: null | {
          overallStatus: string;
          paygw: {
            required: number;
            secured: number;
            status: string;
            shortfall?: number;
          };
          gst: {
            required: number;
            secured: number;
            status: string;
            shortfall?: number;
          };
          blockers: string[];
        };
      };
    }>;
  }>;
}

export async function fetchRegulatorEvidenceList(token: string) {
  const res = await fetch(`${API_BASE}/regulator/evidence`, {
    headers: authHeaders(token),
  });
  if (!res.ok) throw new Error("failed_regulator_evidence");
  return res.json() as Promise<{
    artifacts: Array<{
      id: string;
      kind: string;
      sha256: string;
      wormUri: string | null;
      createdAt: string;
    }>;
  }>;
}

export async function fetchRegulatorEvidenceDetail(token: string, artifactId: string) {
  const res = await fetch(`${API_BASE}/regulator/evidence/${artifactId}`, {
    headers: authHeaders(token),
  });
  if (!res.ok) throw new Error("failed_regulator_evidence_detail");
  return res.json() as Promise<{
    artifact: {
      id: string;
      kind: string;
      sha256: string;
      wormUri: string | null;
      createdAt: string;
      payload: Record<string, unknown> | null;
    };
  }>;
}

export async function generateDemoBankLines(
  token: string,
  payload: { daysBack?: number; intensity?: "low" | "high" } = {},
) {
  const res = await fetch(`${API_BASE}/demo/banking/generate`, {
    method: "POST",
    headers: authHeaders(token),
    body: JSON.stringify(payload),
  });
  if (!res.ok) throw new Error("failed_demo_bank_lines");
  return res.json() as Promise<{
    note: string;
    generated: number;
    intensity: string;
    range: string;
    rows: Array<{ id: string; amount: number; date: string }>;
  }>;
}

export async function runDemoPayroll(
  token: string,
  payload: { includeBankLines?: boolean; note?: string } = {},
) {
  const res = await fetch(`${API_BASE}/demo/payroll/run`, {
    method: "POST",
    headers: authHeaders(token),
    body: JSON.stringify(payload),
  });
  if (!res.ok) throw new Error("failed_demo_payroll");
  return res.json() as Promise<{
    note: string;
    payRunId: string;
    totalPaygWithheld: number;
    payslips: number;
  }>;
}

export async function compileDemoBas(
  token: string,
  payload: { year: number; month: number },
) {
  const res = await fetch(`${API_BASE}/demo/bas/compile`, {
    method: "POST",
    headers: authHeaders(token),
    body: JSON.stringify(payload),
  });
  if (!res.ok) throw new Error("failed_demo_bas");
  return res.json() as Promise<{
    note: string;
    period: { year: number; month: number };
    gstCollected: number;
    gstCredits: number;
    netGst: number;
    paygWithheld: number;
    bankLines: number;
    payslips: number;
  }>;
}

export async function fetchRegulatorBankSummary(token: string) {
  const res = await fetch(`${API_BASE}/regulator/bank-lines/summary`, {
    headers: authHeaders(token),
  });
  if (!res.ok) throw new Error("failed_regulator_bank_summary");
  return res.json() as Promise<{
    summary: {
      totalEntries: number;
      totalAmount: number;
      firstEntryAt: string | null;
      lastEntryAt: string | null;
    };
    recent: Array<{
      id: string;
      date: string;
      amount: number;
    }>;
  }>;
}



============================================================
FILE: C:\src\apgms-final\webapp\src\App.css
============================================================
.app {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  background: linear-gradient(
    180deg,
    var(--color-background) 0%,
    var(--color-surface-muted) 100%
  );
  color: var(--color-text);
}

.app__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: var(--spacing-lg) var(--spacing-2xl) var(--spacing-md);
  gap: var(--spacing-lg);
}

.app__brand {
  font-size: var(--font-size-xl);
  font-weight: var(--font-weight-semibold);
  letter-spacing: -0.02em;
}

.app__nav {
  display: flex;
  gap: var(--spacing-md);
  align-items: center;
}

.app__nav-link {
  position: relative;
  padding: var(--spacing-xs) var(--spacing-sm);
  font-size: var(--font-size-sm);
  font-weight: var(--font-weight-medium);
  color: var(--color-text-muted);
  text-decoration: none;
  border-radius: var(--radius-pill);
  transition: color 180ms ease, background-color 180ms ease;
}

.app__nav-link[aria-current='page'] {
  color: var(--color-primary-contrast);
  background-color: var(--color-primary);
  box-shadow: var(--shadow-sm);
}

.app__nav-link:focus-visible {
  outline: 2px solid var(--color-focus);
  outline-offset: 2px;
}

.app__theme-toggle {
  padding: var(--spacing-xs) var(--spacing-sm);
  border-radius: var(--radius-pill);
  border: 1px solid var(--color-border);
  background-color: var(--color-surface);
  color: var(--color-text);
  font-size: var(--font-size-md);
  cursor: pointer;
  transition: border-color 180ms ease, box-shadow 180ms ease;
}

.app__theme-toggle:hover {
  border-color: var(--color-border-strong);
}

.app__theme-toggle:focus-visible {
  outline: 2px solid var(--color-focus);
  outline-offset: 2px;
}

.app__content {
  flex: 1;
  padding: 0 var(--spacing-2xl) var(--spacing-2xl);
  display: flex;
  flex-direction: column;
}

.app__footer {
  border-top: 1px solid var(--color-border);
  padding: var(--spacing-md) var(--spacing-2xl);
  font-size: var(--font-size-sm);
  color: var(--color-text-muted);
  background-color: var(--color-surface-muted);
}

@media (max-width: 800px) {
  .app__header,
  .app__content,
  .app__footer {
    padding-left: var(--spacing-lg);
    padding-right: var(--spacing-lg);
  }

  .app__header {
    flex-direction: column;
    align-items: flex-start;
  }

  .app__nav {
    width: 100%;
  }
}



============================================================
FILE: C:\src\apgms-final\webapp\src\App.tsx
============================================================
// webapp/src/App.tsx
import React from "react";
import { BrowserRouter, Routes, Route, Navigate } from "react-router-dom";
import LoginPage from "./LoginPage";
import DashboardPage from "./DashboardPage";
import FeedsPage from "./FeedsPage";
import AlertsPage from "./AlertsPage";
import BasPage from "./BasPage";
import CompliancePage from "./CompliancePage";
import SecurityPage from "./SecurityPage";
import DemoPage from "./DemoPage";
import ProtectedLayout from "./ProtectedLayout";
import RegulatorLoginPage from "./RegulatorLoginPage";
import RegulatorLayout from "./RegulatorLayout";
import RegulatorOverviewPage from "./RegulatorOverviewPage";
import RegulatorEvidencePage from "./RegulatorEvidencePage";
import RegulatorMonitoringPage from "./RegulatorMonitoringPage";

export default function App() {
  return (
    <BrowserRouter>
      <Routes>
        {/* login */}
        <Route path="/" element={<LoginPage />} />
        <Route path="/regulator" element={<RegulatorLoginPage />} />
        <Route path="/regulator/portal" element={<RegulatorLayout />}>
          <Route index element={<Navigate to="overview" replace />} />
          <Route path="overview" element={<RegulatorOverviewPage />} />
          <Route path="evidence" element={<RegulatorEvidencePage />} />
          <Route path="monitoring" element={<RegulatorMonitoringPage />} />
        </Route>
        <Route element={<ProtectedLayout />}>
          <Route path="/dashboard" element={<DashboardPage />} />
          <Route path="/feeds" element={<FeedsPage />} />
          <Route path="/alerts" element={<AlertsPage />} />
          <Route path="/bas" element={<BasPage />} />
          <Route path="/compliance" element={<CompliancePage />} />
          <Route path="/demo" element={<DemoPage />} />
          <Route path="/security" element={<SecurityPage />} />
        </Route>
        {/* catch-all */}
        <Route
          path="*"
          element={
            <div style={{ fontFamily: "system-ui", padding: 24 }}>
              Not found
            </div>
          }
        />
      </Routes>
    </BrowserRouter>
  );
}



============================================================
FILE: C:\src\apgms-final\webapp\src\auth.ts
============================================================
// webapp/src/auth.ts
const SESSION_KEY = "apgms_session";
const LEGACY_TOKEN_KEY = "apgms_token";

export type SessionUser = {
  id: string;
  orgId: string;
  role: string;
  mfaEnabled: boolean;
};

export type Session = {
  token: string;
  user: SessionUser;
};

function readSession(): Session | null {
  const raw = localStorage.getItem(SESSION_KEY);
  if (!raw) {
    return null;
  }
  try {
    return JSON.parse(raw) as Session;
  } catch {
    localStorage.removeItem(SESSION_KEY);
    return null;
  }
}

export function saveSession(session: Session) {
  localStorage.setItem(SESSION_KEY, JSON.stringify(session));
  localStorage.removeItem(LEGACY_TOKEN_KEY);
}

export function updateSession(
  update: Partial<Session> & { user?: Partial<SessionUser> },
): Session | null {
  const current = readSession();
  if (!current) {
    return null;
  }
  const next: Session = {
    ...current,
    ...update,
    user: {
      ...current.user,
      ...(update.user ?? {}),
    },
  };
  saveSession(next);
  return next;
}

export function getSession(): Session | null {
  return readSession();
}

export function getSessionUser(): SessionUser | null {
  return readSession()?.user ?? null;
}

export function getToken(): string | null {
  return readSession()?.token ?? null;
}

export function clearSession() {
  localStorage.removeItem(SESSION_KEY);
  localStorage.removeItem(LEGACY_TOKEN_KEY);
}

export function clearToken() {
  clearSession();
}



============================================================
FILE: C:\src\apgms-final\webapp\src\BankLineForm.tsx
============================================================
// services/webapp/src/BankLineForm.tsx
import { useState } from "react";
import { createBankLine } from "./api";

export function BankLineForm({
  token,
  onCreated,
}: {
  token: string;
  onCreated: () => void;
}) {
  const [date, setDate] = useState("2025-01-01T00:00:00.000Z");
  const [amount, setAmount] = useState("123.45");
  const [payee, setPayee] = useState("Test Vendor");
  const [desc, setDesc] = useState("Laptop purchase");
  const [error, setError] = useState("");

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault();
    setError("");
    try {
      await createBankLine(token, { date, amount, payee, desc });
      onCreated();
    } catch (err) {
      setError("Failed to create");
    }
  }

  return (
    <form
      onSubmit={handleSubmit}
      style={{
        display: "grid",
        gap: "0.5rem",
        border: "1px solid #ccc",
        padding: "1rem",
        borderRadius: 8,
      }}
    >
      <h2>New Bank Line</h2>

      <label>
        <div>Date (ISO)</div>
        <input value={date} onChange={(e) => setDate(e.target.value)} />
      </label>

      <label>
        <div>Amount</div>
        <input value={amount} onChange={(e) => setAmount(e.target.value)} />
      </label>

      <label>
        <div>Payee</div>
        <input value={payee} onChange={(e) => setPayee(e.target.value)} />
      </label>

      <label>
        <div>Description</div>
        <input value={desc} onChange={(e) => setDesc(e.target.value)} />
      </label>

      {error && <div style={{ color: "red" }}>{error}</div>}

      <button type="submit">Create Line</button>
    </form>
  );
}



============================================================
FILE: C:\src\apgms-final\webapp\src\BankLineTable.tsx
============================================================
// services/webapp/src/BankLineTable.tsx
import { BankLine } from "./api";

export function BankLineTable({ lines }: { lines: BankLine[] }) {
  return (
    <table
      style={{
        width: "100%",
        borderCollapse: "collapse",
        fontFamily: "sans-serif",
      }}
    >
      <thead>
        <tr>
          <th
            style={{
              textAlign: "left",
              borderBottom: "1px solid #ccc",
              padding: "0.5rem",
            }}
          >
            Posted At
          </th>
          <th
            style={{
              textAlign: "right",
              borderBottom: "1px solid #ccc",
              padding: "0.5rem",
            }}
          >
            Amount
          </th>
          <th
            style={{
              textAlign: "left",
              borderBottom: "1px solid #ccc",
              padding: "0.5rem",
            }}
          >
            Description (masked)
          </th>
          <th
            style={{
              textAlign: "left",
              borderBottom: "1px solid #ccc",
              padding: "0.5rem",
            }}
          >
            Created
          </th>
        </tr>
      </thead>
      <tbody>
        {lines.map((l) => (
          <tr key={l.id}>
            <td
              style={{
                borderBottom: "1px solid #eee",
                padding: "0.5rem",
                whiteSpace: "nowrap",
              }}
            >
              {l.postedAt}
            </td>
            <td
              style={{
                borderBottom: "1px solid #eee",
                padding: "0.5rem",
                textAlign: "right",
              }}
            >
              {l.amount}
            </td>
            <td
              style={{
                borderBottom: "1px solid #eee",
                padding: "0.5rem",
              }}
            >
              {l.description}
            </td>
            <td
              style={{
                borderBottom: "1px solid #eee",
                padding: "0.5rem",
              }}
            >
              {l.createdAt}
            </td>
          </tr>
        ))}
      </tbody>
    </table>
  );
}



============================================================
FILE: C:\src\apgms-final\webapp\src\BasPage.tsx
============================================================
import React, { useEffect, useState } from "react";
import {
  fetchBasPreview,
  lodgeBas,
  fetchDesignatedAccounts,
  fetchPaymentPlanRequest,
  createPaymentPlanRequest,
  initiateMfa,
} from "./api";
import { getToken, getSessionUser } from "./auth";
import { ErrorState, SkeletonBlock, StatusChip, StatCard } from "./components/UI";

type BasPreviewResponse = Awaited<ReturnType<typeof fetchBasPreview>>;
type DesignatedAccountsResponse = Awaited<ReturnType<typeof fetchDesignatedAccounts>>;
type DesignatedAccountView = DesignatedAccountsResponse["accounts"][number];
type PaymentPlanResponse = Awaited<ReturnType<typeof fetchPaymentPlanRequest>>["request"];

export default function BasPage() {
  const token = getToken();
  const sessionUser = getSessionUser();
  const [preview, setPreview] = useState<BasPreviewResponse | null>(null);
  const [designated, setDesignated] = useState<DesignatedAccountsResponse | null>(null);
  const [paymentPlan, setPaymentPlan] = useState<PaymentPlanResponse | null>(null);

  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);
  const [submitting, setSubmitting] = useState(false);
  const [designatedError, setDesignatedError] = useState<string | null>(null);
  const [planError, setPlanError] = useState<string | null>(null);
  const [planSuccess, setPlanSuccess] = useState<string | null>(null);
  const [planLoading, setPlanLoading] = useState(false);

  const basCycleId = preview?.basCycleId ?? null;

  useEffect(() => {
    if (!token) return;
    void loadPreview();
  }, [token]);

  useEffect(() => {
    if (!token) return;
    if (basCycleId) {
      void loadPaymentPlan(basCycleId);
    } else {
      setPaymentPlan(null);
      setPlanError(null);
      setPlanSuccess(null);
    }
  }, [token, basCycleId]);

  async function loadPreview() {
    if (!token) return;
    setError(null);
    setDesignatedError(null);
    setLoading(true);
    try {
      const [previewData, designatedData] = await Promise.all([
        fetchBasPreview(token),
        fetchDesignatedAccounts(token),
      ]);
      setPreview(previewData);
      setDesignated(designatedData);
    } catch (err) {
      console.error(err);
      setError("Unable to load BAS preview");
    } finally {
      setLoading(false);
    }
  }

  async function loadPaymentPlan(cycleId: string) {
    if (!token) return;
    setPlanError(null);
    setPlanSuccess(null);
    setPlanLoading(true);
    try {
      const response = await fetchPaymentPlanRequest(token, cycleId);
      setPaymentPlan(response.request);
    } catch (err) {
      console.error(err);
      setPlanError("Unable to load payment plan status");
    } finally {
      setPlanLoading(false);
    }
  }

  async function handleLodge() {
    if (!token) return;
    setSubmitting(true);
    setSuccess(null);
    setError(null);

    let lodged = false;
    let requiresMfa = false;
    let lodgmentResult: Awaited<ReturnType<typeof lodgeBas>> | null = null;

    try {
      const result = await lodgeBas(token);
      lodgmentResult = result;
      lodged = true;
    } catch (err) {
      if (err instanceof Error && err.message === "mfa_required" && sessionUser?.mfaEnabled) {
        requiresMfa = true;
      } else {
        console.error(err);
        setError("BAS could not be lodged. Check blockers and try again.");
      }
    }

    if (!lodged && requiresMfa) {
      try {
        const challenge = await initiateMfa(token);
        window.alert(
          `MFA verification required for BAS lodgment.\n\nDev stub code: ${challenge.code} (expires in ${challenge.expiresInSeconds}s).`
        );
        const supplied = window.prompt(
          "Enter the MFA code to authorise BAS lodgment:",
          challenge.code
        );
        if (!supplied || supplied.trim().length === 0) {
          setError("MFA verification cancelled.");
        } else {
          const result = await lodgeBas(token, { mfaCode: supplied.trim() });
          lodgmentResult = result;
          lodged = true;
        }
      } catch (err) {
        console.error(err);
        setError("MFA verification failed. Please try again.");
      }
    }

    if (lodged && lodgmentResult) {
      setSuccess(`BAS lodged at ${new Date(lodgmentResult.basCycle.lodgedAt).toLocaleString()}`);
      await loadPreview();
      if (lodgmentResult.basCycle.id) {
        await loadPaymentPlan(lodgmentResult.basCycle.id);
      }
    }

    setSubmitting(false);
  }

  async function handleCreatePaymentPlan() {
    if (!token || !basCycleId) return;
    const reason = window.prompt("Reason for payment plan", "CASHFLOW_SHORTFALL");
    if (!reason || reason.trim() === "") return;
    const weeklyAmountInput = window.prompt("Weekly amount (AUD)", "1500");
    if (!weeklyAmountInput) return;
    const weeklyAmount = Number(weeklyAmountInput);
    if (!Number.isFinite(weeklyAmount) || weeklyAmount <= 0) {
      setPlanError("Weekly amount must be a positive number");
      return;
    }
    const startDate = window.prompt("Proposed start date (YYYY-MM-DD)", new Date().toISOString().slice(0, 10));
    if (!startDate) return;
    const notes = window.prompt("Additional notes (optional)") ?? undefined;

    setPlanError(null);
    setPlanSuccess(null);
    setPlanLoading(true);
    try {
      const response = await createPaymentPlanRequest(token, {
        basCycleId,
        reason: reason.trim(),
        weeklyAmount,
        startDate,
        notes,
      });
      setPaymentPlan(response.request);
      setPlanSuccess("Payment plan request submitted and logged");
    } catch (err) {
      console.error(err);
      setPlanError("Unable to submit payment plan request");
    } finally {
      setPlanLoading(false);
    }
  }

  if (!token) return null;

  const hasActiveCycle = Boolean(preview?.periodStart && preview?.periodEnd);
  const periodStart = hasActiveCycle && preview?.periodStart ? new Date(preview.periodStart).toLocaleDateString() : null;
  const periodEnd = hasActiveCycle && preview?.periodEnd ? new Date(preview.periodEnd).toLocaleDateString() : null;
  const paygwAccount = designated?.accounts.find((account) => account.type.toUpperCase() === "PAYGW") ?? null;
  const gstAccount = designated?.accounts.find((account) => account.type.toUpperCase() === "GST") ?? null;

  return (
    <div style={{ display: "grid", gap: "24px" }}>
      <header>
        <h1 style={pageTitleStyle}>BAS Lodgment</h1>
        <p style={pageSubtitleStyle}>
          We preview the BAS position before lodgment. If obligations are underfunded, the system blocks the transfer and surfaces blockers.
        </p>
      </header>

      {loading && (
        <div style={{ display: "grid", gap: 8 }}>
          <SkeletonBlock width="50%" />
          <SkeletonBlock width="100%" height={140} />
        </div>
      )}
      {error && <ErrorState message={error} onRetry={loadPreview} detail="We could not load BAS preview." />}
      {success && <div style={successTextStyle}>{success}</div>}

      {preview && !error && hasActiveCycle && (
        <>
          <section style={overviewCardStyle}>
            <div style={{ display: "flex", alignItems: "center", gap: "16px", flexWrap: "wrap" }}>
              <StatusChip tone={preview.overallStatus === "READY" ? "success" : "warning"}>
                {preview.overallStatus === "READY" ? "Ready" : "Blocked"}
              </StatusChip>
              <div>
                <div style={overviewTitleStyle}>BAS period {periodStart} to {periodEnd}</div>
                <div style={metaTextStyle}>
                  The ATO payment is automatically triggered if all obligations are secured.
                </div>
              </div>
            </div>
            <div style={{ display: "flex", gap: 10 }}>
              <button
                type="button"
                className="app-button"
                onClick={handleLodge}
                disabled={submitting || preview.overallStatus !== "READY"}
              >
                {submitting ? "Lodging..." : "Lodge BAS now"}
              </button>
            </div>
          </section>

          <section style={gridTwoColumns}>
            <ObligationCard title="PAYGW" data={preview.paygw} />
            <ObligationCard title="GST" data={preview.gst} />
          </section>

          {preview.blockers.length > 0 && (
            <section style={blockersCardStyle}>
              <h2 style={sectionTitleStyle}>Why we are blocked</h2>
              <ul style={blockersListStyle}>
                {preview.blockers.map((blocker, idx) => (
                  <li key={idx} style={blockerItemStyle}>
                    {blocker}
                  </li>
                ))}
              </ul>
            </section>
          )}
        </>
      )}

      {preview && !error && !hasActiveCycle && (
        <section style={overviewCardStyle}>
          <div style={{ fontSize: "16px", fontWeight: 600 }}>No active BAS cycle</div>
          <p style={{ fontSize: "14px", color: "#4b5563", margin: 0 }}>
            All BAS cycles are lodged. Seed a new period in the database to continue the demo.
          </p>
        </section>
      )}

      {(designated || designatedError) && (
        <section style={accountsCardStyle}>
          <h2 style={accountsTitleStyle}>Designated holding accounts</h2>
          <p style={accountsSubtitleStyle}>
            The ATO transfer draws directly from these PAYGW and GST designated accounts when you lodge.
          </p>
          {designatedError && <ErrorState message={designatedError} detail="Holding accounts unavailable." />}
          {!designated && !designatedError && (
            <div style={{ display: "grid", gap: 8 }}>
              <SkeletonBlock width="100%" height={60} />
              <SkeletonBlock width="100%" height={60} />
            </div>
          )}
          {designated && (
            <div style={accountsGridStyle}>
              <HoldingAccountCard title="PAYGW holding account" account={paygwAccount} />
              <HoldingAccountCard title="GST holding account" account={gstAccount} />
            </div>
          )}
        </section>
      )}

      {(basCycleId && preview && (preview.overallStatus !== "READY" || paymentPlan)) && (
        <section style={planCardStyle}>
          <div style={planHeaderStyle}>
            <h2 style={planTitleStyle}>Payment plan request</h2>
            <StatusChip tone={paymentPlan ? statusTone(paymentPlan.status) : "neutral"}>
              {paymentPlan ? paymentPlan.status : "NONE"}
            </StatusChip>
          </div>
          <p style={planSubtitleStyle}>
            Shortfalls can be escalated to the ATO early. Request a structured payment plan so the evidence trail shows good faith remediation.
          </p>
          {planError && <ErrorState message={planError} onRetry={() => basCycleId && loadPaymentPlan(basCycleId)} />}
          {planSuccess && <div style={successTextStyle}>{planSuccess}</div>}
          {planLoading && <div style={infoTextStyle}>Checking payment plan status...</div>}
          {paymentPlan ? (
            <div style={planDetailsGridStyle}>
              <div>
                <div style={planDetailLabelStyle}>Requested</div>
                <div style={planDetailValueStyle}>{new Date(paymentPlan.requestedAt).toLocaleString()}</div>
              </div>
              <div>
                <div style={planDetailLabelStyle}>Reason</div>
                <div style={planDetailValueStyle}>{paymentPlan.reason}</div>
              </div>
              <div>
                <div style={planDetailLabelStyle}>Details</div>
                <div style={planDetailValueStyle}>
                  {JSON.stringify(paymentPlan.details)}
                </div>
              </div>
            </div>
          ) : (
            <button
              type="button"
              className="app-button ghost"
              onClick={handleCreatePaymentPlan}
              disabled={planLoading}
            >
              Request payment plan
            </button>
          )}
        </section>
      )}
    </div>
  );
}

function HoldingAccountCard({ title, account }: { title: string; account: DesignatedAccountView | null }) {
  const balance = account?.balance ?? 0;
  const tone = balance > 0 ? "success" : "warning";
  return (
    <div style={accountsCardColumnStyle}>
      <div style={accountsCardHeaderStyle}>
        <h3 style={accountsCardTitleStyle}>{title}</h3>
        <StatusChip tone={tone}>{account ? "Inbound only" : "Not provisioned"}</StatusChip>
      </div>
      <div style={accountsBalanceStyle}>{currencyFormatter.format(balance)}</div>
      <div style={accountsUpdatedStyle}>
        Last updated {account?.updatedAt ? new Date(account.updatedAt).toLocaleString() : "N/A"}
      </div>
    </div>
  );
}

function ObligationCard({ title, data }: { title: string; data: BasPreviewResponse["paygw"] }) {
  const shortfall = Math.max(0, (data.required ?? 0) - (data.secured ?? 0));
  const tone = shortfall > 0 ? "warning" : "success";
  return (
    <div style={obligationCardStyle}>
      <div style={obligationHeaderStyle}>
        <h3 style={obligationTitleStyle}>{title}</h3>
        <StatusChip tone={tone}>{shortfall > 0 ? "Short" : "Covered"}</StatusChip>
      </div>
      <div style={obligationValueStyle}>{currencyFormatter.format(data.secured ?? 0)}</div>
      <div style={obligationMetaStyle}>Required: {currencyFormatter.format(data.required ?? 0)}</div>
      {shortfall > 0 && <div style={obligationMetaStyle}>Shortfall: {currencyFormatter.format(shortfall)}</div>}
    </div>
  );
}

function statusTone(status: string) {
  const upper = status.toUpperCase();
  if (upper === "READY" || upper === "OK") return "success";
  if (upper === "PARTIAL" || upper === "PENDING") return "warning";
  if (upper === "BLOCKED" || upper === "FAILED") return "danger";
  return "neutral";
}

const currencyFormatter = new Intl.NumberFormat("en-AU", {
  style: "currency",
  currency: "AUD",
});

const pageTitleStyle: React.CSSProperties = {
  fontSize: "24px",
  fontWeight: 700,
  marginBottom: "8px",
};

const pageSubtitleStyle: React.CSSProperties = {
  color: "#4b5563",
  margin: 0,
  fontSize: "14px",
  maxWidth: "620px",
};

const infoTextStyle: React.CSSProperties = {
  fontSize: "14px",
  color: "#6b7280",
};

const successTextStyle: React.CSSProperties = {
  fontSize: "14px",
  color: "#047857",
};

const overviewCardStyle: React.CSSProperties = {
  backgroundColor: "#ffffff",
  borderRadius: "12px",
  padding: "20px",
  border: "1px solid #e2e8f0",
  boxShadow: "0 1px 2px rgba(15, 23, 42, 0.08)",
  display: "flex",
  alignItems: "center",
  justifyContent: "space-between",
  gap: 12,
  flexWrap: "wrap",
};

const overviewTitleStyle: React.CSSProperties = {
  fontSize: "18px",
  fontWeight: 700,
  margin: 0,
};

const metaTextStyle: React.CSSProperties = {
  fontSize: "14px",
  color: "#4b5563",
};

const gridTwoColumns: React.CSSProperties = {
  display: "grid",
  gap: "12px",
  gridTemplateColumns: "repeat(auto-fit, minmax(240px, 1fr))",
};

const blockersCardStyle: React.CSSProperties = {
  backgroundColor: "#ffffff",
  borderRadius: "12px",
  padding: "20px",
  border: "1px solid #e2e8f0",
  boxShadow: "0 1px 2px rgba(15, 23, 42, 0.08)",
};

const blockersListStyle: React.CSSProperties = {
  margin: 0,
  paddingLeft: "18px",
  color: "#1f2937",
};

const blockerItemStyle: React.CSSProperties = {
  marginBottom: "6px",
};

const accountsCardStyle: React.CSSProperties = {
  backgroundColor: "#ffffff",
  borderRadius: "12px",
  padding: "20px",
  border: "1px solid #e2e8f0",
  boxShadow: "0 1px 2px rgba(15, 23, 42, 0.08)",
  display: "grid",
  gap: "12px",
};

const accountsTitleStyle: React.CSSProperties = {
  fontSize: "18px",
  fontWeight: 700,
  margin: 0,
};

const accountsSubtitleStyle: React.CSSProperties = {
  fontSize: "14px",
  color: "#4b5563",
  margin: 0,
};

const accountsGridStyle: React.CSSProperties = {
  display: "grid",
  gap: "12px",
  gridTemplateColumns: "repeat(auto-fit, minmax(240px, 1fr))",
};

const accountsCardColumnStyle: React.CSSProperties = {
  border: "1px solid #e2e8f0",
  borderRadius: "10px",
  padding: "14px",
  background: "#fff",
  display: "grid",
  gap: "6px",
};

const accountsCardHeaderStyle: React.CSSProperties = {
  display: "flex",
  justifyContent: "space-between",
  alignItems: "center",
};

const accountsCardTitleStyle: React.CSSProperties = {
  fontSize: "15px",
  fontWeight: 700,
};

const accountsBalanceStyle: React.CSSProperties = {
  fontSize: "20px",
  fontWeight: 800,
};

const accountsUpdatedStyle: React.CSSProperties = {
  fontSize: "12px",
  color: "#6b7280",
};

const planCardStyle: React.CSSProperties = {
  backgroundColor: "#ffffff",
  borderRadius: "12px",
  padding: "20px",
  border: "1px solid #e2e8f0",
  boxShadow: "0 1px 2px rgba(15, 23, 42, 0.08)",
  display: "grid",
  gap: "12px",
};

const planHeaderStyle: React.CSSProperties = {
  display: "flex",
  justifyContent: "space-between",
  alignItems: "center",
  gap: 12,
};

const planTitleStyle: React.CSSProperties = {
  fontSize: "18px",
  fontWeight: 700,
  margin: 0,
};

const planSubtitleStyle: React.CSSProperties = {
  fontSize: "14px",
  color: "#4b5563",
  margin: 0,
};

const sectionTitleStyle: React.CSSProperties = {
  fontSize: "16px",
  fontWeight: 700,
  margin: 0,
  color: "#111827",
};

const planDetailsGridStyle: React.CSSProperties = {
  display: "grid",
  gap: "12px",
  gridTemplateColumns: "repeat(auto-fit, minmax(220px, 1fr))",
};

const planDetailLabelStyle: React.CSSProperties = {
  fontSize: "12px",
  color: "#6b7280",
  textTransform: "uppercase",
  letterSpacing: "0.05em",
};

const planDetailValueStyle: React.CSSProperties = {
  fontSize: "14px",
  color: "#111827",
};

const obligationCardStyle: React.CSSProperties = {
  border: "1px solid #e2e8f0",
  borderRadius: "10px",
  padding: "14px",
  background: "#fff",
  display: "grid",
  gap: "6px",
};

const obligationHeaderStyle: React.CSSProperties = {
  display: "flex",
  justifyContent: "space-between",
  alignItems: "center",
};

const obligationTitleStyle: React.CSSProperties = {
  fontSize: "15px",
  fontWeight: 700,
};

const obligationValueStyle: React.CSSProperties = {
  fontSize: "20px",
  fontWeight: 800,
};

const obligationMetaStyle: React.CSSProperties = {
  fontSize: "13px",
  color: "#4b5563",
};



============================================================
FILE: C:\src\apgms-final\webapp\src\CompliancePage.tsx
============================================================
import React, { useEffect, useState } from "react";
import {
  fetchComplianceReport,
  fetchEvidenceArtifacts,
  createEvidenceArtifact,
  fetchEvidenceArtifactDetail,
} from "./api";
import { getToken } from "./auth";
import { ErrorState, SkeletonBlock, StatusChip, StatCard } from "./components/UI";

type ComplianceReport = Awaited<ReturnType<typeof fetchComplianceReport>>;
type PaymentPlan = ComplianceReport["paymentPlans"][number];
type EvidenceArtifactSummary = Awaited<ReturnType<typeof fetchEvidenceArtifacts>>["artifacts"][number];

export default function CompliancePage() {
  const token = getToken();
  const [report, setReport] = useState<ComplianceReport | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [artifacts, setArtifacts] = useState<EvidenceArtifactSummary[]>([]);
  const [artifactLoading, setArtifactLoading] = useState(true);
  const [artifactError, setArtifactError] = useState<string | null>(null);
  const [artifactSuccess, setArtifactSuccess] = useState<string | null>(null);
  const [downloadingId, setDownloadingId] = useState<string | null>(null);

  useEffect(() => {
    if (!token) return;
    void loadReport();
    void loadArtifacts();
  }, [token]);

  async function loadReport() {
    if (!token) return;
    setLoading(true);
    setError(null);
    try {
      const data = await fetchComplianceReport(token);
      setReport(data);
    } catch (err) {
      console.error(err);
      setError("Unable to load compliance report");
    } finally {
      setLoading(false);
    }
  }

  async function loadArtifacts() {
    if (!token) return;
    setArtifactLoading(true);
    setArtifactError(null);
    setArtifactSuccess(null);
    try {
      const response = await fetchEvidenceArtifacts(token);
      setArtifacts(response.artifacts);
    } catch (err) {
      console.error(err);
      setArtifactError("Unable to load evidence history");
    } finally {
      setArtifactLoading(false);
    }
  }

  function handleDownload() {
    window.open("http://localhost:3000/compliance/report", "_blank");
  }

  async function handleGenerateEvidence() {
    if (!token) return;
    setArtifactError(null);
    setArtifactSuccess(null);
    try {
      const response = await createEvidenceArtifact(token);
      setArtifactSuccess(
        `Evidence pack generated (${response.artifact.id.slice(0, 8)}…, sha ${response.artifact.sha256.slice(0, 12)})`
      );
      await loadArtifacts();
    } catch (err) {
      console.error(err);
      setArtifactError("Unable to generate compliance evidence pack");
    }
  }

  async function handleDownloadArtifact(artifactId: string) {
    if (!token) return;
    setDownloadingId(artifactId);
    try {
      const response = await fetchEvidenceArtifactDetail(token, artifactId);
      const blob = new Blob([JSON.stringify(response.artifact.payload ?? {}, null, 2)], {
        type: "application/json",
      });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = `apgms-evidence-${artifactId}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    } catch (err) {
      console.error(err);
      setArtifactError("Unable to download evidence payload");
    } finally {
      setDownloadingId(null);
    }
  }

  if (!token) return null;

  return (
    <div style={{ display: "grid", gap: "24px" }}>
      <header>
        <h1 style={pageTitleStyle}>Compliance Evidence</h1>
        <p style={pageSubtitleStyle}>
          Everything the regulator needs in one place: BAS history, outstanding alerts, and the next due lodgment.
        </p>
      </header>

      {loading && (
        <div style={{ display: "grid", gap: 8 }}>
          <SkeletonBlock width="60%" />
          <SkeletonBlock width="100%" height={120} />
          <SkeletonBlock width="100%" height={120} />
        </div>
      )}
      {error && <ErrorState message={error} onRetry={loadReport} detail="We could not load the compliance report." />}

      {report && !error && (
        <>
          <section style={summaryCardsWrapper}>
            <StatCard title="Next BAS Due" value={report.nextBasDue ? new Date(report.nextBasDue).toLocaleDateString() : "Not scheduled"} />
            <StatCard title="Open High Severity" value={report.alertsSummary.openHighSeverity} tone={report.alertsSummary.openHighSeverity > 0 ? "warning" : "success"} />
            <StatCard title="Resolved This Quarter" value={report.alertsSummary.resolvedThisQuarter} />
            <StatCard title="PAYGW Secured" value={currencyFormatter.format(report.designatedTotals.paygw)} />
            <StatCard title="GST Secured" value={currencyFormatter.format(report.designatedTotals.gst)} />
          </section>

          <section style={cardStyle}>
            <h2 style={sectionTitleStyle}>Payment Plans & Requests</h2>
            {report.paymentPlans.length === 0 ? (
              <div style={infoTextStyle}>No payment plan activity recorded.</div>
            ) : (
              <table style={tableStyle}>
                <thead>
                  <tr>
                    <th style={thStyle}>BAS Cycle</th>
                    <th style={thStyle}>Status</th>
                    <th style={thStyle}>Reason</th>
                    <th style={thStyle}>Weekly Amount</th>
                    <th style={thStyle}>Start Date</th>
                    <th style={thStyle}>Requested</th>
                    <th style={thStyle}>Resolved</th>
                  </tr>
                </thead>
                <tbody>
                  {report.paymentPlans.map((plan) => (
                    <tr key={plan.id}>
                      <td style={tdStyle}>{plan.basCycleId}</td>
                      <td style={tdStyle}><StatusChip tone={statusTone(plan.status)}>{plan.status}</StatusChip></td>
                      <td style={tdStyle}>{plan.reason}</td>
                      <td style={tdStyle}>{formatWeeklyAmount(plan)}</td>
                      <td style={tdStyle}>{formatPlanStartDate(plan)}</td>
                      <td style={tdStyle}>{new Date(plan.requestedAt).toLocaleString()}</td>
                      <td style={tdStyle}>{plan.resolvedAt ? new Date(plan.resolvedAt).toLocaleString() : "Pending"}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            )}
          </section>

          <section style={cardStyle}>
            <div style={cardHeaderStyle}>
              <h2 style={sectionTitleStyle}>BAS Lodgment History</h2>
              <button type="button" className="app-button ghost" onClick={handleDownload}>
                Download compliance pack (JSON)
              </button>
            </div>
            <table style={tableStyle}>
              <thead>
                <tr>
                  <th style={thStyle}>Period</th>
                  <th style={thStyle}>Lodged At</th>
                  <th style={thStyle}>Status</th>
                  <th style={thStyle}>Notes</th>
                </tr>
              </thead>
              <tbody>
                {report.basHistory.map((entry) => (
                  <tr key={entry.period}>
                    <td style={tdStyle}>{entry.period}</td>
                    <td style={tdStyle}>{entry.lodgedAt ? new Date(entry.lodgedAt).toLocaleString() : "Not lodged"}</td>
                    <td style={tdStyle}><StatusChip tone={statusTone(entry.status)}>{entry.status}</StatusChip></td>
                    <td style={tdStyle}>{entry.notes}</td>
                  </tr>
                ))}
              </tbody>
            </table>
            {report.basHistory.length === 0 && <div style={infoTextStyle}>No BAS events recorded yet.</div>}
          </section>

          <section style={cardStyle}>
            <div style={cardHeaderStyle}>
              <h2 style={sectionTitleStyle}>Evidence Pack History</h2>
              <button type="button" className="app-button" onClick={handleGenerateEvidence}>
                Generate new evidence pack
              </button>
            </div>
            {artifactSuccess && <div style={successTextStyle}>{artifactSuccess}</div>}
            {artifactError && <ErrorState message={artifactError} onRetry={loadArtifacts} detail="Could not load or generate evidence." />}
            {artifactLoading ? (
              <SkeletonBlock width="100%" height={100} />
            ) : artifacts.length === 0 ? (
              <div style={infoTextStyle}>No evidence packs have been generated yet.</div>
            ) : (
              <table style={tableStyle}>
                <thead>
                  <tr>
                    <th style={thStyle}>Artifact ID</th>
                    <th style={thStyle}>Created</th>
                    <th style={thStyle}>SHA-256</th>
                    <th style={thStyle}>Actions</th>
                  </tr>
                </thead>
                <tbody>
                  {artifacts.map((artifact) => (
                    <tr key={artifact.id}>
                      <td style={tdStyle}>
                        <code>{artifact.id}</code>
                      </td>
                      <td style={tdStyle}>{new Date(artifact.createdAt).toLocaleString()}</td>
                      <td style={tdStyle}>
                        <code>{artifact.sha256}</code>
                      </td>
                      <td style={tdStyle}>
                        <button
                          type="button"
                          className="app-button ghost"
                          style={{ padding: "6px 12px", fontSize: 12 }}
                          onClick={() => void handleDownloadArtifact(artifact.id)}
                          disabled={downloadingId === artifact.id}
                        >
                          {downloadingId === artifact.id ? "Preparing..." : "Download JSON"}
                        </button>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            )}
          </section>
        </>
      )}
    </div>
  );
}

function statusTone(status: string) {
  const upper = status.toUpperCase();
  if (upper === "READY" || upper === "OK") return "success";
  if (upper === "PARTIAL" || upper === "PENDING") return "warning";
  if (upper === "BLOCKED" || upper === "FAILED") return "danger";
  return "neutral";
}

type SummaryCardProps = {
  label: string;
  value: string;
};

function formatWeeklyAmount(plan: PaymentPlan): string {
  const raw = plan.details["weeklyAmount"];
  if (typeof raw === "number") return currencyFormatter.format(raw);
  if (typeof raw === "string") {
    const parsed = Number(raw);
    if (Number.isFinite(parsed)) return currencyFormatter.format(parsed);
  }
  return "N/A";
}

function formatPlanStartDate(plan: PaymentPlan): string {
  const raw = plan.details["startDate"];
  if (typeof raw === "string" && raw.trim().length > 0) {
    const parsed = new Date(raw);
    if (!Number.isNaN(parsed.getTime())) return parsed.toLocaleDateString();
    return raw;
  }
  return "N/A";
}

const currencyFormatter = new Intl.NumberFormat("en-AU", { style: "currency", currency: "AUD" });

const pageTitleStyle: React.CSSProperties = {
  fontSize: "24px",
  fontWeight: 700,
  marginBottom: "8px",
};

const pageSubtitleStyle: React.CSSProperties = {
  color: "#4b5563",
  margin: 0,
  fontSize: "14px",
  maxWidth: "600px",
};

const infoTextStyle: React.CSSProperties = {
  fontSize: "14px",
  color: "#6b7280",
};

const successTextStyle: React.CSSProperties = {
  fontSize: "14px",
  color: "#047857",
};

const summaryCardsWrapper: React.CSSProperties = {
  display: "grid",
  gap: "16px",
  gridTemplateColumns: "repeat(auto-fit, minmax(180px, 1fr))",
};

const cardStyle: React.CSSProperties = {
  backgroundColor: "#ffffff",
  borderRadius: "12px",
  padding: "24px",
  border: "1px solid #e2e8f0",
  boxShadow: "0 1px 2px rgba(15, 23, 42, 0.08)",
};

const cardHeaderStyle: React.CSSProperties = {
  display: "flex",
  justifyContent: "space-between",
  alignItems: "center",
  marginBottom: "16px",
  gap: "12px",
  flexWrap: "wrap",
};

const sectionTitleStyle: React.CSSProperties = {
  fontSize: "18px",
  fontWeight: 600,
  margin: 0,
};

const tableStyle: React.CSSProperties = {
  borderCollapse: "collapse",
  width: "100%",
};

const thStyle: React.CSSProperties = {
  textAlign: "left",
  padding: "10px 12px",
  fontSize: "12px",
  textTransform: "uppercase",
  letterSpacing: "0.06em",
  color: "#6b7280",
  borderBottom: "1px solid #e5e7eb",
};

const tdStyle: React.CSSProperties = {
  padding: "12px",
  fontSize: "14px",
  borderBottom: "1px solid #f1f5f9",
  color: "#111827",
};



============================================================
FILE: C:\src\apgms-final\webapp\src\components\UI.tsx
============================================================
import React from "react";

type Tone = "neutral" | "success" | "warning" | "danger";

export function StatusChip({
  tone = "neutral",
  children,
}: {
  tone?: Tone;
  children: React.ReactNode;
}) {
  return <span className={`app-chip ${tone === "neutral" ? "" : tone}`}>{children}</span>;
}

export function SkeletonBlock({
  width = "100%",
  height = 16,
  style,
}: {
  width?: number | string;
  height?: number | string;
  style?: React.CSSProperties;
}) {
  return (
    <div
      className="app-skeleton"
      style={{
        width,
        height,
        ...style,
      }}
    />
  );
}

export function ErrorState({
  message,
  detail,
  onRetry,
}: {
  message: string;
  detail?: string;
  onRetry?: () => void;
}) {
  return (
    <div style={{ border: "1px solid var(--border)", borderRadius: 10, padding: 12, color: "var(--danger)" }}>
      <div style={{ fontWeight: 700, marginBottom: 4 }}>{message}</div>
      {detail && <div style={{ fontSize: 13, color: "var(--muted)" }}>{detail}</div>}
      {onRetry && (
        <button
          type="button"
          className="app-button ghost"
          style={{ padding: "6px 10px", marginTop: 8, fontSize: 13 }}
          onClick={onRetry}
        >
          Retry
        </button>
      )}
    </div>
  );
}

export function StatCard({
  title,
  value,
  subtitle,
  tone = "neutral",
}: {
  title: string;
  value: React.ReactNode;
  subtitle?: string;
  tone?: Tone;
}) {
  const toneColor =
    tone === "success" ? "var(--success)" : tone === "warning" ? "var(--warning)" : tone === "danger" ? "var(--danger)" : "var(--text)";
  return (
    <div className="app-card" style={{ display: "grid", gap: 6 }}>
      <div style={{ fontSize: 13, color: "var(--muted)" }}>{title}</div>
      <div style={{ fontSize: 22, fontWeight: 800, color: toneColor }}>{value}</div>
      {subtitle && <div style={{ fontSize: 13, color: "var(--muted)" }}>{subtitle}</div>}
    </div>
  );
}



============================================================
FILE: C:\src\apgms-final\webapp\src\Dashboard.tsx
============================================================
// services/webapp/src/Dashboard.tsx
import React, { useEffect, useState } from "react";
import { getBankLines, createBankLine } from "./api";

interface Props {
  token: string;
}

export default function Dashboard({ token }: Props) {
  const [lines, setLines] = useState<
    Array<{
      id: string;
      postedAt: string;
      amount: number;
      description: string;
      createdAt: string;
    }>
  >([]);

  const [date, setDate] = useState("2025-01-01T00:00:00.000Z");
  const [amount, setAmount] = useState("123.45");
  const [payee, setPayee] = useState("Test Vendor");
  const [desc, setDesc] = useState("Laptop purchase");
  const [err, setErr] = useState("");

  async function refresh() {
    setErr("");
    try {
      const data = await getBankLines(token);
      setLines(data.lines);
    } catch (e: any) {
      setErr(e.message || "Failed to load");
    }
  }

  async function handleCreate(e: React.FormEvent) {
    e.preventDefault();
    setErr("");
    try {
      await createBankLine(token, {
        date,
        amount,
        payee,
        desc,
      });
      await refresh();
    } catch (e: any) {
      setErr(e.message || "Failed to create");
    }
  }

  useEffect(() => {
    refresh();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return (
    <div style={{ fontFamily: "sans-serif", padding: "2rem", maxWidth: 800, margin: "0 auto" }}>
      <h2>Dashboard</h2>
      {err && <div style={{ color: "red" }}>{err}</div>}

      <section style={{ marginBottom: "2rem" }}>
        <h3>New Ledger Line</h3>
        <form
          onSubmit={handleCreate}
          style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: "0.75rem", maxWidth: 600 }}
        >
          <label style={{ gridColumn: "span 2" }}>
            Date (ISO)
            <input
              style={{ width: "100%" }}
              value={date}
              onChange={(e) => setDate(e.target.value)}
            />
          </label>

          <label>
            Amount
            <input
              style={{ width: "100%" }}
              value={amount}
              onChange={(e) => setAmount(e.target.value)}
            />
          </label>

          <label>
            Payee
            <input
              style={{ width: "100%" }}
              value={payee}
              onChange={(e) => setPayee(e.target.value)}
            />
          </label>

          <label style={{ gridColumn: "span 2" }}>
            Description
            <input
              style={{ width: "100%" }}
              value={desc}
              onChange={(e) => setDesc(e.target.value)}
            />
          </label>

          <div style={{ gridColumn: "span 2", textAlign: "right" }}>
            <button
              style={{
                padding: "0.5rem 1rem",
                background: "black",
                color: "white",
                borderRadius: 4,
              }}
              type="submit"
            >
              Add line
            </button>
          </div>
        </form>
      </section>

      <section>
        <h3>Bank Lines</h3>
        <table
          style={{
            width: "100%",
            borderCollapse: "collapse",
            fontSize: "0.9rem",
          }}
        >
          <thead>
            <tr>
              <th style={{ textAlign: "left", borderBottom: "1px solid #ccc" }}>ID</th>
              <th style={{ textAlign: "left", borderBottom: "1px solid #ccc" }}>Date</th>
              <th style={{ textAlign: "right", borderBottom: "1px solid #ccc" }}>Amount</th>
              <th style={{ textAlign: "left", borderBottom: "1px solid #ccc" }}>Desc</th>
              <th style={{ textAlign: "left", borderBottom: "1px solid #ccc" }}>Created</th>
            </tr>
          </thead>
          <tbody>
            {lines.map((ln) => (
              <tr key={ln.id}>
                <td style={{ borderBottom: "1px solid #eee", padding: "4px 0" }}>{ln.id}</td>
                <td style={{ borderBottom: "1px solid #eee", padding: "4px 0" }}>
                  {new Date(ln.postedAt).toISOString()}
                </td>
                <td style={{ borderBottom: "1px solid #eee", padding: "4px 0", textAlign: "right" }}>
                  {ln.amount}
                </td>
                <td style={{ borderBottom: "1px solid #eee", padding: "4px 0" }}>
                  {ln.description /* always '***' from API, thatâ€™s intentional */}
                </td>
                <td style={{ borderBottom: "1px solid #eee", padding: "4px 0" }}>
                  {new Date(ln.createdAt).toISOString()}
                </td>
              </tr>
            ))}
            {lines.length === 0 && (
              <tr>
                <td colSpan={5} style={{ padding: "1rem", textAlign: "center", color: "#888" }}>
                  No lines yet
                </td>
              </tr>
            )}
          </tbody>
        </table>
      </section>
    </div>
  );
}



============================================================
FILE: C:\src\apgms-final\webapp\src\DashboardPage.tsx
============================================================
import React, { useEffect, useMemo, useState } from "react";
import {
  fetchBankLines,
  fetchCurrentObligations,
  createBankLine,
  fetchDesignatedAccounts,
} from "./api";
import { getToken } from "./auth";
import { ErrorState, SkeletonBlock, StatCard, StatusChip } from "./components/UI";

type Obligations = Awaited<ReturnType<typeof fetchCurrentObligations>>;
type BankLine = Awaited<ReturnType<typeof fetchBankLines>>["lines"][number];
type DesignatedAccounts = Awaited<ReturnType<typeof fetchDesignatedAccounts>>;

const currencyFormatter = new Intl.NumberFormat("en-AU", {
  style: "currency",
  currency: "AUD",
  minimumFractionDigits: 2,
});

export default function DashboardPage() {
  const token = getToken();
  const [obligations, setObligations] = useState<Obligations | null>(null);
  const [bankLines, setBankLines] = useState<BankLine[]>([]);
  const [designated, setDesignated] = useState<DesignatedAccounts | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [designatedError, setDesignatedError] = useState<string | null>(null);
  const [formError, setFormError] = useState<string | null>(null);
  const [formState, setFormState] = useState({
    date: new Date().toISOString(),
    amount: "123.45",
    payee: "ATO Sweep",
    desc: "PAYGW escrow capture",
  });

  useEffect(() => {
    if (!token) return;
    void loadData();
  }, [token]);

  async function loadData() {
    if (!token) return;
    setLoading(true);
    setError(null);
    setDesignatedError(null);
    try {
      const [obligationsResponse, bankLinesResponse] = await Promise.all([
        fetchCurrentObligations(token),
        fetchBankLines(token),
      ]);
      setObligations(obligationsResponse);
      setBankLines(bankLinesResponse.lines);
    } catch (err) {
      console.error(err);
      setError("Unable to load dashboard data");
      setLoading(false);
      return;
    }

    try {
      const designatedResponse = await fetchDesignatedAccounts(token);
      setDesignated(designatedResponse);
      setDesignatedError(null);
    } catch (designatedErr) {
      console.error(designatedErr);
      setDesignatedError("Unable to load designated account balances");
    }
    setLoading(false);
  }

  const paygwGap = useMemo(() => {
    if (!obligations) return 0;
    return Math.max(0, obligations.paygw.required - obligations.paygw.secured);
  }, [obligations]);

  const gstGap = useMemo(() => {
    if (!obligations) return 0;
    return Math.max(0, obligations.gst.required - obligations.gst.secured);
  }, [obligations]);

  const nextBasDueDisplay = useMemo(() => {
    if (!obligations?.nextBasDue) return "Not scheduled";
    return new Date(obligations.nextBasDue).toLocaleString();
  }, [obligations]);

  const paygwDesignatedAccount = useMemo(
    () =>
      designated?.accounts.find(
        (account) => account.type.toUpperCase() === "PAYGW"
      ) ?? null,
    [designated]
  );

  const gstDesignatedAccount = useMemo(
    () =>
      designated?.accounts.find(
        (account) => account.type.toUpperCase() === "GST"
      ) ?? null,
    [designated]
  );

  async function handleCreateLine(e: React.FormEvent<HTMLFormElement>) {
    e.preventDefault();
    setFormError(null);
    if (!token) return;
    try {
      await createBankLine(token, formState);
      const refreshed = await fetchBankLines(token);
      setBankLines(refreshed.lines);
    } catch (err) {
      console.error(err);
      setFormError("Unable to create ledger entry");
    }
  }

  if (!token) return null;

  return (
    <div style={{ display: "grid", gap: "24px" }}>
      <header>
        <h1 style={pageTitleStyle}>Compliance Control Room</h1>
        <p style={pageSubtitleStyle}>
          Snapshot of PAYGW and GST obligations, plus the ledger evidence we share with the ATO to prove funds are secured.
        </p>
      </header>

      {loading && (
        <div style={{ display: "grid", gap: 8 }}>
          <SkeletonBlock width="50%" />
          <SkeletonBlock width="100%" height={120} />
          <SkeletonBlock width="100%" height={160} />
        </div>
      )}
      {error && <ErrorState message={error} onRetry={loadData} detail="We could not load dashboard data." />}

      {obligations && !error && (
        <>
          <section style={summaryGridStyle}>
            <StatCard
              title="PAYGW"
              value={`${currencyFormatter.format(obligations.paygw.secured)} / ${currencyFormatter.format(obligations.paygw.required)}`}
              subtitle={`Status: ${obligations.paygw.status}`}
              tone={statusTone(obligations.paygw.status)}
            />
            <StatCard
              title="GST"
              value={`${currencyFormatter.format(obligations.gst.secured)} / ${currencyFormatter.format(obligations.gst.required)}`}
              subtitle={`Status: ${obligations.gst.status}`}
              tone={statusTone(obligations.gst.status)}
            />
            <StatCard title="Shortfall" value={currencyFormatter.format(paygwGap + gstGap)} tone={paygwGap + gstGap > 0 ? "warning" : "success"} />
            <StatCard title="Next BAS Due" value={nextBasDueDisplay} />
          </section>

          {(designated || designatedError) && (
            <section style={designatedSectionStyle}>
              <div style={designatedHeaderStyle}>
                <h2 style={designatedTitleStyle}>Designated Accounts</h2>
                <p style={designatedSubtitleStyle}>
                  PAYGW and GST cash is ringfenced in inbound-only accounts. Shortfalls appear here before BAS lodgment.
                </p>
              </div>
              {designatedError && <ErrorState message={designatedError} detail="Holding account balances unavailable." />}
              {!designated && !designatedError && (
                <div style={{ display: "grid", gap: 8 }}>
                  <SkeletonBlock width="100%" height={60} />
                  <SkeletonBlock width="100%" height={60} />
                </div>
              )}
              {designated && (
                <div style={designatedGridStyle}>
                  <DesignatedAccountCard
                    title="PAYGW Holding Account"
                    account={paygwDesignatedAccount}
                    required={obligations.paygw.required}
                  />
                  <DesignatedAccountCard
                    title="GST Holding Account"
                    account={gstDesignatedAccount}
                    required={obligations.gst.required}
                  />
                </div>
              )}
            </section>
          )}

          <section style={ledgerCardStyle}>
            <div style={ledgerHeaderStyle}>
              <div>
                <h2 style={ledgerTitleStyle}>Bank Ledger Evidence</h2>
                <p style={ledgerSubtitleStyle}>
                  Every protected withdrawal or capture is audited. Shortfall right now: {currencyFormatter.format(paygwGap + gstGap)}.
                </p>
              </div>
            </div>

            <div style={{ overflowX: "auto" }}>
              <table style={tableStyle}>
                <thead>
                  <tr>
                    <th style={thStyle}>ID</th>
                    <th style={thStyle}>Posted</th>
                    <th style={thStyle}>Amount</th>
                    <th style={thStyle}>Description</th>
                    <th style={thStyle}>Created</th>
                  </tr>
                </thead>
                <tbody>
                  {bankLines.map((line) => (
                    <tr key={line.id}>
                      <td style={tdStyle}>{line.id}</td>
                      <td style={tdStyle}>{new Date(line.postedAt).toLocaleString()}</td>
                      <td style={tdStyle}>{currencyFormatter.format(line.amount)}</td>
                      <td style={tdStyle}>{line.description}</td>
                      <td style={tdStyle}>{new Date(line.createdAt).toLocaleString()}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
              {bankLines.length === 0 && (
                <div style={{ ...infoTextStyle, padding: "12px 0" }}>
                  No ledger activity recorded yet.
                </div>
              )}
            </div>

            <form onSubmit={handleCreateLine} style={ledgerFormStyle}>
              <div style={formGridStyle}>
                <label style={formLabelStyle}>
                  <span>Date (ISO)</span>
                  <input
                    style={formInputStyle}
                    value={formState.date}
                    onChange={(e) => setFormState((prev) => ({ ...prev, date: e.target.value }))}
                  />
                </label>
                <label style={formLabelStyle}>
                  <span>Amount (AUD)</span>
                  <input
                    style={formInputStyle}
                    value={formState.amount}
                    onChange={(e) => setFormState((prev) => ({ ...prev, amount: e.target.value }))}
                  />
                </label>
                <label style={formLabelStyle}>
                  <span>Payee</span>
                  <input
                    style={formInputStyle}
                    value={formState.payee}
                    onChange={(e) => setFormState((prev) => ({ ...prev, payee: e.target.value }))}
                  />
                </label>
                <label style={formLabelStyle}>
                  <span>Description</span>
                  <input
                    style={formInputStyle}
                    value={formState.desc}
                    onChange={(e) => setFormState((prev) => ({ ...prev, desc: e.target.value }))}
                  />
                </label>
              </div>
              {formError && <div style={errorTextStyle}>{formError}</div>}
              <div>
                <button type="submit" className="app-button">
                  Create ledger entry
                </button>
              </div>
            </form>
          </section>
        </>
      )}
    </div>
  );
}

function statusTone(status: string) {
  const upper = status.toUpperCase();
  if (upper === "READY" || upper === "OK") return "success";
  if (upper === "SHORT" || upper === "BLOCKED" || upper === "ALERT") return "warning";
  return "neutral";
}

function DesignatedAccountCard({
  title,
  account,
  required,
}: {
  title: string;
  account: DesignatedAccounts["accounts"][number] | null;
  required: number;
}) {
  const balance = account?.balance ?? 0;
  const tone = balance >= required ? "success" : balance > 0 ? "warning" : "danger";
  return (
    <div style={designatedCardStyle}>
      <div style={designatedCardHeaderStyle}>
        <div>
          <div style={designatedCardTitleStyle}>{title}</div>
          <div style={designatedCardSubStyle}>Inbound-only</div>
        </div>
        <StatusChip tone={tone}>{balance >= required ? "Covered" : balance > 0 ? "Partial" : "Short"}</StatusChip>
      </div>
      <div style={designatedBalanceStyle}>{currencyFormatter.format(balance)}</div>
      <div style={designatedMetaStyle}>
        Last updated {account?.updatedAt ? new Date(account.updatedAt).toLocaleString() : "N/A"}
      </div>
    </div>
  );
}

const pageTitleStyle: React.CSSProperties = {
  fontSize: "24px",
  fontWeight: 700,
  marginBottom: "8px",
};

const pageSubtitleStyle: React.CSSProperties = {
  color: "#4b5563",
  margin: 0,
  fontSize: "14px",
  maxWidth: "700px",
};

const summaryGridStyle: React.CSSProperties = {
  display: "grid",
  gap: "12px",
  gridTemplateColumns: "repeat(auto-fit, minmax(200px, 1fr))",
};

const designatedSectionStyle: React.CSSProperties = {
  backgroundColor: "#ffffff",
  borderRadius: "12px",
  padding: "20px",
  border: "1px solid #e2e8f0",
  boxShadow: "0 1px 2px rgba(15, 23, 42, 0.08)",
  display: "grid",
  gap: "12px",
};

const designatedHeaderStyle: React.CSSProperties = {
  display: "grid",
  gap: "4px",
};

const designatedTitleStyle: React.CSSProperties = {
  fontSize: "18px",
  fontWeight: 700,
  margin: 0,
};

const designatedSubtitleStyle: React.CSSProperties = {
  fontSize: "14px",
  color: "#4b5563",
  margin: 0,
};

const designatedGridStyle: React.CSSProperties = {
  display: "grid",
  gap: "12px",
  gridTemplateColumns: "repeat(auto-fit, minmax(240px, 1fr))",
};

const designatedCardStyle: React.CSSProperties = {
  border: "1px solid #e2e8f0",
  borderRadius: "10px",
  padding: "14px",
  background: "#fff",
  display: "grid",
  gap: "6px",
};

const designatedCardHeaderStyle: React.CSSProperties = {
  display: "flex",
  justifyContent: "space-between",
  alignItems: "center",
};

const designatedCardTitleStyle: React.CSSProperties = {
  fontSize: "15px",
  fontWeight: 700,
};

const designatedCardSubStyle: React.CSSProperties = {
  fontSize: "12px",
  color: "#64748b",
